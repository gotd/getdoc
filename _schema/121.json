{
  "index": {
    "layer": 121,
    "categories": [
      {
        "name": "constructor",
        "values": [
          "account.authorizationForm",
          "account.authorizations",
          "account.autoDownloadSettings",
          "account.contentSettings",
          "account.password",
          "account.passwordInputSettings",
          "account.passwordSettings",
          "account.privacyRules",
          "account.sentEmailCode",
          "account.takeout",
          "account.themes",
          "account.themesNotModified",
          "account.tmpPassword",
          "account.wallPapers",
          "account.wallPapersNotModified",
          "account.webAuthorizations",
          "accountDaysTTL",
          "auth.authorization",
          "auth.authorizationSignUpRequired",
          "auth.codeTypeCall",
          "auth.codeTypeFlashCall",
          "auth.codeTypeSms",
          "auth.exportedAuthorization",
          "auth.loginToken",
          "auth.loginTokenMigrateTo",
          "auth.loginTokenSuccess",
          "auth.passwordRecovery",
          "auth.sentCode",
          "auth.sentCodeTypeApp",
          "auth.sentCodeTypeCall",
          "auth.sentCodeTypeFlashCall",
          "auth.sentCodeTypeSms",
          "authorization",
          "autoDownloadSettings",
          "bankCardOpenUrl",
          "baseThemeArctic",
          "baseThemeClassic",
          "baseThemeDay",
          "baseThemeNight",
          "baseThemeTinted",
          "boolFalse",
          "boolTrue",
          "botCommand",
          "botInfo",
          "botInlineMediaResult",
          "botInlineMessageMediaAuto",
          "botInlineMessageMediaContact",
          "botInlineMessageMediaGeo",
          "botInlineMessageMediaVenue",
          "botInlineMessageText",
          "botInlineResult",
          "cdnConfig",
          "cdnPublicKey",
          "channel",
          "channelAdminLogEvent",
          "channelAdminLogEventActionChangeAbout",
          "channelAdminLogEventActionChangeLinkedChat",
          "channelAdminLogEventActionChangeLocation",
          "channelAdminLogEventActionChangePhoto",
          "channelAdminLogEventActionChangeStickerSet",
          "channelAdminLogEventActionChangeTitle",
          "channelAdminLogEventActionChangeUsername",
          "channelAdminLogEventActionDefaultBannedRights",
          "channelAdminLogEventActionDeleteMessage",
          "channelAdminLogEventActionEditMessage",
          "channelAdminLogEventActionParticipantInvite",
          "channelAdminLogEventActionParticipantJoin",
          "channelAdminLogEventActionParticipantLeave",
          "channelAdminLogEventActionParticipantToggleAdmin",
          "channelAdminLogEventActionParticipantToggleBan",
          "channelAdminLogEventActionStopPoll",
          "channelAdminLogEventActionToggleInvites",
          "channelAdminLogEventActionTogglePreHistoryHidden",
          "channelAdminLogEventActionToggleSignatures",
          "channelAdminLogEventActionToggleSlowMode",
          "channelAdminLogEventActionUpdatePinned",
          "channelAdminLogEventsFilter",
          "channelForbidden",
          "channelFull",
          "channelLocation",
          "channelLocationEmpty",
          "channelMessagesFilter",
          "channelMessagesFilterEmpty",
          "channelParticipant",
          "channelParticipantAdmin",
          "channelParticipantBanned",
          "channelParticipantCreator",
          "channelParticipantLeft",
          "channelParticipantSelf",
          "channelParticipantsAdmins",
          "channelParticipantsBanned",
          "channelParticipantsBots",
          "channelParticipantsContacts",
          "channelParticipantsKicked",
          "channelParticipantsMentions",
          "channelParticipantsRecent",
          "channelParticipantsSearch",
          "channels.adminLogResults",
          "channels.channelParticipant",
          "channels.channelParticipants",
          "channels.channelParticipantsNotModified",
          "chat",
          "chatAdminRights",
          "chatBannedRights",
          "chatEmpty",
          "chatForbidden",
          "chatFull",
          "chatInvite",
          "chatInviteAlready",
          "chatInviteEmpty",
          "chatInviteExported",
          "chatInvitePeek",
          "chatOnlines",
          "chatParticipant",
          "chatParticipantAdmin",
          "chatParticipantCreator",
          "chatParticipants",
          "chatParticipantsForbidden",
          "chatPhoto",
          "chatPhotoEmpty",
          "codeSettings",
          "config",
          "contact",
          "contactStatus",
          "contacts.blocked",
          "contacts.blockedSlice",
          "contacts.contacts",
          "contacts.contactsNotModified",
          "contacts.found",
          "contacts.importedContacts",
          "contacts.resolvedPeer",
          "contacts.topPeers",
          "contacts.topPeersDisabled",
          "contacts.topPeersNotModified",
          "dataJSON",
          "dcOption",
          "dialog",
          "dialogFilter",
          "dialogFilterSuggested",
          "dialogFolder",
          "dialogPeer",
          "dialogPeerFolder",
          "document",
          "documentAttributeAnimated",
          "documentAttributeAudio",
          "documentAttributeFilename",
          "documentAttributeHasStickers",
          "documentAttributeImageSize",
          "documentAttributeSticker",
          "documentAttributeVideo",
          "documentEmpty",
          "draftMessage",
          "draftMessageEmpty",
          "emojiKeyword",
          "emojiKeywordDeleted",
          "emojiKeywordsDifference",
          "emojiLanguage",
          "emojiURL",
          "encryptedChat",
          "encryptedChatDiscarded",
          "encryptedChatEmpty",
          "encryptedChatRequested",
          "encryptedChatWaiting",
          "encryptedFile",
          "encryptedFileEmpty",
          "encryptedMessage",
          "encryptedMessageService",
          "error",
          "exportedMessageLink",
          "fileHash",
          "fileLocationToBeDeprecated",
          "folder",
          "folderPeer",
          "game",
          "geoPoint",
          "geoPointEmpty",
          "globalPrivacySettings",
          "help.appUpdate",
          "help.countriesList",
          "help.countriesListNotModified",
          "help.country",
          "help.countryCode",
          "help.deepLinkInfo",
          "help.deepLinkInfoEmpty",
          "help.inviteText",
          "help.noAppUpdate",
          "help.passportConfig",
          "help.passportConfigNotModified",
          "help.promoData",
          "help.promoDataEmpty",
          "help.recentMeUrls",
          "help.support",
          "help.supportName",
          "help.termsOfService",
          "help.termsOfServiceUpdate",
          "help.termsOfServiceUpdateEmpty",
          "help.userInfo",
          "help.userInfoEmpty",
          "highScore",
          "importedContact",
          "inlineBotSwitchPM",
          "inputAppEvent",
          "inputBotInlineMessageGame",
          "inputBotInlineMessageID",
          "inputBotInlineMessageMediaAuto",
          "inputBotInlineMessageMediaContact",
          "inputBotInlineMessageMediaGeo",
          "inputBotInlineMessageMediaVenue",
          "inputBotInlineMessageText",
          "inputBotInlineResult",
          "inputBotInlineResultDocument",
          "inputBotInlineResultGame",
          "inputBotInlineResultPhoto",
          "inputChannel",
          "inputChannelEmpty",
          "inputChannelFromMessage",
          "inputChatPhoto",
          "inputChatPhotoEmpty",
          "inputChatUploadedPhoto",
          "inputCheckPasswordEmpty",
          "inputCheckPasswordSRP",
          "inputClientProxy",
          "inputDialogPeer",
          "inputDialogPeerFolder",
          "inputDocument",
          "inputDocumentEmpty",
          "inputDocumentFileLocation",
          "inputEncryptedChat",
          "inputEncryptedFile",
          "inputEncryptedFileBigUploaded",
          "inputEncryptedFileEmpty",
          "inputEncryptedFileLocation",
          "inputEncryptedFileUploaded",
          "inputFile",
          "inputFileBig",
          "inputFileLocation",
          "inputFolderPeer",
          "inputGameID",
          "inputGameShortName",
          "inputGeoPoint",
          "inputGeoPointEmpty",
          "inputKeyboardButtonUrlAuth",
          "inputMediaContact",
          "inputMediaDice",
          "inputMediaDocument",
          "inputMediaDocumentExternal",
          "inputMediaEmpty",
          "inputMediaGame",
          "inputMediaGeoLive",
          "inputMediaGeoPoint",
          "inputMediaInvoice",
          "inputMediaPhoto",
          "inputMediaPhotoExternal",
          "inputMediaPoll",
          "inputMediaUploadedDocument",
          "inputMediaUploadedPhoto",
          "inputMediaVenue",
          "inputMessageCallbackQuery",
          "inputMessageEntityMentionName",
          "inputMessageID",
          "inputMessagePinned",
          "inputMessageReplyTo",
          "inputMessagesFilterChatPhotos",
          "inputMessagesFilterContacts",
          "inputMessagesFilterDocument",
          "inputMessagesFilterEmpty",
          "inputMessagesFilterGeo",
          "inputMessagesFilterGif",
          "inputMessagesFilterMusic",
          "inputMessagesFilterMyMentions",
          "inputMessagesFilterPhoneCalls",
          "inputMessagesFilterPhotoVideo",
          "inputMessagesFilterPhotos",
          "inputMessagesFilterPinned",
          "inputMessagesFilterRoundVideo",
          "inputMessagesFilterRoundVoice",
          "inputMessagesFilterUrl",
          "inputMessagesFilterVideo",
          "inputMessagesFilterVoice",
          "inputNotifyBroadcasts",
          "inputNotifyChats",
          "inputNotifyPeer",
          "inputNotifyUsers",
          "inputPaymentCredentials",
          "inputPaymentCredentialsAndroidPay",
          "inputPaymentCredentialsApplePay",
          "inputPaymentCredentialsSaved",
          "inputPeerChannel",
          "inputPeerChannelFromMessage",
          "inputPeerChat",
          "inputPeerEmpty",
          "inputPeerNotifySettings",
          "inputPeerPhotoFileLocation",
          "inputPeerSelf",
          "inputPeerUser",
          "inputPeerUserFromMessage",
          "inputPhoneCall",
          "inputPhoneContact",
          "inputPhoto",
          "inputPhotoEmpty",
          "inputPhotoFileLocation",
          "inputPhotoLegacyFileLocation",
          "inputPrivacyKeyAddedByPhone",
          "inputPrivacyKeyChatInvite",
          "inputPrivacyKeyForwards",
          "inputPrivacyKeyPhoneCall",
          "inputPrivacyKeyPhoneNumber",
          "inputPrivacyKeyPhoneP2P",
          "inputPrivacyKeyProfilePhoto",
          "inputPrivacyKeyStatusTimestamp",
          "inputPrivacyValueAllowAll",
          "inputPrivacyValueAllowChatParticipants",
          "inputPrivacyValueAllowContacts",
          "inputPrivacyValueAllowUsers",
          "inputPrivacyValueDisallowAll",
          "inputPrivacyValueDisallowChatParticipants",
          "inputPrivacyValueDisallowContacts",
          "inputPrivacyValueDisallowUsers",
          "inputReportReasonChildAbuse",
          "inputReportReasonCopyright",
          "inputReportReasonGeoIrrelevant",
          "inputReportReasonOther",
          "inputReportReasonPornography",
          "inputReportReasonSpam",
          "inputReportReasonViolence",
          "inputSecureFile",
          "inputSecureFileLocation",
          "inputSecureFileUploaded",
          "inputSecureValue",
          "inputSingleMedia",
          "inputStickerSetAnimatedEmoji",
          "inputStickerSetDice",
          "inputStickerSetEmpty",
          "inputStickerSetID",
          "inputStickerSetItem",
          "inputStickerSetShortName",
          "inputStickerSetThumb",
          "inputStickeredMediaDocument",
          "inputStickeredMediaPhoto",
          "inputTakeoutFileLocation",
          "inputTheme",
          "inputThemeSettings",
          "inputThemeSlug",
          "inputUser",
          "inputUserEmpty",
          "inputUserFromMessage",
          "inputUserSelf",
          "inputWallPaper",
          "inputWallPaperNoFile",
          "inputWallPaperSlug",
          "inputWebDocument",
          "inputWebFileGeoPointLocation",
          "inputWebFileLocation",
          "invoice",
          "jsonArray",
          "jsonBool",
          "jsonNull",
          "jsonNumber",
          "jsonObject",
          "jsonObjectValue",
          "jsonString",
          "keyboardButton",
          "keyboardButtonBuy",
          "keyboardButtonCallback",
          "keyboardButtonGame",
          "keyboardButtonRequestGeoLocation",
          "keyboardButtonRequestPhone",
          "keyboardButtonRequestPoll",
          "keyboardButtonRow",
          "keyboardButtonSwitchInline",
          "keyboardButtonUrl",
          "keyboardButtonUrlAuth",
          "labeledPrice",
          "langPackDifference",
          "langPackLanguage",
          "langPackString",
          "langPackStringDeleted",
          "langPackStringPluralized",
          "maskCoords",
          "message",
          "messageActionBotAllowed",
          "messageActionChannelCreate",
          "messageActionChannelMigrateFrom",
          "messageActionChatAddUser",
          "messageActionChatCreate",
          "messageActionChatDeletePhoto",
          "messageActionChatDeleteUser",
          "messageActionChatEditPhoto",
          "messageActionChatEditTitle",
          "messageActionChatJoinedByLink",
          "messageActionChatMigrateTo",
          "messageActionContactSignUp",
          "messageActionCustomAction",
          "messageActionEmpty",
          "messageActionGameScore",
          "messageActionGeoProximityReached",
          "messageActionHistoryClear",
          "messageActionPaymentSent",
          "messageActionPaymentSentMe",
          "messageActionPhoneCall",
          "messageActionPinMessage",
          "messageActionScreenshotTaken",
          "messageActionSecureValuesSent",
          "messageActionSecureValuesSentMe",
          "messageEmpty",
          "messageEntityBankCard",
          "messageEntityBlockquote",
          "messageEntityBold",
          "messageEntityBotCommand",
          "messageEntityCashtag",
          "messageEntityCode",
          "messageEntityEmail",
          "messageEntityHashtag",
          "messageEntityItalic",
          "messageEntityMention",
          "messageEntityMentionName",
          "messageEntityPhone",
          "messageEntityPre",
          "messageEntityStrike",
          "messageEntityTextUrl",
          "messageEntityUnderline",
          "messageEntityUnknown",
          "messageEntityUrl",
          "messageFwdHeader",
          "messageInteractionCounters",
          "messageMediaContact",
          "messageMediaDice",
          "messageMediaDocument",
          "messageMediaEmpty",
          "messageMediaGame",
          "messageMediaGeo",
          "messageMediaGeoLive",
          "messageMediaInvoice",
          "messageMediaPhoto",
          "messageMediaPoll",
          "messageMediaUnsupported",
          "messageMediaVenue",
          "messageMediaWebPage",
          "messageRange",
          "messageReplies",
          "messageReplyHeader",
          "messageService",
          "messageUserVote",
          "messageUserVoteInputOption",
          "messageUserVoteMultiple",
          "messageViews",
          "messages.affectedHistory",
          "messages.affectedMessages",
          "messages.allStickers",
          "messages.allStickersNotModified",
          "messages.archivedStickers",
          "messages.botCallbackAnswer",
          "messages.botResults",
          "messages.channelMessages",
          "messages.chatFull",
          "messages.chats",
          "messages.chatsSlice",
          "messages.dhConfig",
          "messages.dhConfigNotModified",
          "messages.dialogs",
          "messages.dialogsNotModified",
          "messages.dialogsSlice",
          "messages.discussionMessage",
          "messages.favedStickers",
          "messages.favedStickersNotModified",
          "messages.featuredStickers",
          "messages.featuredStickersNotModified",
          "messages.foundStickerSets",
          "messages.foundStickerSetsNotModified",
          "messages.highScores",
          "messages.inactiveChats",
          "messages.messageEditData",
          "messages.messageViews",
          "messages.messages",
          "messages.messagesNotModified",
          "messages.messagesSlice",
          "messages.peerDialogs",
          "messages.recentStickers",
          "messages.recentStickersNotModified",
          "messages.savedGifs",
          "messages.savedGifsNotModified",
          "messages.searchCounter",
          "messages.sentEncryptedFile",
          "messages.sentEncryptedMessage",
          "messages.stickerSet",
          "messages.stickerSetInstallResultArchive",
          "messages.stickerSetInstallResultSuccess",
          "messages.stickers",
          "messages.stickersNotModified",
          "messages.votesList",
          "nearestDc",
          "notifyBroadcasts",
          "notifyChats",
          "notifyPeer",
          "notifyUsers",
          "null",
          "page",
          "pageBlockAnchor",
          "pageBlockAudio",
          "pageBlockAuthorDate",
          "pageBlockBlockquote",
          "pageBlockChannel",
          "pageBlockCollage",
          "pageBlockCover",
          "pageBlockDetails",
          "pageBlockDivider",
          "pageBlockEmbed",
          "pageBlockEmbedPost",
          "pageBlockFooter",
          "pageBlockHeader",
          "pageBlockKicker",
          "pageBlockList",
          "pageBlockMap",
          "pageBlockOrderedList",
          "pageBlockParagraph",
          "pageBlockPhoto",
          "pageBlockPreformatted",
          "pageBlockPullquote",
          "pageBlockRelatedArticles",
          "pageBlockSlideshow",
          "pageBlockSubheader",
          "pageBlockSubtitle",
          "pageBlockTable",
          "pageBlockTitle",
          "pageBlockUnsupported",
          "pageBlockVideo",
          "pageCaption",
          "pageListItemBlocks",
          "pageListItemText",
          "pageListOrderedItemBlocks",
          "pageListOrderedItemText",
          "pageRelatedArticle",
          "pageTableCell",
          "pageTableRow",
          "passwordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow",
          "passwordKdfAlgoUnknown",
          "paymentCharge",
          "paymentRequestedInfo",
          "paymentSavedCredentialsCard",
          "payments.bankCardData",
          "payments.paymentForm",
          "payments.paymentReceipt",
          "payments.paymentResult",
          "payments.paymentVerificationNeeded",
          "payments.savedInfo",
          "payments.validatedRequestedInfo",
          "peerBlocked",
          "peerChannel",
          "peerChat",
          "peerLocated",
          "peerNotifySettings",
          "peerSelfLocated",
          "peerSettings",
          "peerUser",
          "phone.phoneCall",
          "phoneCall",
          "phoneCallAccepted",
          "phoneCallDiscardReasonBusy",
          "phoneCallDiscardReasonDisconnect",
          "phoneCallDiscardReasonHangup",
          "phoneCallDiscardReasonMissed",
          "phoneCallDiscarded",
          "phoneCallEmpty",
          "phoneCallProtocol",
          "phoneCallRequested",
          "phoneCallWaiting",
          "phoneConnection",
          "phoneConnectionWebrtc",
          "photo",
          "photoCachedSize",
          "photoEmpty",
          "photoPathSize",
          "photoSize",
          "photoSizeEmpty",
          "photoSizeProgressive",
          "photoStrippedSize",
          "photos.photo",
          "photos.photos",
          "photos.photosSlice",
          "poll",
          "pollAnswer",
          "pollAnswerVoters",
          "pollResults",
          "popularContact",
          "postAddress",
          "privacyKeyAddedByPhone",
          "privacyKeyChatInvite",
          "privacyKeyForwards",
          "privacyKeyPhoneCall",
          "privacyKeyPhoneNumber",
          "privacyKeyPhoneP2P",
          "privacyKeyProfilePhoto",
          "privacyKeyStatusTimestamp",
          "privacyValueAllowAll",
          "privacyValueAllowChatParticipants",
          "privacyValueAllowContacts",
          "privacyValueAllowUsers",
          "privacyValueDisallowAll",
          "privacyValueDisallowChatParticipants",
          "privacyValueDisallowContacts",
          "privacyValueDisallowUsers",
          "receivedNotifyMessage",
          "recentMeUrlChat",
          "recentMeUrlChatInvite",
          "recentMeUrlStickerSet",
          "recentMeUrlUnknown",
          "recentMeUrlUser",
          "replyInlineMarkup",
          "replyKeyboardForceReply",
          "replyKeyboardHide",
          "replyKeyboardMarkup",
          "restrictionReason",
          "savedPhoneContact",
          "secureCredentialsEncrypted",
          "secureData",
          "secureFile",
          "secureFileEmpty",
          "securePasswordKdfAlgoPBKDF2HMACSHA512iter100000",
          "securePasswordKdfAlgoSHA512",
          "securePasswordKdfAlgoUnknown",
          "securePlainEmail",
          "securePlainPhone",
          "secureRequiredType",
          "secureRequiredTypeOneOf",
          "secureSecretSettings",
          "secureValue",
          "secureValueError",
          "secureValueErrorData",
          "secureValueErrorFile",
          "secureValueErrorFiles",
          "secureValueErrorFrontSide",
          "secureValueErrorReverseSide",
          "secureValueErrorSelfie",
          "secureValueErrorTranslationFile",
          "secureValueErrorTranslationFiles",
          "secureValueHash",
          "secureValueTypeAddress",
          "secureValueTypeBankStatement",
          "secureValueTypeDriverLicense",
          "secureValueTypeEmail",
          "secureValueTypeIdentityCard",
          "secureValueTypeInternalPassport",
          "secureValueTypePassport",
          "secureValueTypePassportRegistration",
          "secureValueTypePersonalDetails",
          "secureValueTypePhone",
          "secureValueTypeRentalAgreement",
          "secureValueTypeTemporaryRegistration",
          "secureValueTypeUtilityBill",
          "sendMessageCancelAction",
          "sendMessageChooseContactAction",
          "sendMessageGamePlayAction",
          "sendMessageGeoLocationAction",
          "sendMessageRecordAudioAction",
          "sendMessageRecordRoundAction",
          "sendMessageRecordVideoAction",
          "sendMessageTypingAction",
          "sendMessageUploadAudioAction",
          "sendMessageUploadDocumentAction",
          "sendMessageUploadPhotoAction",
          "sendMessageUploadRoundAction",
          "sendMessageUploadVideoAction",
          "shippingOption",
          "stats.broadcastStats",
          "stats.megagroupStats",
          "stats.messageStats",
          "statsAbsValueAndPrev",
          "statsDateRangeDays",
          "statsGraph",
          "statsGraphAsync",
          "statsGraphError",
          "statsGroupTopAdmin",
          "statsGroupTopInviter",
          "statsGroupTopPoster",
          "statsPercentValue",
          "statsURL",
          "stickerPack",
          "stickerSet",
          "stickerSetCovered",
          "stickerSetMultiCovered",
          "storage.fileGif",
          "storage.fileJpeg",
          "storage.fileMov",
          "storage.fileMp3",
          "storage.fileMp4",
          "storage.filePartial",
          "storage.filePdf",
          "storage.filePng",
          "storage.fileUnknown",
          "storage.fileWebp",
          "textAnchor",
          "textBold",
          "textConcat",
          "textEmail",
          "textEmpty",
          "textFixed",
          "textImage",
          "textItalic",
          "textMarked",
          "textPhone",
          "textPlain",
          "textStrike",
          "textSubscript",
          "textSuperscript",
          "textUnderline",
          "textUrl",
          "theme",
          "themeSettings",
          "topPeer",
          "topPeerCategoryBotsInline",
          "topPeerCategoryBotsPM",
          "topPeerCategoryChannels",
          "topPeerCategoryCorrespondents",
          "topPeerCategoryForwardChats",
          "topPeerCategoryForwardUsers",
          "topPeerCategoryGroups",
          "topPeerCategoryPeers",
          "topPeerCategoryPhoneCalls",
          "true",
          "updateBotCallbackQuery",
          "updateBotInlineQuery",
          "updateBotInlineSend",
          "updateBotPrecheckoutQuery",
          "updateBotShippingQuery",
          "updateBotWebhookJSON",
          "updateBotWebhookJSONQuery",
          "updateChannel",
          "updateChannelAvailableMessages",
          "updateChannelMessageForwards",
          "updateChannelMessageViews",
          "updateChannelParticipant",
          "updateChannelReadMessagesContents",
          "updateChannelTooLong",
          "updateChannelUserTyping",
          "updateChannelWebPage",
          "updateChatDefaultBannedRights",
          "updateChatParticipantAdd",
          "updateChatParticipantAdmin",
          "updateChatParticipantDelete",
          "updateChatParticipants",
          "updateChatUserTyping",
          "updateConfig",
          "updateContactsReset",
          "updateDcOptions",
          "updateDeleteChannelMessages",
          "updateDeleteMessages",
          "updateDeleteScheduledMessages",
          "updateDialogFilter",
          "updateDialogFilterOrder",
          "updateDialogFilters",
          "updateDialogPinned",
          "updateDialogUnreadMark",
          "updateDraftMessage",
          "updateEditChannelMessage",
          "updateEditMessage",
          "updateEncryptedChatTyping",
          "updateEncryptedMessagesRead",
          "updateEncryption",
          "updateFavedStickers",
          "updateFolderPeers",
          "updateGeoLiveViewed",
          "updateInlineBotCallbackQuery",
          "updateLangPack",
          "updateLangPackTooLong",
          "updateLoginToken",
          "updateMessageID",
          "updateMessagePoll",
          "updateMessagePollVote",
          "updateNewChannelMessage",
          "updateNewEncryptedMessage",
          "updateNewMessage",
          "updateNewScheduledMessage",
          "updateNewStickerSet",
          "updateNotifySettings",
          "updatePeerBlocked",
          "updatePeerLocated",
          "updatePeerSettings",
          "updatePhoneCall",
          "updatePhoneCallSignalingData",
          "updatePinnedChannelMessages",
          "updatePinnedDialogs",
          "updatePinnedMessages",
          "updatePrivacy",
          "updatePtsChanged",
          "updateReadChannelDiscussionInbox",
          "updateReadChannelDiscussionOutbox",
          "updateReadChannelInbox",
          "updateReadChannelOutbox",
          "updateReadFeaturedStickers",
          "updateReadHistoryInbox",
          "updateReadHistoryOutbox",
          "updateReadMessagesContents",
          "updateRecentStickers",
          "updateSavedGifs",
          "updateServiceNotification",
          "updateShort",
          "updateShortChatMessage",
          "updateShortMessage",
          "updateShortSentMessage",
          "updateStickerSets",
          "updateStickerSetsOrder",
          "updateTheme",
          "updateUserName",
          "updateUserPhone",
          "updateUserPhoto",
          "updateUserStatus",
          "updateUserTyping",
          "updateWebPage",
          "updates",
          "updates.channelDifference",
          "updates.channelDifferenceEmpty",
          "updates.channelDifferenceTooLong",
          "updates.difference",
          "updates.differenceEmpty",
          "updates.differenceSlice",
          "updates.differenceTooLong",
          "updates.state",
          "updatesCombined",
          "updatesTooLong",
          "upload.cdnFile",
          "upload.cdnFileReuploadNeeded",
          "upload.file",
          "upload.fileCdnRedirect",
          "upload.webFile",
          "urlAuthResultAccepted",
          "urlAuthResultDefault",
          "urlAuthResultRequest",
          "user",
          "userEmpty",
          "userFull",
          "userProfilePhoto",
          "userProfilePhotoEmpty",
          "userStatusEmpty",
          "userStatusLastMonth",
          "userStatusLastWeek",
          "userStatusOffline",
          "userStatusOnline",
          "userStatusRecently",
          "vector",
          "videoSize",
          "wallPaper",
          "wallPaperNoFile",
          "wallPaperSettings",
          "webAuthorization",
          "webDocument",
          "webDocumentNoProxy",
          "webPage",
          "webPageAttributeTheme",
          "webPageEmpty",
          "webPageNotModified",
          "webPagePending"
        ]
      },
      {
        "name": "method",
        "values": [
          "account.acceptAuthorization",
          "account.cancelPasswordEmail",
          "account.changePhone",
          "account.checkUsername",
          "account.confirmPasswordEmail",
          "account.confirmPhone",
          "account.createTheme",
          "account.deleteAccount",
          "account.deleteSecureValue",
          "account.finishTakeoutSession",
          "account.getAccountTTL",
          "account.getAllSecureValues",
          "account.getAuthorizationForm",
          "account.getAuthorizations",
          "account.getAutoDownloadSettings",
          "account.getContactSignUpNotification",
          "account.getContentSettings",
          "account.getGlobalPrivacySettings",
          "account.getMultiWallPapers",
          "account.getNotifyExceptions",
          "account.getNotifySettings",
          "account.getPassword",
          "account.getPasswordSettings",
          "account.getPrivacy",
          "account.getSecureValue",
          "account.getTheme",
          "account.getThemes",
          "account.getTmpPassword",
          "account.getWallPaper",
          "account.getWallPapers",
          "account.getWebAuthorizations",
          "account.initTakeoutSession",
          "account.installTheme",
          "account.installWallPaper",
          "account.registerDevice",
          "account.reportPeer",
          "account.resendPasswordEmail",
          "account.resetAuthorization",
          "account.resetNotifySettings",
          "account.resetWallPapers",
          "account.resetWebAuthorization",
          "account.resetWebAuthorizations",
          "account.saveAutoDownloadSettings",
          "account.saveSecureValue",
          "account.saveTheme",
          "account.saveWallPaper",
          "account.sendChangePhoneCode",
          "account.sendConfirmPhoneCode",
          "account.sendVerifyEmailCode",
          "account.sendVerifyPhoneCode",
          "account.setAccountTTL",
          "account.setContactSignUpNotification",
          "account.setContentSettings",
          "account.setGlobalPrivacySettings",
          "account.setPrivacy",
          "account.unregisterDevice",
          "account.updateDeviceLocked",
          "account.updateNotifySettings",
          "account.updatePasswordSettings",
          "account.updateProfile",
          "account.updateStatus",
          "account.updateTheme",
          "account.updateUsername",
          "account.uploadTheme",
          "account.uploadWallPaper",
          "account.verifyEmail",
          "account.verifyPhone",
          "auth.acceptLoginToken",
          "auth.bindTempAuthKey",
          "auth.cancelCode",
          "auth.checkPassword",
          "auth.dropTempAuthKeys",
          "auth.exportAuthorization",
          "auth.exportLoginToken",
          "auth.importAuthorization",
          "auth.importBotAuthorization",
          "auth.importLoginToken",
          "auth.logOut",
          "auth.recoverPassword",
          "auth.requestPasswordRecovery",
          "auth.resendCode",
          "auth.resetAuthorizations",
          "auth.sendCode",
          "auth.signIn",
          "auth.signUp",
          "bots.answerWebhookJSONQuery",
          "bots.sendCustomRequest",
          "bots.setBotCommands",
          "channels.checkUsername",
          "channels.createChannel",
          "channels.deleteChannel",
          "channels.deleteHistory",
          "channels.deleteMessages",
          "channels.deleteUserHistory",
          "channels.editAdmin",
          "channels.editBanned",
          "channels.editCreator",
          "channels.editLocation",
          "channels.editPhoto",
          "channels.editTitle",
          "channels.exportMessageLink",
          "channels.getAdminLog",
          "channels.getAdminedPublicChannels",
          "channels.getChannels",
          "channels.getFullChannel",
          "channels.getGroupsForDiscussion",
          "channels.getInactiveChannels",
          "channels.getLeftChannels",
          "channels.getMessages",
          "channels.getParticipant",
          "channels.getParticipants",
          "channels.inviteToChannel",
          "channels.joinChannel",
          "channels.leaveChannel",
          "channels.readHistory",
          "channels.readMessageContents",
          "channels.reportSpam",
          "channels.setDiscussionGroup",
          "channels.setStickers",
          "channels.togglePreHistoryHidden",
          "channels.toggleSignatures",
          "channels.toggleSlowMode",
          "channels.updateUsername",
          "contacts.acceptContact",
          "contacts.addContact",
          "contacts.block",
          "contacts.blockFromReplies",
          "contacts.deleteByPhones",
          "contacts.deleteContacts",
          "contacts.getBlocked",
          "contacts.getContactIDs",
          "contacts.getContacts",
          "contacts.getLocated",
          "contacts.getSaved",
          "contacts.getStatuses",
          "contacts.getTopPeers",
          "contacts.importContacts",
          "contacts.resetSaved",
          "contacts.resetTopPeerRating",
          "contacts.resolveUsername",
          "contacts.search",
          "contacts.toggleTopPeers",
          "contacts.unblock",
          "folders.deleteFolder",
          "folders.editPeerFolders",
          "help.acceptTermsOfService",
          "help.dismissSuggestion",
          "help.editUserInfo",
          "help.getAppChangelog",
          "help.getAppConfig",
          "help.getAppUpdate",
          "help.getCdnConfig",
          "help.getConfig",
          "help.getCountriesList",
          "help.getDeepLinkInfo",
          "help.getInviteText",
          "help.getNearestDc",
          "help.getPassportConfig",
          "help.getPromoData",
          "help.getRecentMeUrls",
          "help.getSupport",
          "help.getSupportName",
          "help.getTermsOfServiceUpdate",
          "help.getUserInfo",
          "help.hidePromoData",
          "help.saveAppLog",
          "help.setBotUpdatesStatus",
          "initConnection",
          "invokeAfterMsg",
          "invokeAfterMsgs",
          "invokeWithLayer",
          "invokeWithMessagesRange",
          "invokeWithTakeout",
          "invokeWithoutUpdates",
          "langpack.getDifference",
          "langpack.getLangPack",
          "langpack.getLanguage",
          "langpack.getLanguages",
          "langpack.getStrings",
          "messages.acceptEncryption",
          "messages.acceptUrlAuth",
          "messages.addChatUser",
          "messages.checkChatInvite",
          "messages.clearAllDrafts",
          "messages.clearRecentStickers",
          "messages.createChat",
          "messages.deleteChatUser",
          "messages.deleteHistory",
          "messages.deleteMessages",
          "messages.deleteScheduledMessages",
          "messages.discardEncryption",
          "messages.editChatAbout",
          "messages.editChatAdmin",
          "messages.editChatDefaultBannedRights",
          "messages.editChatPhoto",
          "messages.editChatTitle",
          "messages.editInlineBotMessage",
          "messages.editMessage",
          "messages.exportChatInvite",
          "messages.faveSticker",
          "messages.forwardMessages",
          "messages.getAllChats",
          "messages.getAllDrafts",
          "messages.getAllStickers",
          "messages.getArchivedStickers",
          "messages.getAttachedStickers",
          "messages.getBotCallbackAnswer",
          "messages.getChats",
          "messages.getCommonChats",
          "messages.getDhConfig",
          "messages.getDialogFilters",
          "messages.getDialogUnreadMarks",
          "messages.getDialogs",
          "messages.getDiscussionMessage",
          "messages.getDocumentByHash",
          "messages.getEmojiKeywords",
          "messages.getEmojiKeywordsDifference",
          "messages.getEmojiKeywordsLanguages",
          "messages.getEmojiURL",
          "messages.getFavedStickers",
          "messages.getFeaturedStickers",
          "messages.getFullChat",
          "messages.getGameHighScores",
          "messages.getHistory",
          "messages.getInlineBotResults",
          "messages.getInlineGameHighScores",
          "messages.getMaskStickers",
          "messages.getMessageEditData",
          "messages.getMessages",
          "messages.getMessagesViews",
          "messages.getOldFeaturedStickers",
          "messages.getOnlines",
          "messages.getPeerDialogs",
          "messages.getPeerSettings",
          "messages.getPinnedDialogs",
          "messages.getPollResults",
          "messages.getPollVotes",
          "messages.getRecentLocations",
          "messages.getRecentStickers",
          "messages.getReplies",
          "messages.getSavedGifs",
          "messages.getScheduledHistory",
          "messages.getScheduledMessages",
          "messages.getSearchCounters",
          "messages.getSplitRanges",
          "messages.getStatsURL",
          "messages.getStickerSet",
          "messages.getStickers",
          "messages.getSuggestedDialogFilters",
          "messages.getUnreadMentions",
          "messages.getWebPage",
          "messages.getWebPagePreview",
          "messages.hidePeerSettingsBar",
          "messages.importChatInvite",
          "messages.installStickerSet",
          "messages.markDialogUnread",
          "messages.migrateChat",
          "messages.readDiscussion",
          "messages.readEncryptedHistory",
          "messages.readFeaturedStickers",
          "messages.readHistory",
          "messages.readMentions",
          "messages.readMessageContents",
          "messages.receivedMessages",
          "messages.receivedQueue",
          "messages.reorderPinnedDialogs",
          "messages.reorderStickerSets",
          "messages.report",
          "messages.reportEncryptedSpam",
          "messages.reportSpam",
          "messages.requestEncryption",
          "messages.requestUrlAuth",
          "messages.saveDraft",
          "messages.saveGif",
          "messages.saveRecentSticker",
          "messages.search",
          "messages.searchGlobal",
          "messages.searchStickerSets",
          "messages.sendEncrypted",
          "messages.sendEncryptedFile",
          "messages.sendEncryptedService",
          "messages.sendInlineBotResult",
          "messages.sendMedia",
          "messages.sendMessage",
          "messages.sendMultiMedia",
          "messages.sendScheduledMessages",
          "messages.sendScreenshotNotification",
          "messages.sendVote",
          "messages.setBotCallbackAnswer",
          "messages.setBotPrecheckoutResults",
          "messages.setBotShippingResults",
          "messages.setEncryptedTyping",
          "messages.setGameScore",
          "messages.setInlineBotResults",
          "messages.setInlineGameScore",
          "messages.setTyping",
          "messages.startBot",
          "messages.toggleDialogPin",
          "messages.toggleStickerSets",
          "messages.uninstallStickerSet",
          "messages.unpinAllMessages",
          "messages.updateDialogFilter",
          "messages.updateDialogFiltersOrder",
          "messages.updatePinnedMessage",
          "messages.uploadEncryptedFile",
          "messages.uploadMedia",
          "payments.clearSavedInfo",
          "payments.getBankCardData",
          "payments.getPaymentForm",
          "payments.getPaymentReceipt",
          "payments.getSavedInfo",
          "payments.sendPaymentForm",
          "payments.validateRequestedInfo",
          "phone.acceptCall",
          "phone.confirmCall",
          "phone.discardCall",
          "phone.getCallConfig",
          "phone.receivedCall",
          "phone.requestCall",
          "phone.saveCallDebug",
          "phone.sendSignalingData",
          "phone.setCallRating",
          "photos.deletePhotos",
          "photos.getUserPhotos",
          "photos.updateProfilePhoto",
          "photos.uploadProfilePhoto",
          "stats.getBroadcastStats",
          "stats.getMegagroupStats",
          "stats.getMessagePublicForwards",
          "stats.getMessageStats",
          "stats.loadAsyncGraph",
          "stickers.addStickerToSet",
          "stickers.changeStickerPosition",
          "stickers.createStickerSet",
          "stickers.removeStickerFromSet",
          "stickers.setStickerSetThumb",
          "updates.getChannelDifference",
          "updates.getDifference",
          "updates.getState",
          "upload.getCdnFile",
          "upload.getCdnFileHashes",
          "upload.getFile",
          "upload.getFileHashes",
          "upload.getWebFile",
          "upload.reuploadCdnFile",
          "upload.saveBigFilePart",
          "upload.saveFilePart",
          "users.getFullUser",
          "users.getUsers",
          "users.setSecureValueErrors"
        ]
      },
      {
        "name": "type",
        "values": [
          "#",
          "AccountDaysTTL",
          "Authorization",
          "AutoDownloadSettings",
          "BankCardOpenUrl",
          "BaseTheme",
          "Bool",
          "BotCommand",
          "BotInfo",
          "BotInlineMessage",
          "BotInlineResult",
          "CdnConfig",
          "CdnPublicKey",
          "ChannelAdminLogEvent",
          "ChannelAdminLogEventAction",
          "ChannelAdminLogEventsFilter",
          "ChannelLocation",
          "ChannelMessagesFilter",
          "ChannelParticipant",
          "ChannelParticipantsFilter",
          "Chat",
          "ChatAdminRights",
          "ChatBannedRights",
          "ChatFull",
          "ChatInvite",
          "ChatOnlines",
          "ChatParticipant",
          "ChatParticipants",
          "ChatPhoto",
          "CodeSettings",
          "Config",
          "Contact",
          "ContactStatus",
          "DataJSON",
          "DcOption",
          "Dialog",
          "DialogFilter",
          "DialogFilterSuggested",
          "DialogPeer",
          "Document",
          "DocumentAttribute",
          "DraftMessage",
          "EmojiKeyword",
          "EmojiKeywordsDifference",
          "EmojiLanguage",
          "EmojiURL",
          "EncryptedChat",
          "EncryptedFile",
          "EncryptedMessage",
          "Error",
          "ExportedChatInvite",
          "ExportedMessageLink",
          "FileHash",
          "FileLocation",
          "Folder",
          "FolderPeer",
          "Game",
          "GeoPoint",
          "GlobalPrivacySettings",
          "HighScore",
          "ImportedContact",
          "InlineBotSwitchPM",
          "InputAppEvent",
          "InputBotInlineMessage",
          "InputBotInlineMessageID",
          "InputBotInlineResult",
          "InputChannel",
          "InputChatPhoto",
          "InputCheckPasswordSRP",
          "InputClientProxy",
          "InputContact",
          "InputDialogPeer",
          "InputDocument",
          "InputEncryptedChat",
          "InputEncryptedFile",
          "InputFile",
          "InputFileLocation",
          "InputFolderPeer",
          "InputGame",
          "InputGeoPoint",
          "InputMedia",
          "InputMessage",
          "InputNotifyPeer",
          "InputPaymentCredentials",
          "InputPeer",
          "InputPeerNotifySettings",
          "InputPhoneCall",
          "InputPhoto",
          "InputPrivacyKey",
          "InputPrivacyRule",
          "InputSecureFile",
          "InputSecureValue",
          "InputSingleMedia",
          "InputStickerSet",
          "InputStickerSetItem",
          "InputStickeredMedia",
          "InputTheme",
          "InputThemeSettings",
          "InputUser",
          "InputWallPaper",
          "InputWebDocument",
          "InputWebFileLocation",
          "Invoice",
          "JSONObjectValue",
          "JSONValue",
          "KeyboardButton",
          "KeyboardButtonRow",
          "LabeledPrice",
          "LangPackDifference",
          "LangPackLanguage",
          "LangPackString",
          "MaskCoords",
          "Message",
          "MessageAction",
          "MessageEntity",
          "MessageFwdHeader",
          "MessageInteractionCounters",
          "MessageMedia",
          "MessageRange",
          "MessageReplies",
          "MessageReplyHeader",
          "MessageUserVote",
          "MessageViews",
          "MessagesFilter",
          "NearestDc",
          "NotifyPeer",
          "Null",
          "Page",
          "PageBlock",
          "PageCaption",
          "PageListItem",
          "PageListOrderedItem",
          "PageRelatedArticle",
          "PageTableCell",
          "PageTableRow",
          "PasswordKdfAlgo",
          "PaymentCharge",
          "PaymentRequestedInfo",
          "PaymentSavedCredentials",
          "Peer",
          "PeerBlocked",
          "PeerLocated",
          "PeerNotifySettings",
          "PeerSettings",
          "PhoneCall",
          "PhoneCallDiscardReason",
          "PhoneCallProtocol",
          "PhoneConnection",
          "Photo",
          "PhotoSize",
          "Poll",
          "PollAnswer",
          "PollAnswerVoters",
          "PollResults",
          "PopularContact",
          "PostAddress",
          "PrivacyKey",
          "PrivacyRule",
          "ReceivedNotifyMessage",
          "RecentMeUrl",
          "ReplyMarkup",
          "ReportReason",
          "RestrictionReason",
          "RichText",
          "SavedContact",
          "SecureCredentialsEncrypted",
          "SecureData",
          "SecureFile",
          "SecurePasswordKdfAlgo",
          "SecurePlainData",
          "SecureRequiredType",
          "SecureSecretSettings",
          "SecureValue",
          "SecureValueError",
          "SecureValueHash",
          "SecureValueType",
          "SendMessageAction",
          "ShippingOption",
          "StatsAbsValueAndPrev",
          "StatsDateRangeDays",
          "StatsGraph",
          "StatsGroupTopAdmin",
          "StatsGroupTopInviter",
          "StatsGroupTopPoster",
          "StatsPercentValue",
          "StatsURL",
          "StickerPack",
          "StickerSet",
          "StickerSetCovered",
          "Theme",
          "ThemeSettings",
          "TopPeer",
          "TopPeerCategory",
          "TopPeerCategoryPeers",
          "True",
          "Update",
          "Updates",
          "UrlAuthResult",
          "User",
          "UserFull",
          "UserProfilePhoto",
          "UserStatus",
          "Vector t",
          "VideoSize",
          "WallPaper",
          "WallPaperSettings",
          "WebAuthorization",
          "WebDocument",
          "WebPage",
          "WebPageAttribute",
          "account.AuthorizationForm",
          "account.Authorizations",
          "account.AutoDownloadSettings",
          "account.ContentSettings",
          "account.Password",
          "account.PasswordInputSettings",
          "account.PasswordSettings",
          "account.PrivacyRules",
          "account.SentEmailCode",
          "account.Takeout",
          "account.Themes",
          "account.TmpPassword",
          "account.WallPapers",
          "account.WebAuthorizations",
          "auth.Authorization",
          "auth.CodeType",
          "auth.ExportedAuthorization",
          "auth.LoginToken",
          "auth.PasswordRecovery",
          "auth.SentCode",
          "auth.SentCodeType",
          "bytes",
          "channels.AdminLogResults",
          "channels.ChannelParticipant",
          "channels.ChannelParticipants",
          "contacts.Blocked",
          "contacts.Contacts",
          "contacts.Found",
          "contacts.ImportedContacts",
          "contacts.ResolvedPeer",
          "contacts.TopPeers",
          "double",
          "help.AppUpdate",
          "help.CountriesList",
          "help.Country",
          "help.CountryCode",
          "help.DeepLinkInfo",
          "help.InviteText",
          "help.PassportConfig",
          "help.PromoData",
          "help.RecentMeUrls",
          "help.Support",
          "help.SupportName",
          "help.TermsOfService",
          "help.TermsOfServiceUpdate",
          "help.UserInfo",
          "int",
          "long",
          "messages.AffectedHistory",
          "messages.AffectedMessages",
          "messages.AllStickers",
          "messages.ArchivedStickers",
          "messages.BotCallbackAnswer",
          "messages.BotResults",
          "messages.ChatFull",
          "messages.Chats",
          "messages.DhConfig",
          "messages.Dialogs",
          "messages.DiscussionMessage",
          "messages.FavedStickers",
          "messages.FeaturedStickers",
          "messages.FoundStickerSets",
          "messages.HighScores",
          "messages.InactiveChats",
          "messages.MessageEditData",
          "messages.MessageViews",
          "messages.Messages",
          "messages.PeerDialogs",
          "messages.RecentStickers",
          "messages.SavedGifs",
          "messages.SearchCounter",
          "messages.SentEncryptedMessage",
          "messages.StickerSet",
          "messages.StickerSetInstallResult",
          "messages.Stickers",
          "messages.VotesList",
          "payments.BankCardData",
          "payments.PaymentForm",
          "payments.PaymentReceipt",
          "payments.PaymentResult",
          "payments.SavedInfo",
          "payments.ValidatedRequestedInfo",
          "phone.PhoneCall",
          "photos.Photo",
          "photos.Photos",
          "stats.BroadcastStats",
          "stats.MegagroupStats",
          "stats.MessageStats",
          "storage.FileType",
          "string",
          "updates.ChannelDifference",
          "updates.Difference",
          "updates.State",
          "upload.CdnFile",
          "upload.File",
          "upload.WebFile"
        ]
      }
    ]
  },
  "constructors": {
    "FileHash": {
      "name": "FileHash",
      "description": [
        "SHA256 Hash of an uploaded file, to be checked for validity after download"
      ],
      "fields": {
        "hash": "SHA-256 Hash of file chunk, to be checked for validity after download",
        "limit": "Length",
        "offset": "Offset from where to start computing SHA-256 hash"
      }
    },
    "Updates": {
      "name": "Updates",
      "description": [
        "Full constructor of updates"
      ],
      "fields": {
        "chats": "List of chats mentioned in updates",
        "date": "Current date",
        "seq": "Total number of sent updates",
        "updates": "List of updates",
        "users": "List of users mentioned in updates"
      }
    },
    "account.authorizationForm": {
      "name": "account.authorizationForm",
      "description": [
        "Telegram Passport authorization form"
      ],
      "fields": {
        "errors": "Telegram Passport errors",
        "flags": "Flags, see TL conditional fields",
        "privacy_policy_url": "URL of the service's privacy policy",
        "required_types": "Required Telegram Passport documents",
        "users": "Info about the bot to which the form will be submitted",
        "values": "Already submitted Telegram Passport documents"
      }
    },
    "account.authorizations": {
      "name": "account.authorizations",
      "description": [
        "Logged-in sessions"
      ],
      "fields": {
        "authorizations": "Logged-in sessions"
      }
    },
    "account.autoDownloadSettings": {
      "name": "account.autoDownloadSettings",
      "description": [
        "Media autodownload settings"
      ],
      "fields": {
        "high": "High data usage preset",
        "low": "Low data usage preset",
        "medium": "Medium data usage preset"
      }
    },
    "account.contentSettings": {
      "name": "account.contentSettings",
      "description": [
        "Sensitive content settings"
      ],
      "fields": {
        "flags": "Flags, see TL conditional fields",
        "sensitive_can_change": "Whether the current client can change the sensitive content settings to view NSFW content",
        "sensitive_enabled": "Whether viewing of sensitive (NSFW) content is enabled"
      }
    },
    "account.password": {
      "name": "account.password",
      "description": [
        "Configuration for two-factor authorization"
      ],
      "fields": {
        "current_algo": "The KDF algorithm for SRP two-factor authentication of the current password",
        "email_unconfirmed_pattern": "A password recovery email with the specified pattern is still awaiting verification",
        "flags": "Flags, see TL conditional fields",
        "has_password": "Whether the user has a password",
        "has_recovery": "Whether the user has a recovery method configured",
        "has_secure_values": "Whether telegram passport is enabled",
        "hint": "Text hint for the password",
        "new_algo": "The KDF algorithm for SRP two-factor authentication to use when creating new passwords",
        "new_secure_algo": "The KDF algorithm for telegram passport",
        "secure_random": "Secure random string",
        "srp_B": "Srp B param for SRP authorization",
        "srp_id": "Srp ID param for SRP authorization"
      }
    },
    "account.passwordInputSettings": {
      "name": "account.passwordInputSettings",
      "description": [
        "Settings for setting up a new password"
      ],
      "fields": {
        "email": "Password recovery email",
        "flags": "Flags, see TL conditional fields",
        "hint": "Text hint for the password",
        "new_algo": "The SRP algorithm to use",
        "new_password_hash": "The computed password hash",
        "new_secure_settings": "Telegram passport settings"
      }
    },
    "account.passwordSettings": {
      "name": "account.passwordSettings",
      "description": [
        "Private info associated to the password info (recovery email, telegram passport info \u0026 so on)"
      ],
      "fields": {
        "email": "2FA Recovery email",
        "flags": "Flags, see TL conditional fields",
        "secure_settings": "Telegram passport settings"
      }
    },
    "account.privacyRules": {
      "name": "account.privacyRules",
      "description": [
        "Privacy rules"
      ],
      "fields": {
        "chats": "Chats to which the rules apply",
        "rules": "Privacy rules",
        "users": "Users to which the rules apply"
      }
    },
    "account.sentEmailCode": {
      "name": "account.sentEmailCode",
      "description": [
        "The sent email code"
      ],
      "fields": {
        "email_pattern": "The email (to which the code was sent) must match this pattern",
        "length": "The length of the verification code"
      }
    },
    "account.takeout": {
      "name": "account.takeout",
      "description": [
        "Takout info"
      ],
      "fields": {
        "id": "Takeout ID"
      }
    },
    "account.themes": {
      "name": "account.themes",
      "description": [
        "Installed themes"
      ],
      "fields": {
        "hash": "Hash for pagination, for more info click here",
        "themes": "Themes"
      }
    },
    "account.themesNotModified": {
      "name": "account.themesNotModified",
      "description": [
        "No new themes were installed"
      ]
    },
    "account.tmpPassword": {
      "name": "account.tmpPassword",
      "description": [
        "Temporary payment password"
      ],
      "fields": {
        "tmp_password": "Temporary password",
        "valid_until": "Validity period"
      }
    },
    "account.wallPapers": {
      "name": "account.wallPapers",
      "description": [
        "Installed wallpapers"
      ],
      "fields": {
        "hash": "Hash for pagination, for more info click here",
        "wallpapers": "Wallpapers"
      }
    },
    "account.wallPapersNotModified": {
      "name": "account.wallPapersNotModified",
      "description": [
        "No new wallpapers were found"
      ]
    },
    "account.webAuthorizations": {
      "name": "account.webAuthorizations",
      "description": [
        "Web authorizations"
      ],
      "fields": {
        "authorizations": "Web authorization list",
        "users": "Users"
      }
    },
    "accountDaysTTL": {
      "name": "accountDaysTTL",
      "description": [
        "Time to live in days of the current account"
      ],
      "fields": {
        "days": "This account will self-destruct in the specified number of days"
      }
    },
    "auth.authorization": {
      "name": "auth.authorization",
      "description": [
        "Contains user authorization info."
      ],
      "fields": {
        "flags": "Flags, see TL conditional fields",
        "tmp_sessions": "Temporary passport sessions",
        "user": "Info on authorized user"
      }
    },
    "auth.authorizationSignUpRequired": {
      "name": "auth.authorizationSignUpRequired",
      "description": [
        "An account with this phone number doesn't exist on telegram: the user has to enter basic information and sign up"
      ],
      "fields": {
        "flags": "Flags, see TL conditional fields",
        "terms_of_service": "Telegram's terms of service: the user must read and accept the terms of service before signing up to telegram"
      }
    },
    "auth.codeTypeCall": {
      "name": "auth.codeTypeCall",
      "description": [
        "Type of verification code that will be sent next if you call the resendCode method: SMS code"
      ]
    },
    "auth.codeTypeFlashCall": {
      "name": "auth.codeTypeFlashCall",
      "description": [
        "Type of verification code that will be sent next if you call the resendCode method: SMS code"
      ]
    },
    "auth.codeTypeSms": {
      "name": "auth.codeTypeSms",
      "description": [
        "Type of verification code that will be sent next if you call the resendCode method: SMS code"
      ]
    },
    "auth.exportedAuthorization": {
      "name": "auth.exportedAuthorization",
      "description": [
        "Data for copying of authorization between data centres."
      ],
      "fields": {
        "bytes": "authorizes key",
        "id": "current user identifier"
      }
    },
    "auth.loginToken": {
      "name": "auth.loginToken",
      "description": [
        "Login token (for QR code login)"
      ],
      "fields": {
        "expires": "Expiry date of QR code",
        "token": "Token to render in QR code"
      }
    },
    "auth.loginTokenMigrateTo": {
      "name": "auth.loginTokenMigrateTo",
      "description": [
        "Repeat the query to the specified DC"
      ],
      "fields": {
        "dc_id": "DC ID",
        "token": "Token to use for login"
      }
    },
    "auth.loginTokenSuccess": {
      "name": "auth.loginTokenSuccess",
      "description": [
        "Login via token (QR code) succeded!"
      ],
      "fields": {
        "authorization": "Authorization info"
      }
    },
    "auth.passwordRecovery": {
      "name": "auth.passwordRecovery",
      "description": [
        "Recovery info of a 2FA password, only for accounts with a recovery email configured."
      ],
      "fields": {
        "email_pattern": "The email to which the recovery code was sent must match this pattern."
      }
    },
    "auth.sentCode": {
      "name": "auth.sentCode",
      "description": [
        "Contains info about a sent verification code."
      ],
      "fields": {
        "flags": "Flags, see TL conditional fields",
        "next_type": "Phone code type that will be sent next, if the phone code is not received within timeout seconds: to send it use auth.resendCode",
        "phone_code_hash": "Phone code hash, to be stored and later re-used with auth.signIn",
        "timeout": "Timeout for reception of the phone code",
        "type": "Phone code type"
      }
    },
    "auth.sentCodeTypeApp": {
      "name": "auth.sentCodeTypeApp",
      "description": [
        "The code was sent through the telegram app"
      ],
      "fields": {
        "length": "Length of the code in bytes"
      }
    },
    "auth.sentCodeTypeCall": {
      "name": "auth.sentCodeTypeCall",
      "description": [
        "The code will be sent via a phone call: a synthesized voice will tell the user which verification code to input."
      ],
      "fields": {
        "length": "Length of the verification code"
      }
    },
    "auth.sentCodeTypeFlashCall": {
      "name": "auth.sentCodeTypeFlashCall",
      "description": [
        "The code will be sent via a flash phone call, that will be closed immediately. The phone code will then be the phone number itself, just make sure that the phone number matches the specified pattern."
      ],
      "fields": {
        "pattern": "pattern to match"
      }
    },
    "auth.sentCodeTypeSms": {
      "name": "auth.sentCodeTypeSms",
      "description": [
        "The code was sent via SMS"
      ],
      "fields": {
        "length": "Length of the code in bytes"
      }
    },
    "authorization": {
      "name": "authorization",
      "description": [
        "Logged-in session"
      ],
      "fields": {
        "api_id": "API ID",
        "app_name": "App name",
        "app_version": "App version",
        "country": "Country determined from IP",
        "current": "Whether this is the current session",
        "date_active": "When was the session last active",
        "date_created": "When was the session created",
        "device_model": "Device model",
        "flags": "Flags, see TL conditional fields",
        "hash": "Identifier",
        "ip": "Last known IP",
        "official_app": "Whether the session is from an official app",
        "password_pending": "Whether the session is still waiting for a 2FA password",
        "platform": "Platform",
        "region": "Region determined from IP",
        "system_version": "System version"
      }
    },
    "autoDownloadSettings": {
      "name": "autoDownloadSettings",
      "description": [
        "Autodownload settings"
      ],
      "fields": {
        "audio_preload_next": "Whether to preload the next audio track when you're listening to music",
        "disabled": "Disable automatic media downloads?",
        "file_size_max": "Maximum size of other files to preload",
        "flags": "Flags, see TL conditional fields",
        "phonecalls_less_data": "Whether to enable data saving mode in phone calls",
        "photo_size_max": "Maximum size of photos to preload",
        "video_preload_large": "Whether to preload the first seconds of videos larger than the specified limit",
        "video_size_max": "Maximum size of videos to preload",
        "video_upload_maxbitrate": "Maximum suggested bitrate for uploading videos"
      }
    },
    "bankCardOpenUrl": {
      "name": "bankCardOpenUrl",
      "description": [
        "Credit card info URL provided by the bank"
      ],
      "fields": {
        "name": "Bank name",
        "url": "Info URL"
      }
    },
    "baseThemeArctic": {
      "name": "baseThemeArctic",
      "description": [
        "Arctic theme"
      ]
    },
    "baseThemeClassic": {
      "name": "baseThemeClassic",
      "description": [
        "Classic theme"
      ]
    },
    "baseThemeDay": {
      "name": "baseThemeDay",
      "description": [
        "Day theme"
      ]
    },
    "baseThemeNight": {
      "name": "baseThemeNight",
      "description": [
        "Night theme"
      ]
    },
    "baseThemeTinted": {
      "name": "baseThemeTinted",
      "description": [
        "Tinted theme"
      ]
    },
    "boolFalse": {
      "name": "boolFalse",
      "description": [
        "Constructor may be interpreted as a booleanfalse value."
      ]
    },
    "boolTrue": {
      "name": "boolTrue",
      "description": [
        "The constructor can be interpreted as a booleantrue value."
      ]
    },
    "botCommand": {
      "name": "botCommand",
      "description": [
        "Describes a bot command that can be used in a chat"
      ],
      "fields": {
        "command": "/command name",
        "description": "Description of the command"
      }
    },
    "botInfo": {
      "name": "botInfo",
      "description": [
        "Info about bots (available bot commands, etc)"
      ],
      "fields": {
        "commands": "Bot commands that can be used in the chat",
        "description": "Description of the bot",
        "user_id": "ID of the bot"
      }
    },
    "botInlineMediaResult": {
      "name": "botInlineMediaResult",
      "description": [
        "Media result"
      ],
      "fields": {
        "description": "Description",
        "document": "If type is document, the document to send",
        "flags": "Flags, see TL conditional fields",
        "id": "Result ID",
        "photo": "If type is photo, the photo to send",
        "send_message": "Depending on the type and on the constructor, contains the caption of the media or the content of the message to be sent instead of the media",
        "title": "Result title",
        "type": "Result type (see bot API docs)"
      }
    },
    "botInlineMessageMediaAuto": {
      "name": "botInlineMessageMediaAuto",
      "description": [
        "Send whatever media is attached to the botInlineMediaResult"
      ],
      "fields": {
        "entities": "Message entities for styled text",
        "flags": "Flags, see TL conditional fields",
        "message": "Caption",
        "reply_markup": "Inline keyboard"
      }
    },
    "botInlineMessageMediaContact": {
      "name": "botInlineMessageMediaContact",
      "description": [
        "Send a contact"
      ],
      "fields": {
        "first_name": "First name",
        "flags": "Flags, see TL conditional fields",
        "last_name": "Last name",
        "phone_number": "Phone number",
        "reply_markup": "Inline keyboard",
        "vcard": "VCard info"
      }
    },
    "botInlineMessageMediaGeo": {
      "name": "botInlineMessageMediaGeo",
      "description": [
        "Send a geolocation"
      ],
      "fields": {
        "flags": "Flags, see TL conditional fields",
        "geo": "Geolocation",
        "heading": "For live locations, a direction in which the location moves, in degrees; 1-360.",
        "period": "Validity period",
        "proximity_notification_radius": "For live locations, a maximum distance to another chat member for proximity alerts, in meters (0-100000).",
        "reply_markup": "Inline keyboard"
      }
    },
    "botInlineMessageMediaVenue": {
      "name": "botInlineMessageMediaVenue",
      "description": [
        "Send a venue"
      ],
      "fields": {
        "address": "Address",
        "flags": "Flags, see TL conditional fields",
        "geo": "Geolocation of venue",
        "provider": "Venue provider: currently only \"foursquare\" needs to be supported",
        "reply_markup": "Inline keyboard",
        "title": "Venue name",
        "venue_id": "Venue ID in the provider's database",
        "venue_type": "Venue type in the provider's database"
      }
    },
    "botInlineMessageText": {
      "name": "botInlineMessageText",
      "description": [
        "Send a simple text message"
      ],
      "fields": {
        "entities": "Message entities for styled text",
        "flags": "Flags, see TL conditional fields",
        "message": "The message",
        "no_webpage": "Disable webpage preview",
        "reply_markup": "Inline keyboard"
      }
    },
    "botInlineResult": {
      "name": "botInlineResult",
      "description": [
        "Generic result"
      ],
      "fields": {
        "content": "Content of the result",
        "description": "Result description",
        "flags": "Flags, see TL conditional fields",
        "id": "Result ID",
        "send_message": "Message to send",
        "thumb": "Thumbnail for the result",
        "title": "Result title",
        "type": "Result type (see bot API docs)",
        "url": "URL of article or webpage"
      }
    },
    "cdnConfig": {
      "name": "cdnConfig",
      "description": [
        "Configuration for CDN file downloads."
      ],
      "fields": {
        "public_keys": "Vector of public keys to use only during handshakes to CDN DCs."
      }
    },
    "cdnPublicKey": {
      "name": "cdnPublicKey",
      "description": [
        "Public key to use only during handshakes to CDN DCs."
      ],
      "fields": {
        "dc_id": "CDN DC ID",
        "public_key": "RSA public key"
      }
    },
    "channel": {
      "name": "channel",
      "description": [
        "Channel/supergroup info"
      ],
      "fields": {
        "access_hash": "Access hash",
        "admin_rights": "Admin rights of the user in this channel (see rights)",
        "banned_rights": "Banned rights of the user in this channel (see rights)",
        "broadcast": "Is this a channel?",
        "creator": "Whether the current user is the creator of this channel",
        "date": "Date when the user joined the supergroup/channel, or if the user isn't a member, its creation date",
        "default_banned_rights": "Default chat rights (see rights)",
        "flags": "Flags, see TL conditional fields",
        "has_geo": "Whether this chanel has a geoposition",
        "has_link": "Whether this channel has a private join link",
        "id": "ID of the channel",
        "left": "Whether the current user has left this channel",
        "megagroup": "Is this a supergroup?",
        "min": "See min",
        "participants_count": "Participant count",
        "photo": "Profile photo",
        "restricted": "Whether viewing/writing in this channel for a reason (see restriction_reason",
        "restriction_reason": "Contains the reason why access to this channel must be restricted.",
        "scam": "This channel/supergroup is probably a scam",
        "signatures": "Whether signatures are enabled (channels)",
        "slowmode_enabled": "Whether slow mode is enabled for groups to prevent flood in chat",
        "title": "Title",
        "username": "Username",
        "verified": "Is this channel verified by telegram?",
        "version": "Version of the channel (always 0)"
      }
    },
    "channelAdminLogEvent": {
      "name": "channelAdminLogEvent",
      "description": [
        "Admin log event"
      ],
      "fields": {
        "action": "Action",
        "date": "Date",
        "id": "Event ID",
        "user_id": "User ID"
      }
    },
    "channelAdminLogEventActionChangeAbout": {
      "name": "channelAdminLogEventActionChangeAbout",
      "description": [
        "The description was changed"
      ],
      "fields": {
        "new_value": "New description",
        "prev_value": "Previous description"
      }
    },
    "channelAdminLogEventActionChangeLinkedChat": {
      "name": "channelAdminLogEventActionChangeLinkedChat",
      "description": [
        "The linked chat was changed"
      ],
      "fields": {
        "new_value": "New linked chat",
        "prev_value": "Previous linked chat"
      }
    },
    "channelAdminLogEventActionChangeLocation": {
      "name": "channelAdminLogEventActionChangeLocation",
      "description": [
        "The geogroup location was changed"
      ],
      "fields": {
        "new_value": "New location",
        "prev_value": "Previous location"
      }
    },
    "channelAdminLogEventActionChangePhoto": {
      "name": "channelAdminLogEventActionChangePhoto",
      "description": [
        "The channel/supergroup's picture was changed"
      ],
      "fields": {
        "new_photo": "New picture",
        "prev_photo": "Previous picture"
      }
    },
    "channelAdminLogEventActionChangeStickerSet": {
      "name": "channelAdminLogEventActionChangeStickerSet",
      "description": [
        "The supergroup's stickerset was changed"
      ],
      "fields": {
        "new_stickerset": "New stickerset",
        "prev_stickerset": "Previous stickerset"
      }
    },
    "channelAdminLogEventActionChangeTitle": {
      "name": "channelAdminLogEventActionChangeTitle",
      "description": [
        "Channel/supergroup title was changed"
      ],
      "fields": {
        "new_value": "New title",
        "prev_value": "Previous title"
      }
    },
    "channelAdminLogEventActionChangeUsername": {
      "name": "channelAdminLogEventActionChangeUsername",
      "description": [
        "Channel/supergroup username was changed"
      ],
      "fields": {
        "new_value": "New username",
        "prev_value": "Old username"
      }
    },
    "channelAdminLogEventActionDefaultBannedRights": {
      "name": "channelAdminLogEventActionDefaultBannedRights",
      "description": [
        "The default banned rights were modified"
      ],
      "fields": {
        "new_banned_rights": "New glboal banned rights.",
        "prev_banned_rights": "Previous global banned rights"
      }
    },
    "channelAdminLogEventActionDeleteMessage": {
      "name": "channelAdminLogEventActionDeleteMessage",
      "description": [
        "A message was deleted"
      ],
      "fields": {
        "message": "The message that was deleted"
      }
    },
    "channelAdminLogEventActionEditMessage": {
      "name": "channelAdminLogEventActionEditMessage",
      "description": [
        "A message was edited"
      ],
      "fields": {
        "new_message": "New message",
        "prev_message": "Old message"
      }
    },
    "channelAdminLogEventActionParticipantInvite": {
      "name": "channelAdminLogEventActionParticipantInvite",
      "description": [
        "A user was invited to the group"
      ],
      "fields": {
        "participant": "The user that was invited"
      }
    },
    "channelAdminLogEventActionParticipantJoin": {
      "name": "channelAdminLogEventActionParticipantJoin",
      "description": [
        "A user has joined the group (in the case of big groups, info of the user that has joined isn't shown)"
      ]
    },
    "channelAdminLogEventActionParticipantLeave": {
      "name": "channelAdminLogEventActionParticipantLeave",
      "description": [
        "A user left the channel/supergroup (in the case of big groups, info of the user that has joined isn't shown)"
      ]
    },
    "channelAdminLogEventActionParticipantToggleAdmin": {
      "name": "channelAdminLogEventActionParticipantToggleAdmin",
      "description": [
        "The admin rights of a user were changed"
      ],
      "fields": {
        "new_participant": "New admin rights",
        "prev_participant": "Previous admin rights"
      }
    },
    "channelAdminLogEventActionParticipantToggleBan": {
      "name": "channelAdminLogEventActionParticipantToggleBan",
      "description": [
        "The banned rights of a user were changed"
      ],
      "fields": {
        "new_participant": "New banned rights of user",
        "prev_participant": "Old banned rights of user"
      }
    },
    "channelAdminLogEventActionStopPoll": {
      "name": "channelAdminLogEventActionStopPoll",
      "description": [
        "A poll was stopped"
      ],
      "fields": {
        "message": "The poll that was stopped"
      }
    },
    "channelAdminLogEventActionToggleInvites": {
      "name": "channelAdminLogEventActionToggleInvites",
      "description": [
        "Invites were enabled/disabled"
      ],
      "fields": {
        "new_value": "New value"
      }
    },
    "channelAdminLogEventActionTogglePreHistoryHidden": {
      "name": "channelAdminLogEventActionTogglePreHistoryHidden",
      "description": [
        "The hidden prehistory setting was changed"
      ],
      "fields": {
        "new_value": "New value"
      }
    },
    "channelAdminLogEventActionToggleSignatures": {
      "name": "channelAdminLogEventActionToggleSignatures",
      "description": [
        "Channel signatures were enabled/disabled"
      ],
      "fields": {
        "new_value": "New value"
      }
    },
    "channelAdminLogEventActionToggleSlowMode": {
      "name": "channelAdminLogEventActionToggleSlowMode",
      "description": [
        "Slow mode setting for supergroups was changed"
      ],
      "fields": {
        "new_value": "New slow mode value",
        "prev_value": "Previous slow mode value"
      }
    },
    "channelAdminLogEventActionUpdatePinned": {
      "name": "channelAdminLogEventActionUpdatePinned",
      "description": [
        "A message was pinned"
      ],
      "fields": {
        "message": "The message that was pinned"
      }
    },
    "channelAdminLogEventsFilter": {
      "name": "channelAdminLogEventsFilter",
      "description": [
        "Filter only certain admin log events"
      ],
      "fields": {
        "ban": "Ban events",
        "delete": "Message deletion events",
        "demote": "Admin demotion events",
        "edit": "Message edit events",
        "flags": "Flags, see TL conditional fields",
        "info": "Info change events (when about, linked chat, location, photo, stickerset, title or username data of a channel gets modified)",
        "invite": "Invite events",
        "join": "Join events",
        "kick": "Kick events",
        "leave": "Leave events",
        "pinned": "Message pin events",
        "promote": "Admin promotion events",
        "settings": "Settings change events (invites, hidden prehistory, signatures, default banned rights)",
        "unban": "Unban events",
        "unkick": "Unkick events"
      }
    },
    "channelForbidden": {
      "name": "channelForbidden",
      "description": [
        "Indicates a channel/supergroup we can't access because we were banned, or for some other reason."
      ],
      "fields": {
        "access_hash": "Access hash",
        "broadcast": "Is this a channel",
        "flags": "Flags, see TL conditional fields",
        "id": "Channel ID",
        "megagroup": "Is this a supergroup",
        "title": "Title",
        "until_date": "The ban is valid until the specified date"
      }
    },
    "channelFull": {
      "name": "channelFull",
      "description": [
        "Full info about a channel/supergroup"
      ],
      "fields": {
        "about": "Info about the channel",
        "admins_count": "Number of channel admins",
        "available_min_id": "Identifier of a maximum unavailable message in a channel due to hidden history.",
        "banned_count": "Number of users banned from the channel",
        "blocked": "Whether any anonymous admin of this supergroup was blocked: if set, you won't receive messages from anonymous group admins in discussion replies via @replies",
        "bot_info": "Info about bots in the channel/supergrup",
        "can_set_location": "Can we set the geolocation of this group (for geogroups)",
        "can_set_stickers": "Can we associate a stickerpack to the supergroup?",
        "can_set_username": "Can we set the channel's username?",
        "can_view_participants": "Can we vew the participant list?",
        "can_view_stats": "Can the user view channel/supergroup statistics",
        "chat_photo": "Channel picture",
        "exported_invite": "Invite link",
        "flags": "Flags, see TL conditional fields",
        "folder_id": "Peer folder ID, for more info click here",
        "has_scheduled": "Whether scheduled messages are available",
        "hidden_prehistory": "Is the history before we joined hidden to us?",
        "id": "ID of the channel",
        "kicked_count": "Number of users kicked from the channel",
        "linked_chat_id": "ID of the linked discussion chat for channels",
        "location": "Location of the geogroup",
        "migrated_from_chat_id": "The chat ID from which this group was migrated",
        "migrated_from_max_id": "The message ID in the original chat at which this group was migrated",
        "notify_settings": "Notification settings",
        "online_count": "Number of users currently online",
        "participants_count": "Number of participants of the channel",
        "pinned_msg_id": "Message ID of the last pinned message",
        "pts": "Latest PTS for this channel",
        "read_inbox_max_id": "Position up to which all incoming messages are read.",
        "read_outbox_max_id": "Position up to which all outgoing messages are read.",
        "slowmode_next_send_date": "Indicates when the user will be allowed to send another message in the supergroup (unixdate)",
        "slowmode_seconds": "If specified, users in supergroups will only be able to send one message every slowmode_seconds seconds",
        "stats_dc": "If set, specifies the DC to use for fetching channel statistics",
        "stickerset": "Associated stickerset",
        "unread_count": "Count of unread messages"
      }
    },
    "channelLocation": {
      "name": "channelLocation",
      "description": [
        "Geographical location of supergroup (geogroups)"
      ],
      "fields": {
        "address": "Textual description of the address",
        "geo_point": "Geographical location of supergrup"
      }
    },
    "channelLocationEmpty": {
      "name": "channelLocationEmpty",
      "description": [
        "No location (normal supergroup)"
      ]
    },
    "channelMessagesFilter": {
      "name": "channelMessagesFilter",
      "description": [
        "Filter for getting only certain types of channel messages"
      ],
      "fields": {
        "exclude_new_messages": "Whether to exclude new messages from the search",
        "flags": "Flags, see TL conditional fields",
        "ranges": "A range of messages to fetch"
      }
    },
    "channelMessagesFilterEmpty": {
      "name": "channelMessagesFilterEmpty",
      "description": [
        "No filter"
      ]
    },
    "channelParticipant": {
      "name": "channelParticipant",
      "description": [
        "Channel/supergroup participant"
      ],
      "fields": {
        "date": "Date joined",
        "user_id": "Pariticipant user ID"
      }
    },
    "channelParticipantAdmin": {
      "name": "channelParticipantAdmin",
      "description": [
        "Admin"
      ],
      "fields": {
        "admin_rights": "Admin rights",
        "can_edit": "Can this admin promote other admins with the same permissions?",
        "date": "When did the user join",
        "flags": "Flags, see TL conditional fields",
        "inviter_id": "User that invited the admin to the channel/group",
        "promoted_by": "User that promoted the user to admin",
        "rank": "The role (rank) of the admin in the group: just an arbitrary string, admin by default",
        "self": "Is this the current user",
        "user_id": "Admin user ID"
      }
    },
    "channelParticipantBanned": {
      "name": "channelParticipantBanned",
      "description": [
        "Banned/kicked user"
      ],
      "fields": {
        "banned_rights": "Banned rights",
        "date": "When did the user join the group",
        "flags": "Flags, see TL conditional fields",
        "kicked_by": "User was kicked by the specified admin",
        "left": "Whether the user has left the group",
        "user_id": "User ID"
      }
    },
    "channelParticipantCreator": {
      "name": "channelParticipantCreator",
      "description": [
        "Channel/supergroup creator"
      ],
      "fields": {
        "admin_rights": "Creator admin rights",
        "flags": "Flags, see TL conditional fields",
        "rank": "The role (rank) of the group creator in the group: just an arbitrary string, admin by default",
        "user_id": "User ID"
      }
    },
    "channelParticipantLeft": {
      "name": "channelParticipantLeft",
      "description": [
        "A participant that left the channel/supergroup"
      ],
      "fields": {
        "user_id": "User ID"
      }
    },
    "channelParticipantSelf": {
      "name": "channelParticipantSelf",
      "description": [
        "Myself"
      ],
      "fields": {
        "date": "When did I join the channel/supergroup",
        "inviter_id": "User that invited me to the channel/supergroup",
        "user_id": "User ID"
      }
    },
    "channelParticipantsAdmins": {
      "name": "channelParticipantsAdmins",
      "description": [
        "Fetch only admin participants"
      ]
    },
    "channelParticipantsBanned": {
      "name": "channelParticipantsBanned",
      "description": [
        "Fetch only banned participants"
      ],
      "fields": {
        "q": "Optional filter for searching banned participants by name (otherwise empty)"
      }
    },
    "channelParticipantsBots": {
      "name": "channelParticipantsBots",
      "description": [
        "Fetch only bot participants"
      ]
    },
    "channelParticipantsContacts": {
      "name": "channelParticipantsContacts",
      "description": [
        "Fetch only participants that are also contacts"
      ],
      "fields": {
        "q": "Optional search query for searching contact participants by name"
      }
    },
    "channelParticipantsKicked": {
      "name": "channelParticipantsKicked",
      "description": [
        "Fetch only kicked participants"
      ],
      "fields": {
        "q": "Optional filter for searching kicked participants by name (otherwise empty)"
      }
    },
    "channelParticipantsMentions": {
      "name": "channelParticipantsMentions",
      "description": [
        "This filter is used when looking for supergroup members to mention.\nThis filter will automatically remove anonymous admins, and return even non-participant users that replied to a specific thread through the comment section of a channel."
      ],
      "fields": {
        "flags": "Flags, see TL conditional fields",
        "q": "Filter by user name or username",
        "top_msg_id": "Look only for users that posted in this thread"
      }
    },
    "channelParticipantsRecent": {
      "name": "channelParticipantsRecent",
      "description": [
        "Fetch only recent participants"
      ]
    },
    "channelParticipantsSearch": {
      "name": "channelParticipantsSearch",
      "description": [
        "Query participants by name"
      ],
      "fields": {
        "q": "Search query"
      }
    },
    "channels.adminLogResults": {
      "name": "channels.adminLogResults",
      "description": [
        "Admin log events"
      ],
      "fields": {
        "chats": "Chats mentioned in events",
        "events": "Admin log events",
        "users": "Users mentioned in events"
      }
    },
    "channels.channelParticipant": {
      "name": "channels.channelParticipant",
      "description": [
        "Represents a channel participant"
      ],
      "fields": {
        "participant": "The channel participant",
        "users": "Users"
      }
    },
    "channels.channelParticipants": {
      "name": "channels.channelParticipants",
      "description": [
        "Represents multiple channel participants"
      ],
      "fields": {
        "count": "Total number of participants that correspond to the given query",
        "participants": "Participants",
        "users": "Users mentioned in participant info"
      }
    },
    "channels.channelParticipantsNotModified": {
      "name": "channels.channelParticipantsNotModified",
      "description": [
        "No new participant info could be found"
      ]
    },
    "chat": {
      "name": "chat",
      "description": [
        "Info about a group"
      ],
      "fields": {
        "admin_rights": "Admin rights of the user in the group",
        "creator": "Whether the current user is the creator of the group",
        "date": "Date of creation of the group",
        "deactivated": "Whether the group was migrated",
        "default_banned_rights": "Default banned rights of all users in the group",
        "flags": "Flags, see TL conditional fields",
        "id": "ID of the group",
        "kicked": "Whether the current user was kicked from the group",
        "left": "Whether the current user has left the group",
        "migrated_to": "Means this chat was upgraded to a supergroup",
        "participants_count": "Participant count",
        "photo": "Chat photo",
        "title": "Title",
        "version": "Used in basic groups to reorder updates and make sure that all of them were received."
      }
    },
    "chatAdminRights": {
      "name": "chatAdminRights",
      "description": [
        "Represents the rights of an admin in a channel/supergroup."
      ],
      "fields": {
        "add_admins": "If set, allows the admin to add other admins with the same (or more limited) permissions in the channel/supergroup",
        "anonymous": "Whether this admin is anonymous",
        "ban_users": "If set, allows the admin to ban users from the channel/supergroup",
        "change_info": "If set, allows the admin to modify the description of the channel/supergroup",
        "delete_messages": "If set, allows the admin to also delete messages from other admins in the channel",
        "edit_messages": "If set, allows the admin to also edit messages from other admins in the channel",
        "flags": "Flags, see TL conditional fields",
        "invite_users": "If set, allows the admin to invite users in the channel/supergroup",
        "pin_messages": "If set, allows the admin to pin messages in the channel/supergroup",
        "post_messages": "If set, allows the admin to post messages in the channel"
      }
    },
    "chatBannedRights": {
      "name": "chatBannedRights",
      "description": [
        "Represents the rights of a normal user in a supergroup/channel/chat. In this case, the flags are inverted: if set, a flag does not allow a user to do X."
      ],
      "fields": {
        "change_info": "If set, does not allow any user to change the description of a supergroup/chat",
        "embed_links": "If set, does not allow a user to embed links in the messages of a supergroup/chat",
        "flags": "Flags, see TL conditional fields",
        "invite_users": "If set, does not allow any user to invite users in a supergroup/chat",
        "pin_messages": "If set, does not allow any user to pin messages in a supergroup/chat",
        "send_games": "If set, does not allow a user to send games in a supergroup/chat",
        "send_gifs": "If set, does not allow a user to send gifs in a supergroup/chat",
        "send_inline": "If set, does not allow a user to use inline bots in a supergroup/chat",
        "send_media": "If set, does not allow a user to send any media in a supergroup/chat",
        "send_messages": "If set, does not allow a user to send messages in a supergroup/chat",
        "send_polls": "If set, does not allow a user to send stickers in a supergroup/chat",
        "send_stickers": "If set, does not allow a user to send stickers in a supergroup/chat",
        "until_date": "Validity of said permissions (it is considered forever any value less then 30 seconds or more then 366 days).",
        "view_messages": "If set, does not allow a user to view messages in a supergroup/channel/chat"
      }
    },
    "chatEmpty": {
      "name": "chatEmpty",
      "description": [
        "Empty constructor, group doesn't exist"
      ],
      "fields": {
        "id": "Group identifier"
      }
    },
    "chatForbidden": {
      "name": "chatForbidden",
      "description": [
        "A group to which the user has no access. E.g., because the user was kicked from the group."
      ],
      "fields": {
        "id": "User identifier",
        "title": "Group name"
      }
    },
    "chatFull": {
      "name": "chatFull",
      "description": [
        "Detailed chat info"
      ],
      "fields": {
        "about": "About string for this chat",
        "bot_info": "Info about bots that are in this chat",
        "can_set_username": "Can we change the username of this chat",
        "chat_photo": "Chat photo",
        "exported_invite": "Chat invite",
        "flags": "Flags, see TL conditional fields",
        "folder_id": "Peer folder ID, for more info click here",
        "has_scheduled": "Whether scheduled messages are available",
        "id": "ID of the chat",
        "notify_settings": "Notification settings",
        "participants": "Participant list",
        "pinned_msg_id": "Message ID of the last pinned message"
      }
    },
    "chatInvite": {
      "name": "chatInvite",
      "description": [
        "Chat invite info"
      ],
      "fields": {
        "broadcast": "Whether this is a channel",
        "channel": "Whether this is a channel/supergroup or a normal group",
        "flags": "Flags, see TL conditional fields",
        "megagroup": "Whether this is a supergroup",
        "participants": "A few of the participants that are in the group",
        "participants_count": "Participant count",
        "photo": "Chat/supergroup/channel photo",
        "public": "Whether this is a public channel/supergroup",
        "title": "Chat/supergroup/channel title"
      }
    },
    "chatInviteAlready": {
      "name": "chatInviteAlready",
      "description": [
        "The user has already joined this chat"
      ],
      "fields": {
        "chat": "The chat connected to the invite"
      }
    },
    "chatInviteEmpty": {
      "name": "chatInviteEmpty",
      "description": [
        "No info is associated to the chat invite"
      ]
    },
    "chatInviteExported": {
      "name": "chatInviteExported",
      "description": [
        "Exported chat invite"
      ],
      "fields": {
        "link": "Chat invitation link"
      }
    },
    "chatInvitePeek": {
      "name": "chatInvitePeek",
      "description": [
        "A chat invitation that also allows peeking into the group to read messages without joining it."
      ],
      "fields": {
        "chat": "Chat information",
        "expires": "Read-only anonymous access to this group will be revoked at this date"
      }
    },
    "chatOnlines": {
      "name": "chatOnlines",
      "description": [
        "Number of online users in a chat"
      ],
      "fields": {
        "onlines": "Number of online users"
      }
    },
    "chatParticipant": {
      "name": "chatParticipant",
      "description": [
        "Group member."
      ],
      "fields": {
        "date": "Date added to the group",
        "inviter_id": "ID of the user that added the member to the group",
        "user_id": "Member user ID"
      }
    },
    "chatParticipantAdmin": {
      "name": "chatParticipantAdmin",
      "description": [
        "Chat admin"
      ],
      "fields": {
        "date": "Date when the user was added",
        "inviter_id": "ID of the user that added the member to the group",
        "user_id": "ID of a group member that is admin"
      }
    },
    "chatParticipantCreator": {
      "name": "chatParticipantCreator",
      "description": [
        "Represents the creator of the group"
      ],
      "fields": {
        "user_id": "ID of the user that created the group"
      }
    },
    "chatParticipants": {
      "name": "chatParticipants",
      "description": [
        "Group members."
      ],
      "fields": {
        "chat_id": "Group identifier",
        "participants": "List of group members",
        "version": "Group version number"
      }
    },
    "chatParticipantsForbidden": {
      "name": "chatParticipantsForbidden",
      "description": [
        "Info on members is unavailable"
      ],
      "fields": {
        "chat_id": "Group ID",
        "flags": "Flags, see TL conditional fields",
        "self_participant": "Info about the group membership of the current user"
      }
    },
    "chatPhoto": {
      "name": "chatPhoto",
      "description": [
        "Group profile photo."
      ],
      "fields": {
        "dc_id": "DC where this photo is stored",
        "flags": "Flags, see TL conditional fields",
        "has_video": "Whether the user has an animated profile picture",
        "photo_big": "Location of the file corresponding to the small thumbnail for group profile photo",
        "photo_small": "Location of the file corresponding to the small thumbnail for group profile photo"
      }
    },
    "chatPhotoEmpty": {
      "name": "chatPhotoEmpty",
      "description": [
        "Group photo is not set."
      ]
    },
    "codeSettings": {
      "name": "codeSettings",
      "description": [
        "Settings used by telegram servers for sending the confirm code.",
        "Example implementations: telegram for android, tdlib."
      ],
      "fields": {
        "allow_app_hash": "If a token that will be included in eventually sent SMSs is required: required in newer versions of android, to use the android SMS receiver APIs",
        "allow_flashcall": "Whether to allow phone verification via phone calls.",
        "current_number": "Pass true if the phone number is used on the current device. Ignored if allow_flashcall is not set.",
        "flags": "Flags, see TL conditional fields"
      }
    },
    "config": {
      "name": "config",
      "description": [
        "Current configuration"
      ],
      "fields": {
        "autoupdate_url_prefix": "URL to use to auto-update the current app",
        "base_lang_pack_version": "Basic language pack version",
        "blocked_mode": "Indicates that telegram is probably censored by governments/ISPs in the current region",
        "call_connect_timeout_ms": "VoIP connection timeout: if the instance of libtgvoip on the other side of the call doesn't connect to our instance of libtgvoip within the specified time (in milliseconds), the call must be aborted",
        "call_packet_timeout_ms": "If during a VoIP call a packet isn't received for the specified period of time, the call must be aborted",
        "call_receive_timeout_ms": "Maximum allowed outgoing ring time in VoIP calls: if the user we're calling doesn't reply within the specified time (in milliseconds), we should hang up the call",
        "call_ring_timeout_ms": "Maximum allowed incoming ring time in VoIP calls: if the current user doesn't reply within the specified time (in milliseconds), the call will be automatically refused",
        "caption_length_max": "Maximum length of caption (length in utf8 codepoints)",
        "channels_read_media_period": "Indicates that round videos (video notes) and voice messages sent in channels and older than the specified period must be marked as read",
        "chat_size_max": "Maximum member count for normal groups",
        "date": "Current date at the server",
        "dc_options": "DC IP list",
        "dc_txt_domain_name": "Domain name for fetching encrypted DC list from DNS TXT record",
        "default_p2p_contacts": "Whether the client should use P2P by default for phone calls with contacts",
        "edit_time_limit": "Only messages with age smaller than the one specified can be edited",
        "expires": "Expiration date of this config: when it expires it'll have to be refetched using help.getConfig",
        "flags": "Flags, see TL conditional fields",
        "forwarded_count_max": "Maximum number of messages that can be forwarded at once using messages.forwardMessages.",
        "gif_search_username": "Username of the bot to use to search for GIFs",
        "ignore_phone_entities": "Whether the client should ignore phone entities",
        "img_search_username": "Username of the bot to use for image search",
        "lang_pack_version": "Language pack version",
        "me_url_prefix": "The domain to use to parse in-app links.For example t.me indicates that t.me/username links should parsed to @username, t.me/addsticker/name should be parsed to the appropriate stickerset and so on...",
        "megagroup_size_max": "Maximum member count for supergroups",
        "message_length_max": "Maximum length of messages (length in utf8 codepoints)",
        "notify_cloud_delay_ms": "If we are offline, but online from some other client then delay sending the offline notification for notify_cloud_delay_ms milliseconds.",
        "notify_default_delay_ms": "If some other client is online, then delay notification for notification_default_delay_ms milliseconds",
        "offline_blur_timeout_ms": "Delay before offline status needs to be sent to the server",
        "offline_idle_timeout_ms": "Time without any user activity after which it should be treated offline",
        "online_cloud_timeout_ms": "If we are offline, but were online from some other client in last online_cloud_timeout_ms milliseconds after we had gone offline, then delay offline notification for notify_cloud_delay_ms milliseconds.",
        "online_update_period_ms": "The client should update its online status every N milliseconds",
        "pfs_enabled": "Whether pfs was used",
        "phonecalls_enabled": "Whether phone calls can be used",
        "pinned_dialogs_count_max": "Maximum count of pinned dialogs",
        "pinned_infolder_count_max": "Maximum count of dialogs per folder",
        "preload_featured_stickers": "Whether the client should preload featured stickers",
        "push_chat_limit": "Not for client use",
        "push_chat_period_ms": "Not for client use",
        "rating_e_decay": "Exponential decay rate for computing top peer rating",
        "revoke_pm_inbox": "Whether incoming private messages can be deleted for both participants",
        "revoke_pm_time_limit": "Only private messages with age smaller than the specified can be deleted",
        "revoke_time_limit": "Only channel/supergroup messages with age smaller than the specified can be deleted",
        "saved_gifs_limit": "Maximum count of saved gifs",
        "static_maps_provider": "ID of the map provider to use for venues",
        "stickers_faved_limit": "Maximum number of faved stickers",
        "stickers_recent_limit": "Maximum number of recent stickers",
        "suggested_lang_code": "Suggested language code",
        "test_mode": "Whether we're connected to the test DCs",
        "this_dc": "ID of the DC that returned the reply",
        "tmp_sessions": "Temporary passport sessions",
        "venue_search_username": "Username of the bot to use to search for venues",
        "webfile_dc_id": "DC ID to use to download webfiles"
      }
    },
    "contact": {
      "name": "contact",
      "description": [
        "A contact of the current user that is registered in the system."
      ],
      "fields": {
        "mutual": "Current user is in the user's contact list",
        "user_id": "User identifier"
      }
    },
    "contactStatus": {
      "name": "contactStatus",
      "description": [
        "Contact status: online / offline."
      ],
      "fields": {
        "status": "Online status",
        "user_id": "User identifier"
      }
    },
    "contacts.blocked": {
      "name": "contacts.blocked",
      "description": [
        "Full list of blocked users."
      ],
      "fields": {
        "blocked": "List of blocked users",
        "chats": "Blocked chats",
        "users": "List of users"
      }
    },
    "contacts.blockedSlice": {
      "name": "contacts.blockedSlice",
      "description": [
        "Incomplete list of blocked users."
      ],
      "fields": {
        "blocked": "List of blocked users",
        "chats": "Blocked chats",
        "count": "Total number of elements in the list",
        "users": "List of users"
      }
    },
    "contacts.contacts": {
      "name": "contacts.contacts",
      "description": [
        "The current user's contact list and info on users."
      ],
      "fields": {
        "contacts": "Contact list",
        "saved_count": "Number of contacts that were saved successfully",
        "users": "User list"
      }
    },
    "contacts.contactsNotModified": {
      "name": "contacts.contactsNotModified",
      "description": [
        "Contact list on the server is the same as the list on the client."
      ]
    },
    "contacts.found": {
      "name": "contacts.found",
      "description": [
        "Users found by name substring and auxiliary data."
      ],
      "fields": {
        "chats": "Found chats",
        "my_results": "Personalized results",
        "results": "List of found user identifiers",
        "users": "List of users"
      }
    },
    "contacts.importedContacts": {
      "name": "contacts.importedContacts",
      "description": [
        "Info on succesfully imported contacts."
      ],
      "fields": {
        "imported": "List of succesfully imported contacts",
        "popular_invites": "Popular contacts",
        "retry_contacts": "List of contact ids that could not be imported due to system limitation and will need to be imported at a later date.Parameter added in Layer 13",
        "users": "List of users"
      }
    },
    "contacts.resolvedPeer": {
      "name": "contacts.resolvedPeer",
      "description": [
        "Resolved peer"
      ],
      "fields": {
        "chats": "Chats",
        "peer": "The peer",
        "users": "Users"
      }
    },
    "contacts.topPeers": {
      "name": "contacts.topPeers",
      "description": [
        "Top peers"
      ],
      "fields": {
        "categories": "Top peers by top peer category",
        "chats": "Chats",
        "users": "Users"
      }
    },
    "contacts.topPeersDisabled": {
      "name": "contacts.topPeersDisabled",
      "description": [
        "Top peers disabled"
      ]
    },
    "contacts.topPeersNotModified": {
      "name": "contacts.topPeersNotModified",
      "description": [
        "Top peer info hasn't changed"
      ]
    },
    "dataJSON": {
      "name": "dataJSON",
      "description": [
        "Represents a json-encoded object"
      ],
      "fields": {
        "data": "JSON-encoded object"
      }
    },
    "dcOption": {
      "name": "dcOption",
      "description": [
        "Data centre"
      ],
      "fields": {
        "cdn": "Whether this is a CDN DC.",
        "flags": "Flags, see TL conditional fields",
        "id": "DC ID",
        "ip_address": "IP address of DC",
        "ipv6": "Whether the specified IP is an IPv6 address",
        "media_only": "Whether this DC should only be used to download or upload files",
        "port": "Port",
        "secret": "If the tcpo_only flag is set, specifies the secret to use when connecting using transport obfuscation",
        "static": "If set, this IP should be used when connecting through a proxy",
        "tcpo_only": "Whether this DC only supports connection with transport obfuscation"
      }
    },
    "dialog": {
      "name": "dialog",
      "description": [
        "Chat"
      ],
      "fields": {
        "draft": "Message draft",
        "flags": "Flags, see TL conditional fields",
        "folder_id": "Peer folder ID, for more info click here",
        "notify_settings": "Notification settings",
        "peer": "The chat",
        "pinned": "Is the dialog pinned",
        "pts": "PTS",
        "read_inbox_max_id": "Position up to which all incoming messages are read.",
        "read_outbox_max_id": "Position up to which all outgoing messages are read.",
        "top_message": "The latest message ID",
        "unread_count": "Number of unread messages",
        "unread_mark": "Whether the chat was manually marked as unread",
        "unread_mentions_count": "Number of unread mentions"
      }
    },
    "dialogFilter": {
      "name": "dialogFilter",
      "description": [
        "Dialog filter AKA folder"
      ],
      "fields": {
        "bots": "Whether to include all bots in this folder",
        "broadcasts": "Whether to include all channels in this folder",
        "contacts": "Whether to include all contacts in this folder",
        "emoticon": "Folder emoticon",
        "exclude_archived": "Whether to exclude archived chats from this folder",
        "exclude_muted": "Whether to exclude muted chats from this folder",
        "exclude_peers": "Exclude the following chats from this folder",
        "exclude_read": "Whether to exclude read chats from this folder",
        "flags": "Flags, see TL conditional fields",
        "groups": "Whether to include all groups in this folder",
        "id": "Folder ID",
        "include_peers": "Include the following chats in this folder",
        "non_contacts": "Whether to include all non-contacts in this folder",
        "pinned_peers": "Pinned chats, folders can have unlimited pinned chats",
        "title": "Folder name"
      }
    },
    "dialogFilterSuggested": {
      "name": "dialogFilterSuggested",
      "description": [
        "Suggested folders"
      ],
      "fields": {
        "description": "Folder description",
        "filter": "Folder info"
      }
    },
    "dialogFolder": {
      "name": "dialogFolder",
      "description": [
        "Dialog in folder"
      ],
      "fields": {
        "flags": "Flags, see TL conditional fields",
        "folder": "The folder",
        "peer": "Peer in folder",
        "pinned": "Is this folder pinned",
        "top_message": "Latest message ID of dialog",
        "unread_muted_messages_count": "Number of unread messages from muted peers in folder",
        "unread_muted_peers_count": "Number of unread muted peers in folder",
        "unread_unmuted_messages_count": "Number of unread messages from unmuted peers in folder",
        "unread_unmuted_peers_count": "Number of unread unmuted peers in folder"
      }
    },
    "dialogPeer": {
      "name": "dialogPeer",
      "description": [
        "Peer"
      ],
      "fields": {
        "peer": "Peer"
      }
    },
    "dialogPeerFolder": {
      "name": "dialogPeerFolder",
      "description": [
        "Peer folder"
      ],
      "fields": {
        "folder_id": "Peer folder ID, for more info click here"
      }
    },
    "document": {
      "name": "document",
      "description": [
        "Document"
      ],
      "fields": {
        "access_hash": "Check sum, dependant on document ID",
        "attributes": "Attributes",
        "date": "Creation date",
        "dc_id": "DC ID",
        "file_reference": "File reference",
        "flags": "Flags, see TL conditional fields",
        "id": "Document ID",
        "mime_type": "MIME type",
        "size": "Size",
        "thumbs": "Thumbnails",
        "video_thumbs": "Video thumbnails"
      }
    },
    "documentAttributeAnimated": {
      "name": "documentAttributeAnimated",
      "description": [
        "Defines an animated GIF"
      ]
    },
    "documentAttributeAudio": {
      "name": "documentAttributeAudio",
      "description": [
        "Represents an audio file"
      ],
      "fields": {
        "duration": "Duration in seconds",
        "flags": "Flags, see TL conditional fields",
        "performer": "Performer",
        "title": "Name of song",
        "voice": "Whether this is a voice message",
        "waveform": "Waveform"
      }
    },
    "documentAttributeFilename": {
      "name": "documentAttributeFilename",
      "description": [
        "A simple document with a file name"
      ],
      "fields": {
        "file_name": "The file name"
      }
    },
    "documentAttributeHasStickers": {
      "name": "documentAttributeHasStickers",
      "description": [
        "Whether the current document has stickers attached"
      ]
    },
    "documentAttributeImageSize": {
      "name": "documentAttributeImageSize",
      "description": [
        "Defines the width and height of an image uploaded as document"
      ],
      "fields": {
        "h": "Height of image",
        "w": "Width of image"
      }
    },
    "documentAttributeSticker": {
      "name": "documentAttributeSticker",
      "description": [
        "Defines a sticker"
      ],
      "fields": {
        "alt": "Alternative emoji representation of sticker",
        "flags": "Flags, see TL conditional fields",
        "mask": "Whether this is a mask sticker",
        "mask_coords": "Mask coordinates (if this is a mask sticker, attached to a photo)",
        "stickerset": "Associated stickerset"
      }
    },
    "documentAttributeVideo": {
      "name": "documentAttributeVideo",
      "description": [
        "Defines a video"
      ],
      "fields": {
        "duration": "Duration in seconds",
        "flags": "Flags, see TL conditional fields",
        "h": "Video height",
        "round_message": "Whether this is a round video",
        "supports_streaming": "Whether the video supports streaming",
        "w": "Video width"
      }
    },
    "documentEmpty": {
      "name": "documentEmpty",
      "description": [
        "Empty constructor, document doesn't exist."
      ],
      "fields": {
        "id": "Document ID or 0"
      }
    },
    "draftMessage": {
      "name": "draftMessage",
      "description": [
        "Represents a message draft."
      ],
      "fields": {
        "date": "Date of last update of the draft.",
        "entities": "Message entities for styled text.",
        "flags": "Flags, see TL conditional fields",
        "message": "The draft",
        "no_webpage": "Whether no webpage preview will be generated",
        "reply_to_msg_id": "The message this message will reply to"
      }
    },
    "draftMessageEmpty": {
      "name": "draftMessageEmpty",
      "description": [
        "Empty draft"
      ],
      "fields": {
        "date": "When was the draft last updated",
        "flags": "Flags, see TL conditional fields"
      }
    },
    "emojiKeyword": {
      "name": "emojiKeyword",
      "description": [
        "Emoji keyword"
      ],
      "fields": {
        "emoticons": "Emojis associated to keyword",
        "keyword": "Keyword"
      }
    },
    "emojiKeywordDeleted": {
      "name": "emojiKeywordDeleted",
      "description": [
        "Deleted emoji keyword"
      ],
      "fields": {
        "emoticons": "Emojis that were associated to keyword",
        "keyword": "Keyword"
      }
    },
    "emojiKeywordsDifference": {
      "name": "emojiKeywordsDifference",
      "description": [
        "Changes to emoji keywords"
      ],
      "fields": {
        "from_version": "Previous emoji keyword list version",
        "keywords": "Emojis associated to keywords",
        "lang_code": "Language code for keywords",
        "version": "Current version of emoji keyword list"
      }
    },
    "emojiLanguage": {
      "name": "emojiLanguage",
      "description": [
        "Emoji language"
      ],
      "fields": {
        "lang_code": "Language code"
      }
    },
    "emojiURL": {
      "name": "emojiURL",
      "description": [
        "An HTTP URL which can be used to automatically log in into translation platform and suggest new emoji replacements. The URL will be valid for 30 seconds after generation"
      ],
      "fields": {
        "url": "An HTTP URL which can be used to automatically log in into translation platform and suggest new emoji replacements. The URL will be valid for 30 seconds after generation"
      }
    },
    "encryptedChat": {
      "name": "encryptedChat",
      "description": [
        "Encrypted chat"
      ],
      "fields": {
        "access_hash": "Check sum dependant on the user ID",
        "admin_id": "Chat creator ID",
        "date": "Date chat was created",
        "g_a_or_b": "B = g ^ b mod p, if the currently authorized user is the chat's creator,or A = g ^ a mod p otherwiseSee Wikipedia for more info",
        "id": "Chat ID",
        "key_fingerprint": "64-bit fingerprint of received key",
        "participant_id": "ID of the second chat participant"
      }
    },
    "encryptedChatDiscarded": {
      "name": "encryptedChatDiscarded",
      "description": [
        "Discarded or deleted chat."
      ],
      "fields": {
        "id": "Chat ID"
      }
    },
    "encryptedChatEmpty": {
      "name": "encryptedChatEmpty",
      "description": [
        "Empty constructor."
      ],
      "fields": {
        "id": "Chat ID"
      }
    },
    "encryptedChatRequested": {
      "name": "encryptedChatRequested",
      "description": [
        "Request to create an encrypted chat."
      ],
      "fields": {
        "access_hash": "Check sum depending on user ID",
        "admin_id": "Chat creator ID",
        "date": "Chat creation date",
        "flags": "Flags, see TL conditional fields",
        "folder_id": "Peer folder ID, for more info click here",
        "g_a": "A = g ^ a mod p, see Wikipedia",
        "id": "Chat ID",
        "participant_id": "ID of second chat participant"
      }
    },
    "encryptedChatWaiting": {
      "name": "encryptedChatWaiting",
      "description": [
        "Chat waiting for approval of second participant."
      ],
      "fields": {
        "access_hash": "Checking sum depending on user ID",
        "admin_id": "Chat creator ID",
        "date": "Date of chat creation",
        "id": "Chat ID",
        "participant_id": "ID of second chat participant"
      }
    },
    "encryptedFile": {
      "name": "encryptedFile",
      "description": [
        "Encrypted file."
      ],
      "fields": {
        "access_hash": "Checking sum depending on user ID",
        "dc_id": "Number of data centre",
        "id": "File ID",
        "key_fingerprint": "32-bit fingerprint of key used for file encryption",
        "size": "File size in bytes"
      }
    },
    "encryptedFileEmpty": {
      "name": "encryptedFileEmpty",
      "description": [
        "Empty constructor, unexisitng file."
      ]
    },
    "encryptedMessage": {
      "name": "encryptedMessage",
      "description": [
        "Encrypted message."
      ],
      "fields": {
        "bytes": "TL-serialising of DecryptedMessage type, encrypted with the key creatied at stage of chat initialization",
        "chat_id": "ID of encrypted chat",
        "date": "Date of sending",
        "file": "Attached encrypted file",
        "random_id": "Random message ID, assigned by the author of message"
      }
    },
    "encryptedMessageService": {
      "name": "encryptedMessageService",
      "description": [
        "Encrypted service message"
      ],
      "fields": {
        "bytes": "TL-serialising of DecryptedMessage type, encrypted with the key creatied at stage of chat initialization",
        "chat_id": "ID of encrypted chat",
        "date": "Date of sending",
        "random_id": "Random message ID, assigned by the author of message"
      }
    },
    "error": {
      "name": "error",
      "description": [
        "Error."
      ],
      "fields": {
        "code": "Error code",
        "text": "Message"
      }
    },
    "exportedMessageLink": {
      "name": "exportedMessageLink",
      "description": [
        "Link to a message in a supergroup/channel"
      ],
      "fields": {
        "html": "Embed code",
        "link": "URL"
      }
    },
    "fileLocationToBeDeprecated": {
      "name": "fileLocationToBeDeprecated",
      "description": [
        "Indicates the location of a photo, will be deprecated soon"
      ],
      "fields": {
        "local_id": "Local ID",
        "volume_id": "Volume ID"
      }
    },
    "folder": {
      "name": "folder",
      "description": [
        "Folder"
      ],
      "fields": {
        "autofill_new_broadcasts": "Automatically add new channels to this folder",
        "autofill_new_correspondents": "Automatically add new private chats to this folder",
        "autofill_public_groups": "Automatically add joined new public supergroups to this folder",
        "flags": "Flags, see TL conditional fields",
        "id": "Folder ID",
        "photo": "Folder picture",
        "title": "Folder title"
      }
    },
    "folderPeer": {
      "name": "folderPeer",
      "description": [
        "Peer in a folder"
      ],
      "fields": {
        "folder_id": "Peer folder ID, for more info click here",
        "peer": "Folder peer info"
      }
    },
    "game": {
      "name": "game",
      "description": [
        "Indicates an already sent game"
      ],
      "fields": {
        "access_hash": "Access hash of the game",
        "description": "Game description",
        "document": "Optional attached document",
        "flags": "Flags, see TL conditional fields",
        "id": "ID of the game",
        "photo": "Game preview",
        "short_name": "Short name for the game",
        "title": "Title of the game"
      }
    },
    "geoPoint": {
      "name": "geoPoint",
      "description": [
        "GeoPoint."
      ],
      "fields": {
        "access_hash": "Access hash",
        "accuracy_radius": "The estimated horizontal accuracy of the location, in meters; as defined by the sender.",
        "flags": "Flags, see TL conditional fields",
        "lat": "Latitude",
        "long": "Longtitude"
      }
    },
    "geoPointEmpty": {
      "name": "geoPointEmpty",
      "description": [
        "Empty constructor."
      ]
    },
    "globalPrivacySettings": {
      "name": "globalPrivacySettings",
      "description": [
        "Global privacy settings"
      ],
      "fields": {
        "archive_and_mute_new_noncontact_peers": "Whether to archive and mute new chats from non-contacts",
        "flags": "Flags, see TL conditional fields"
      }
    },
    "help.appUpdate": {
      "name": "help.appUpdate",
      "description": [
        "An update is available for the application."
      ],
      "fields": {
        "can_not_skip": "Unskippable, the new info must be shown to the user (with a popup or something else)",
        "document": "Application binary",
        "entities": "Message entities for styled text",
        "flags": "Flags, see TL conditional fields",
        "id": "Update ID",
        "text": "Text description of the update",
        "url": "Application download URL",
        "version": "New version name"
      }
    },
    "help.countriesList": {
      "name": "help.countriesList",
      "description": [
        "Name, ISO code, localized name and phone codes/patterns of all available countries"
      ],
      "fields": {
        "countries": "Name, ISO code, localized name and phone codes/patterns of all available countries",
        "hash": "Hash for pagination, for more info click here"
      }
    },
    "help.countriesListNotModified": {
      "name": "help.countriesListNotModified",
      "description": [
        "The country list has not changed"
      ]
    },
    "help.country": {
      "name": "help.country",
      "description": [
        "Name, ISO code, localized name and phone codes/patterns of a specific country"
      ],
      "fields": {
        "country_codes": "Phone codes/patterns",
        "default_name": "Name of the country in the country's language",
        "flags": "Flags, see TL conditional fields",
        "hidden": "Whether this country should not be shown in the list",
        "iso2": "ISO code of country",
        "name": "Name of the country in the user's language, if different from the original name"
      }
    },
    "help.countryCode": {
      "name": "help.countryCode",
      "description": [
        "Country code and phone number pattern of a specific country"
      ],
      "fields": {
        "country_code": "ISO country code",
        "flags": "Flags, see TL conditional fields",
        "patterns": "Phone patterns: for example, XXX XXX XXX",
        "prefixes": "Possible phone prefixes"
      }
    },
    "help.deepLinkInfo": {
      "name": "help.deepLinkInfo",
      "description": [
        "Deep linking info"
      ],
      "fields": {
        "entities": "Message entities for styled text",
        "flags": "Flags, see TL conditional fields",
        "message": "Message to show to the user",
        "update_app": "An update of the app is required to parse this link"
      }
    },
    "help.deepLinkInfoEmpty": {
      "name": "help.deepLinkInfoEmpty",
      "description": [
        "Deep link info empty"
      ]
    },
    "help.inviteText": {
      "name": "help.inviteText",
      "description": [
        "Text of a text message with an invitation to install Telegram."
      ],
      "fields": {
        "message": "Text of the message"
      }
    },
    "help.noAppUpdate": {
      "name": "help.noAppUpdate",
      "description": [
        "No updates are available for the application."
      ]
    },
    "help.passportConfig": {
      "name": "help.passportConfig",
      "description": [
        "Telegram passport configuration"
      ],
      "fields": {
        "countries_langs": "Localization",
        "hash": "Hash for pagination, for more info click here"
      }
    },
    "help.passportConfigNotModified": {
      "name": "help.passportConfigNotModified",
      "description": [
        "Password configuration not modified"
      ]
    },
    "help.promoData": {
      "name": "help.promoData",
      "description": [
        "MTProxy/Public Service Announcement information"
      ],
      "fields": {
        "chats": "Chat info",
        "expires": "Expiry of PSA/MTProxy info",
        "flags": "Flags, see TL conditional fields",
        "peer": "MTProxy/PSA peer",
        "proxy": "MTProxy-related channel",
        "psa_message": "PSA message",
        "psa_type": "PSA type",
        "users": "User info"
      }
    },
    "help.promoDataEmpty": {
      "name": "help.promoDataEmpty",
      "description": [
        "No PSA/MTProxy info is available"
      ],
      "fields": {
        "expires": "Re-fetch PSA/MTProxy info after the specified number of seconds"
      }
    },
    "help.recentMeUrls": {
      "name": "help.recentMeUrls",
      "description": [
        "Recent t.me URLs"
      ],
      "fields": {
        "chats": "Chats",
        "urls": "URLs",
        "users": "Users"
      }
    },
    "help.support": {
      "name": "help.support",
      "description": [
        "Info on support user."
      ],
      "fields": {
        "phone_number": "Phone number",
        "user": "User"
      }
    },
    "help.supportName": {
      "name": "help.supportName",
      "description": [
        "Localized name for telegram support"
      ],
      "fields": {
        "name": "Localized name"
      }
    },
    "help.termsOfService": {
      "name": "help.termsOfService",
      "description": [
        "Info about the latest telegram Terms Of Service"
      ],
      "fields": {
        "entities": "Message entities for styled text",
        "flags": "Flags, see TL conditional fields",
        "id": "ID of the new terms",
        "min_age_confirm": "Minimum age required to sign up to telegram, the user must confirm that they is older than the minimum age.",
        "popup": "Whether a prompt must be showed to the user, in order to accept the new terms.",
        "text": "Text of the new terms"
      }
    },
    "help.termsOfServiceUpdate": {
      "name": "help.termsOfServiceUpdate",
      "description": [
        "Info about an update of telegram's terms of service. If the terms of service are declined, then the account.deleteAccount method should be called with the reason \"Decline ToS update\""
      ],
      "fields": {
        "expires": "New TOS updates will have to be queried using help.getTermsOfServiceUpdate in expires seconds",
        "terms_of_service": "New terms of service"
      }
    },
    "help.termsOfServiceUpdateEmpty": {
      "name": "help.termsOfServiceUpdateEmpty",
      "description": [
        "No changes were made to telegram's terms of service"
      ],
      "fields": {
        "expires": "New TOS updates will have to be queried using help.getTermsOfServiceUpdate in expires seconds"
      }
    },
    "help.userInfo": {
      "name": "help.userInfo",
      "description": [
        "Internal use"
      ],
      "fields": {
        "author": "Author",
        "date": "Date",
        "entities": "Message entities for styled text",
        "message": "Info"
      }
    },
    "help.userInfoEmpty": {
      "name": "help.userInfoEmpty",
      "description": [
        "Internal use"
      ]
    },
    "highScore": {
      "name": "highScore",
      "description": [
        "Game highscore"
      ],
      "fields": {
        "pos": "Position in highscore list",
        "score": "Score",
        "user_id": "User ID"
      }
    },
    "importedContact": {
      "name": "importedContact",
      "description": [
        "Successfully imported contact."
      ],
      "fields": {
        "client_id": "The contact's client identifier (passed to one of the InputContact constructors)",
        "user_id": "User identifier"
      }
    },
    "inlineBotSwitchPM": {
      "name": "inlineBotSwitchPM",
      "description": [
        "The bot requested the user to message him in private"
      ],
      "fields": {
        "start_param": "The parameter for the /start parameter",
        "text": "Text for the button that switches the user to a private chat with the bot and sends the bot a start message with the parameter start_parameter (can be empty)"
      }
    },
    "inputAppEvent": {
      "name": "inputAppEvent",
      "description": [
        "Event that occured in the application."
      ],
      "fields": {
        "data": "Details of the event",
        "peer": "Arbitrary numeric value for more convenient selection of certain event types, or events referring to a certain object",
        "time": "Client's exact timestamp for the event",
        "type": "Type of event"
      }
    },
    "inputBotInlineMessageGame": {
      "name": "inputBotInlineMessageGame",
      "description": [
        "A game"
      ],
      "fields": {
        "flags": "Flags, see TL conditional fields",
        "reply_markup": "Inline keyboard"
      }
    },
    "inputBotInlineMessageID": {
      "name": "inputBotInlineMessageID",
      "description": [
        "Represents a sent inline message from the perspective of a bot"
      ],
      "fields": {
        "access_hash": "Access hash of message",
        "dc_id": "DC ID to use when working with this inline message",
        "id": "ID of message"
      }
    },
    "inputBotInlineMessageMediaAuto": {
      "name": "inputBotInlineMessageMediaAuto",
      "description": [
        "A media"
      ],
      "fields": {
        "entities": "Message entities for styled text",
        "flags": "Flags, see TL conditional fields",
        "message": "Caption",
        "reply_markup": "Inline keyboard"
      }
    },
    "inputBotInlineMessageMediaContact": {
      "name": "inputBotInlineMessageMediaContact",
      "description": [
        "A contact"
      ],
      "fields": {
        "first_name": "First name",
        "flags": "Flags, see TL conditional fields",
        "last_name": "Last name",
        "phone_number": "Phone number",
        "reply_markup": "Inline keyboard",
        "vcard": "VCard info"
      }
    },
    "inputBotInlineMessageMediaGeo": {
      "name": "inputBotInlineMessageMediaGeo",
      "description": [
        "Geolocation"
      ],
      "fields": {
        "flags": "Flags, see TL conditional fields",
        "geo_point": "Geolocation",
        "heading": "For live locations, a direction in which the location moves, in degrees; 1-360",
        "period": "Validity period",
        "proximity_notification_radius": "For live locations, a maximum distance to another chat member for proximity alerts, in meters (0-100000)",
        "reply_markup": "Reply markup for bot/inline keyboards"
      }
    },
    "inputBotInlineMessageMediaVenue": {
      "name": "inputBotInlineMessageMediaVenue",
      "description": [
        "Venue"
      ],
      "fields": {
        "address": "Address",
        "flags": "Flags, see TL conditional fields",
        "geo_point": "Geolocation",
        "provider": "Venue provider: currently only \"foursquare\" needs to be supported",
        "reply_markup": "Inline keyboard",
        "title": "Venue name",
        "venue_id": "Venue ID in the provider's database",
        "venue_type": "Venue type in the provider's database"
      }
    },
    "inputBotInlineMessageText": {
      "name": "inputBotInlineMessageText",
      "description": [
        "Simple text message"
      ],
      "fields": {
        "entities": "Message entities for styled text",
        "flags": "Flags, see TL conditional fields",
        "message": "Message",
        "no_webpage": "Disable webpage preview",
        "reply_markup": "Inline keyboard"
      }
    },
    "inputBotInlineResult": {
      "name": "inputBotInlineResult",
      "description": [
        "An inline bot result"
      ],
      "fields": {
        "content": "Result contents",
        "description": "Result description",
        "flags": "Flags, see TL conditional fields",
        "id": "ID of result",
        "send_message": "Message to send when the result is selected",
        "thumb": "Thumbnail for result",
        "title": "Result title",
        "type": "Result type (see bot API docs)",
        "url": "URL of result"
      }
    },
    "inputBotInlineResultDocument": {
      "name": "inputBotInlineResultDocument",
      "description": [
        "Document (media of any type except for photos)"
      ],
      "fields": {
        "description": "Result description",
        "document": "Document to send",
        "flags": "Flags, see TL conditional fields",
        "id": "Result ID",
        "send_message": "Message to send when the result is selected",
        "title": "Result title",
        "type": "Result type (see bot API docs)"
      }
    },
    "inputBotInlineResultGame": {
      "name": "inputBotInlineResultGame",
      "description": [
        "Game"
      ],
      "fields": {
        "id": "Result ID",
        "send_message": "Message to send when the result is selected",
        "short_name": "Game short name"
      }
    },
    "inputBotInlineResultPhoto": {
      "name": "inputBotInlineResultPhoto",
      "description": [
        "Photo"
      ],
      "fields": {
        "id": "Result ID",
        "photo": "Photo to send",
        "send_message": "Message to send when the result is selected",
        "type": "Result type (see bot API docs)"
      }
    },
    "inputChannel": {
      "name": "inputChannel",
      "description": [
        "Represents a channel"
      ],
      "fields": {
        "access_hash": "Access hash taken from the channel constructor",
        "channel_id": "Channel ID"
      }
    },
    "inputChannelEmpty": {
      "name": "inputChannelEmpty",
      "description": [
        "Represents the absence of a channel"
      ]
    },
    "inputChannelFromMessage": {
      "name": "inputChannelFromMessage",
      "description": [
        "Defines a min channel that was seen in a certain message of a certain chat."
      ],
      "fields": {
        "channel_id": "The channel ID",
        "msg_id": "The message ID in the chat where the channel was seen",
        "peer": "The chat where the channel was seen"
      }
    },
    "inputChatPhoto": {
      "name": "inputChatPhoto",
      "description": [
        "Existing photo to be set as a chat profile photo."
      ],
      "fields": {
        "id": "Existing photo"
      }
    },
    "inputChatPhotoEmpty": {
      "name": "inputChatPhotoEmpty",
      "description": [
        "Empty constructor, remove group photo."
      ]
    },
    "inputChatUploadedPhoto": {
      "name": "inputChatUploadedPhoto",
      "description": [
        "New photo to be set as group profile photo."
      ],
      "fields": {
        "file": "File saved in parts using the method upload.saveFilePart",
        "flags": "Flags, see TL conditional fields",
        "video": "Square video for animated profile picture",
        "video_start_ts": "Timestamp that should be shown as static preview to the user (seconds)"
      }
    },
    "inputCheckPasswordEmpty": {
      "name": "inputCheckPasswordEmpty",
      "description": [
        "There is no password"
      ]
    },
    "inputCheckPasswordSRP": {
      "name": "inputCheckPasswordSRP",
      "description": [
        "Constructor for checking the validity of a 2FA SRP password (see SRP)"
      ],
      "fields": {
        "A": "A parameter (see SRP)",
        "M1": "M1 parameter (see SRP)",
        "srp_id": "SRP ID"
      }
    },
    "inputClientProxy": {
      "name": "inputClientProxy",
      "description": [
        "Info about an MTProxy used to connect."
      ],
      "fields": {
        "address": "Proxy address",
        "port": "Proxy port"
      }
    },
    "inputDialogPeer": {
      "name": "inputDialogPeer",
      "description": [
        "A peer"
      ],
      "fields": {
        "peer": "Peer"
      }
    },
    "inputDialogPeerFolder": {
      "name": "inputDialogPeerFolder",
      "description": [
        "All peers in a peer folder"
      ],
      "fields": {
        "folder_id": "Peer folder ID, for more info click here"
      }
    },
    "inputDocument": {
      "name": "inputDocument",
      "description": [
        "Defines a video for subsequent interaction."
      ],
      "fields": {
        "access_hash": "access_hash parameter from the document constructor",
        "file_reference": "File reference",
        "id": "Document ID"
      }
    },
    "inputDocumentEmpty": {
      "name": "inputDocumentEmpty",
      "description": [
        "Empty constructor."
      ]
    },
    "inputDocumentFileLocation": {
      "name": "inputDocumentFileLocation",
      "description": [
        "Document location (video, voice, audio, basically every type except photo)"
      ],
      "fields": {
        "access_hash": "access_hash parameter from the document constructor",
        "file_reference": "File reference",
        "id": "Document ID",
        "thumb_size": "Thumbnail size to download the thumbnail"
      }
    },
    "inputEncryptedChat": {
      "name": "inputEncryptedChat",
      "description": [
        "Creates an encrypted chat."
      ],
      "fields": {
        "access_hash": "Checking sum from constructor encryptedChat, encryptedChatWaiting or encryptedChatRequested",
        "chat_id": "Chat ID"
      }
    },
    "inputEncryptedFile": {
      "name": "inputEncryptedFile",
      "description": [
        "Sets forwarded encrypted file for attachment."
      ],
      "fields": {
        "access_hash": "Checking sum, value of access_hash parameter from encryptedFile",
        "id": "File ID, value of id parameter from encryptedFile"
      }
    },
    "inputEncryptedFileBigUploaded": {
      "name": "inputEncryptedFileBigUploaded",
      "description": [
        "Assigns a new big encrypted file (over 10Mb in size), saved in parts using the method upload.saveBigFilePart."
      ],
      "fields": {
        "id": "Random file id, created by the client",
        "key_fingerprint": "32-bit imprint of the key used to encrypt the file",
        "parts": "Number of saved parts"
      }
    },
    "inputEncryptedFileEmpty": {
      "name": "inputEncryptedFileEmpty",
      "description": [
        "Empty constructor."
      ]
    },
    "inputEncryptedFileLocation": {
      "name": "inputEncryptedFileLocation",
      "description": [
        "Location of encrypted secret chat file."
      ],
      "fields": {
        "access_hash": "Checksum, access_hash parameter value from encryptedFile",
        "id": "File ID, id parameter value from encryptedFile"
      }
    },
    "inputEncryptedFileUploaded": {
      "name": "inputEncryptedFileUploaded",
      "description": [
        "Sets new encrypted file saved by parts using upload.saveFilePart method."
      ],
      "fields": {
        "id": "Random file ID created by clien",
        "key_fingerprint": "32-bit fingerprint of the key used to encrypt a file",
        "md5_checksum": "In case md5-HASH of the (already encrypted) file was transmitted, file content will be checked prior to use",
        "parts": "Number of saved parts"
      }
    },
    "inputFile": {
      "name": "inputFile",
      "description": [
        "Defines a file saved in parts using the method upload.saveFilePart."
      ],
      "fields": {
        "id": "Random file identifier created by the client",
        "md5_checksum": "In case the file's md5-hash was passed, contents of the file will be checked prior to use",
        "name": "Full name of the file",
        "parts": "Number of parts saved"
      }
    },
    "inputFileBig": {
      "name": "inputFileBig",
      "description": [
        "Assigns a big file (over 10Mb in size), saved in part using the method upload.saveBigFilePart."
      ],
      "fields": {
        "id": "Random file id, created by the client",
        "name": "Full file name",
        "parts": "Number of parts saved"
      }
    },
    "inputFileLocation": {
      "name": "inputFileLocation",
      "description": [
        "DEPRECATED location of a photo"
      ],
      "fields": {
        "file_reference": "File reference",
        "local_id": "File identifier",
        "secret": "Check sum to access the file",
        "volume_id": "Server volume"
      }
    },
    "inputFolderPeer": {
      "name": "inputFolderPeer",
      "description": [
        "Peer in a folder"
      ],
      "fields": {
        "folder_id": "Peer folder ID, for more info click here",
        "peer": "Peer"
      }
    },
    "inputGameID": {
      "name": "inputGameID",
      "description": [
        "Indicates an already sent game"
      ],
      "fields": {
        "access_hash": "access hash from Game constructor",
        "id": "game ID from Game constructor"
      }
    },
    "inputGameShortName": {
      "name": "inputGameShortName",
      "description": [
        "Game by short name"
      ],
      "fields": {
        "bot_id": "The bot that provides the game",
        "short_name": "The game's short name"
      }
    },
    "inputGeoPoint": {
      "name": "inputGeoPoint",
      "description": [
        "Defines a GeoPoint by its coordinates."
      ],
      "fields": {
        "accuracy_radius": "The estimated horizontal accuracy of the location, in meters; as defined by the sender.",
        "flags": "Flags, see TL conditional fields",
        "lat": "Latitide",
        "long": "Longtitude"
      }
    },
    "inputGeoPointEmpty": {
      "name": "inputGeoPointEmpty",
      "description": [
        "Empty GeoPoint constructor."
      ]
    },
    "inputKeyboardButtonUrlAuth": {
      "name": "inputKeyboardButtonUrlAuth",
      "description": [
        "Button to request a user to authorize via URL using Seamless Telegram Login."
      ],
      "fields": {
        "bot": "Username of a bot, which will be used for user authorization. See Setting up a bot for more details. If not specified, the current bot's username will be assumed. The url's domain must be the same as the domain linked with the bot. See Linking your domain to the bot for more details.",
        "flags": "Flags, see TL conditional fields",
        "fwd_text": "New text of the button in forwarded messages.",
        "request_write_access": "Set this flag to request the permission for your bot to send messages to the user.",
        "text": "Button text",
        "url": "An HTTP URL to be opened with user authorization data added to the query string when the button is pressed. If the user refuses to provide authorization data, the original URL without information about the user will be opened. The data added is the same as described in Receiving authorization data.NOTE: You must always check the hash of the received data to verify the authentication and the integrity of the data as described in Checking authorization."
      }
    },
    "inputMediaContact": {
      "name": "inputMediaContact",
      "description": [
        "Phonebook contact"
      ],
      "fields": {
        "first_name": "Contact's first name",
        "last_name": "Contact's last name",
        "phone_number": "Phone number",
        "vcard": "Contact vcard"
      }
    },
    "inputMediaDice": {
      "name": "inputMediaDice",
      "description": [
        "Send a dice-based animated sticker"
      ],
      "fields": {
        "emoticon": "The emoji, for now ,  and  are supported"
      }
    },
    "inputMediaDocument": {
      "name": "inputMediaDocument",
      "description": [
        "Forwarded document"
      ],
      "fields": {
        "flags": "Flags, see TL conditional fields",
        "id": "The document to be forwarded.",
        "ttl_seconds": "Time to live of self-destructing document"
      }
    },
    "inputMediaDocumentExternal": {
      "name": "inputMediaDocumentExternal",
      "description": [
        "Document that will be downloaded by the telegram servers"
      ],
      "fields": {
        "flags": "Flags, see TL conditional fields",
        "ttl_seconds": "Self-destruct time to live of document",
        "url": "URL of the document"
      }
    },
    "inputMediaEmpty": {
      "name": "inputMediaEmpty",
      "description": [
        "Empty media content of a message."
      ]
    },
    "inputMediaGame": {
      "name": "inputMediaGame",
      "description": [
        "A game"
      ],
      "fields": {
        "id": "The game to forward"
      }
    },
    "inputMediaGeoLive": {
      "name": "inputMediaGeoLive",
      "description": [
        "Live geolocation"
      ],
      "fields": {
        "flags": "Flags, see TL conditional fields",
        "geo_point": "Current geolocation",
        "heading": "For live locations, a direction in which the location moves, in degrees; 1-360.",
        "period": "Validity period of the current location",
        "proximity_notification_radius": "For live locations, a maximum distance to another chat member for proximity alerts, in meters (0-100000)",
        "stopped": "Whether sending of the geolocation was stopped"
      }
    },
    "inputMediaGeoPoint": {
      "name": "inputMediaGeoPoint",
      "description": [
        "Map."
      ],
      "fields": {
        "geo_point": "GeoPoint"
      }
    },
    "inputMediaInvoice": {
      "name": "inputMediaInvoice",
      "description": [
        "Generated invoice of a bot payment"
      ],
      "fields": {
        "description": "Product description, 1-255 characters",
        "flags": "Flags, see TL conditional fields",
        "invoice": "The actual invoice",
        "payload": "Bot-defined invoice payload, 1-128 bytes. This will not be displayed to the user, use for your internal processes.",
        "photo": "URL of the product photo for the invoice. Can be a photo of the goods or a marketing image for a service. People like it better when they see what they are paying for.",
        "provider": "Payments provider token, obtained via Botfather",
        "provider_data": "JSON-encoded data about the invoice, which will be shared with the payment provider. A detailed description of required fields should be provided by the payment provider.",
        "start_param": "Start parameter",
        "title": "Product name, 1-32 characters"
      }
    },
    "inputMediaPhoto": {
      "name": "inputMediaPhoto",
      "description": [
        "Forwarded photo"
      ],
      "fields": {
        "flags": "Flags, see TL conditional fields",
        "id": "Photo to be forwarded",
        "ttl_seconds": "Time to live in seconds of self-destructing photo"
      }
    },
    "inputMediaPhotoExternal": {
      "name": "inputMediaPhotoExternal",
      "description": [
        "New photo that will be uploaded by the server using the specified URL"
      ],
      "fields": {
        "flags": "Flags, see TL conditional fields",
        "ttl_seconds": "Self-destruct time to live of photo",
        "url": "URL of the photo"
      }
    },
    "inputMediaPoll": {
      "name": "inputMediaPoll",
      "description": [
        "A poll"
      ],
      "fields": {
        "correct_answers": "Correct answer IDs (for quiz polls)",
        "flags": "Flags, see TL conditional fields",
        "poll": "The poll to send",
        "solution": "Explanation of quiz solution",
        "solution_entities": "Message entities for styled text"
      }
    },
    "inputMediaUploadedDocument": {
      "name": "inputMediaUploadedDocument",
      "description": [
        "New document"
      ],
      "fields": {
        "attributes": "Attributes that specify the type of the document (video, audio, voice, sticker, etc.)",
        "file": "The uploaded file",
        "flags": "Flags, see TL conditional fields",
        "force_file": "Force the media file to be uploaded as document",
        "mime_type": "MIME type of document",
        "nosound_video": "Whether the specified document is a video file with no audio tracks (a GIF animation (even as MPEG4), for example)",
        "stickers": "Attached stickers",
        "thumb": "Thumbnail of the document, uploaded as for the file",
        "ttl_seconds": "Time to live in seconds of self-destructing document"
      }
    },
    "inputMediaUploadedPhoto": {
      "name": "inputMediaUploadedPhoto",
      "description": [
        "Photo"
      ],
      "fields": {
        "file": "The uploaded file",
        "flags": "Flags, see TL conditional fields",
        "stickers": "Attached mask stickers",
        "ttl_seconds": "Time to live in seconds of self-destructing photo"
      }
    },
    "inputMediaVenue": {
      "name": "inputMediaVenue",
      "description": [
        "Can be used to send a venue geolocation."
      ],
      "fields": {
        "address": "Physical address of the venue",
        "geo_point": "Geolocation",
        "provider": "Venue provider: currently only \"foursquare\" needs to be supported",
        "title": "Venue name",
        "venue_id": "Venue ID in the provider's database",
        "venue_type": "Venue type in the provider's database"
      }
    },
    "inputMessageCallbackQuery": {
      "name": "inputMessageCallbackQuery",
      "description": [
        "Used by bots for fetching information about the message that originated a callback query"
      ],
      "fields": {
        "id": "Message ID",
        "query_id": "Callback query ID"
      }
    },
    "inputMessageEntityMentionName": {
      "name": "inputMessageEntityMentionName",
      "description": [
        "Message entity that can be used to create a user user mention: received mentions use the messageEntityMentionName constructor, instead."
      ],
      "fields": {
        "length": "Length of message entity within message (in UTF-8 codepoints)",
        "offset": "Offset of message entity within message (in UTF-8 codepoints)",
        "user_id": "Identifier of the user that was mentioned"
      }
    },
    "inputMessageID": {
      "name": "inputMessageID",
      "description": [
        "Message by ID"
      ],
      "fields": {
        "id": "Message ID"
      }
    },
    "inputMessagePinned": {
      "name": "inputMessagePinned",
      "description": [
        "Pinned message"
      ]
    },
    "inputMessageReplyTo": {
      "name": "inputMessageReplyTo",
      "description": [
        "Message to which the specified message replies to"
      ],
      "fields": {
        "id": "ID of the message that replies to the message we need"
      }
    },
    "inputMessagesFilterChatPhotos": {
      "name": "inputMessagesFilterChatPhotos",
      "description": [
        "Return only chat photo changes"
      ]
    },
    "inputMessagesFilterContacts": {
      "name": "inputMessagesFilterContacts",
      "description": [
        "Return only messages containing contacts"
      ]
    },
    "inputMessagesFilterDocument": {
      "name": "inputMessagesFilterDocument",
      "description": [
        "Filter for messages containing documents."
      ]
    },
    "inputMessagesFilterEmpty": {
      "name": "inputMessagesFilterEmpty",
      "description": [
        "Filter is absent."
      ]
    },
    "inputMessagesFilterGeo": {
      "name": "inputMessagesFilterGeo",
      "description": [
        "Return only messages containing geolocations"
      ]
    },
    "inputMessagesFilterGif": {
      "name": "inputMessagesFilterGif",
      "description": [
        "Return only messages containing gifs"
      ]
    },
    "inputMessagesFilterMusic": {
      "name": "inputMessagesFilterMusic",
      "description": [
        "Return only messages containing audio files"
      ]
    },
    "inputMessagesFilterMyMentions": {
      "name": "inputMessagesFilterMyMentions",
      "description": [
        "Return only messages where the current user was mentioned."
      ]
    },
    "inputMessagesFilterPhoneCalls": {
      "name": "inputMessagesFilterPhoneCalls",
      "description": [
        "Return only phone calls"
      ],
      "fields": {
        "flags": "Flags, see TL conditional fields",
        "missed": "Return only missed phone calls"
      }
    },
    "inputMessagesFilterPhotoVideo": {
      "name": "inputMessagesFilterPhotoVideo",
      "description": [
        "Filter for messages containing photos or videos."
      ]
    },
    "inputMessagesFilterPhotos": {
      "name": "inputMessagesFilterPhotos",
      "description": [
        "Filter for messages containing photos."
      ]
    },
    "inputMessagesFilterPinned": {
      "name": "inputMessagesFilterPinned",
      "description": [
        "Fetch only pinned messages"
      ]
    },
    "inputMessagesFilterRoundVideo": {
      "name": "inputMessagesFilterRoundVideo",
      "description": [
        "Return only round videos"
      ]
    },
    "inputMessagesFilterRoundVoice": {
      "name": "inputMessagesFilterRoundVoice",
      "description": [
        "Return only round videos and voice notes"
      ]
    },
    "inputMessagesFilterUrl": {
      "name": "inputMessagesFilterUrl",
      "description": [
        "Return only messages containing URLs"
      ]
    },
    "inputMessagesFilterVideo": {
      "name": "inputMessagesFilterVideo",
      "description": [
        "Filter for messages containing videos."
      ]
    },
    "inputMessagesFilterVoice": {
      "name": "inputMessagesFilterVoice",
      "description": [
        "Return only messages containing voice notes"
      ]
    },
    "inputNotifyBroadcasts": {
      "name": "inputNotifyBroadcasts",
      "description": [
        "All channels"
      ]
    },
    "inputNotifyChats": {
      "name": "inputNotifyChats",
      "description": [
        "Notifications generated by all groups."
      ]
    },
    "inputNotifyPeer": {
      "name": "inputNotifyPeer",
      "description": [
        "Notifications generated by a certain user or group."
      ],
      "fields": {
        "peer": "User or group"
      }
    },
    "inputNotifyUsers": {
      "name": "inputNotifyUsers",
      "description": [
        "Notifications generated by all users."
      ]
    },
    "inputPaymentCredentials": {
      "name": "inputPaymentCredentials",
      "description": [
        "Payment credentials"
      ],
      "fields": {
        "data": "Payment credentials",
        "flags": "Flags, see TL conditional fields",
        "save": "Save payment credential for future use"
      }
    },
    "inputPaymentCredentialsAndroidPay": {
      "name": "inputPaymentCredentialsAndroidPay",
      "description": [
        "Android pay payment credentials"
      ],
      "fields": {
        "google_transaction_id": "Google transaction ID",
        "payment_token": "Android pay payment token"
      }
    },
    "inputPaymentCredentialsApplePay": {
      "name": "inputPaymentCredentialsApplePay",
      "description": [
        "Apple pay payment credentials"
      ],
      "fields": {
        "payment_data": "Payment data"
      }
    },
    "inputPaymentCredentialsSaved": {
      "name": "inputPaymentCredentialsSaved",
      "description": [
        "Saved payment credentials"
      ],
      "fields": {
        "id": "Credential ID",
        "tmp_password": "Temporary password"
      }
    },
    "inputPeerChannel": {
      "name": "inputPeerChannel",
      "description": [
        "Defines a channel for further interaction."
      ],
      "fields": {
        "access_hash": "access_hash value from the channel constructor",
        "channel_id": "Channel identifier"
      }
    },
    "inputPeerChannelFromMessage": {
      "name": "inputPeerChannelFromMessage",
      "description": [
        "Defines a min channel that was seen in a certain message of a certain chat."
      ],
      "fields": {
        "channel_id": "The identifier of the channel that was seen",
        "msg_id": "The message ID",
        "peer": "The chat where the channel's message was seen"
      }
    },
    "inputPeerChat": {
      "name": "inputPeerChat",
      "description": [
        "Defines a chat for further interaction."
      ],
      "fields": {
        "chat_id": "Chat idientifier"
      }
    },
    "inputPeerEmpty": {
      "name": "inputPeerEmpty",
      "description": [
        "An empty constructor, no user or chat is defined."
      ]
    },
    "inputPeerNotifySettings": {
      "name": "inputPeerNotifySettings",
      "description": [
        "Notification settings."
      ],
      "fields": {
        "flags": "Flags, see TL conditional fields",
        "mute_until": "Date until which all notifications shall be switched off",
        "show_previews": "If the text of the message shall be displayed in notification",
        "silent": "Peer was muted?",
        "sound": "Name of an audio file for notification"
      }
    },
    "inputPeerPhotoFileLocation": {
      "name": "inputPeerPhotoFileLocation",
      "description": [
        "Location of profile photo of channel/group/supergroup/user"
      ],
      "fields": {
        "big": "Whether to download the high-quality version of the picture",
        "flags": "Flags, see TL conditional fields",
        "local_id": "Local ID from FileLocation met in the profile photo container.",
        "peer": "The peer whose profile picture should be downloaded",
        "volume_id": "Volume ID from FileLocation met in the profile photo container."
      }
    },
    "inputPeerSelf": {
      "name": "inputPeerSelf",
      "description": [
        "Defines the current user."
      ]
    },
    "inputPeerUser": {
      "name": "inputPeerUser",
      "description": [
        "Defines a user for further interaction."
      ],
      "fields": {
        "access_hash": "access_hash value from the user constructor",
        "user_id": "User identifier"
      }
    },
    "inputPeerUserFromMessage": {
      "name": "inputPeerUserFromMessage",
      "description": [
        "Defines a min user that was seen in a certain message of a certain chat."
      ],
      "fields": {
        "msg_id": "The message ID",
        "peer": "The chat where the user was seen",
        "user_id": "The identifier of the user that was seen"
      }
    },
    "inputPhoneCall": {
      "name": "inputPhoneCall",
      "description": [
        "Phone call"
      ],
      "fields": {
        "access_hash": "Access hash",
        "id": "Call ID"
      }
    },
    "inputPhoneContact": {
      "name": "inputPhoneContact",
      "description": [
        "Phone contact. The client_id is just an arbitrary contact ID: it should be set, for example, to an incremental number when using contacts.importContacts, in order to retry importing only the contacts that weren't imported successfully."
      ],
      "fields": {
        "client_id": "User identifier on the client",
        "first_name": "Contact's first name",
        "last_name": "Contact's last name",
        "phone": "Phone number"
      }
    },
    "inputPhoto": {
      "name": "inputPhoto",
      "description": [
        "Defines a photo for further interaction."
      ],
      "fields": {
        "access_hash": "access_hash value from the photo constructor",
        "file_reference": "File reference",
        "id": "Photo identifier"
      }
    },
    "inputPhotoEmpty": {
      "name": "inputPhotoEmpty",
      "description": [
        "Empty constructor."
      ]
    },
    "inputPhotoFileLocation": {
      "name": "inputPhotoFileLocation",
      "description": [
        "Use this object to download a photo with upload.getFile method"
      ],
      "fields": {
        "access_hash": "Photo's access hash, obtained from the photo object",
        "file_reference": "File reference",
        "id": "Photo ID, obtained from the photo object",
        "thumb_size": "The PhotoSize to download: must be set to the type field of the desired PhotoSize object of the photo"
      }
    },
    "inputPhotoLegacyFileLocation": {
      "name": "inputPhotoLegacyFileLocation",
      "description": [
        "Legacy photo file location"
      ],
      "fields": {
        "access_hash": "Access hash",
        "file_reference": "File reference",
        "id": "Photo ID",
        "local_id": "Local ID",
        "secret": "Secret",
        "volume_id": "Volume ID"
      }
    },
    "inputPrivacyKeyAddedByPhone": {
      "name": "inputPrivacyKeyAddedByPhone",
      "description": [
        "Whether people can add you to their contact list by your phone number"
      ]
    },
    "inputPrivacyKeyChatInvite": {
      "name": "inputPrivacyKeyChatInvite",
      "description": [
        "Whether the user can be invited to chats"
      ]
    },
    "inputPrivacyKeyForwards": {
      "name": "inputPrivacyKeyForwards",
      "description": [
        "Whether messages forwarded from this user will be anonymous"
      ]
    },
    "inputPrivacyKeyPhoneCall": {
      "name": "inputPrivacyKeyPhoneCall",
      "description": [
        "Whether the user will accept phone calls"
      ]
    },
    "inputPrivacyKeyPhoneNumber": {
      "name": "inputPrivacyKeyPhoneNumber",
      "description": [
        "Whether people will be able to see the user's phone number"
      ]
    },
    "inputPrivacyKeyPhoneP2P": {
      "name": "inputPrivacyKeyPhoneP2P",
      "description": [
        "Whether the user allows P2P communication during VoIP calls"
      ]
    },
    "inputPrivacyKeyProfilePhoto": {
      "name": "inputPrivacyKeyProfilePhoto",
      "description": [
        "Whether people will be able to see the user's profile picture"
      ]
    },
    "inputPrivacyKeyStatusTimestamp": {
      "name": "inputPrivacyKeyStatusTimestamp",
      "description": [
        "Whether we can see the exact last online timestamp of the user"
      ]
    },
    "inputPrivacyValueAllowAll": {
      "name": "inputPrivacyValueAllowAll",
      "description": [
        "Allow all users"
      ]
    },
    "inputPrivacyValueAllowChatParticipants": {
      "name": "inputPrivacyValueAllowChatParticipants",
      "description": [
        "Allow only participants of certain chats"
      ],
      "fields": {
        "chats": "Allowed chat IDs"
      }
    },
    "inputPrivacyValueAllowContacts": {
      "name": "inputPrivacyValueAllowContacts",
      "description": [
        "Allow only contacts"
      ]
    },
    "inputPrivacyValueAllowUsers": {
      "name": "inputPrivacyValueAllowUsers",
      "description": [
        "Allow only certain users"
      ],
      "fields": {
        "users": "Allowed users"
      }
    },
    "inputPrivacyValueDisallowAll": {
      "name": "inputPrivacyValueDisallowAll",
      "description": [
        "Disallow all"
      ]
    },
    "inputPrivacyValueDisallowChatParticipants": {
      "name": "inputPrivacyValueDisallowChatParticipants",
      "description": [
        "Disallow only participants of certain chats"
      ],
      "fields": {
        "chats": "Disallowed chat IDs"
      }
    },
    "inputPrivacyValueDisallowContacts": {
      "name": "inputPrivacyValueDisallowContacts",
      "description": [
        "Disallow only contacts"
      ]
    },
    "inputPrivacyValueDisallowUsers": {
      "name": "inputPrivacyValueDisallowUsers",
      "description": [
        "Disallow only certain users"
      ],
      "fields": {
        "users": "Users to disallow"
      }
    },
    "inputReportReasonChildAbuse": {
      "name": "inputReportReasonChildAbuse",
      "description": [
        "Report for child abuse"
      ]
    },
    "inputReportReasonCopyright": {
      "name": "inputReportReasonCopyright",
      "description": [
        "Report for copyrighted content"
      ]
    },
    "inputReportReasonGeoIrrelevant": {
      "name": "inputReportReasonGeoIrrelevant",
      "description": [
        "Report an irrelevant geogroup"
      ]
    },
    "inputReportReasonOther": {
      "name": "inputReportReasonOther",
      "description": [
        "Other"
      ],
      "fields": {
        "text": "Other report reason"
      }
    },
    "inputReportReasonPornography": {
      "name": "inputReportReasonPornography",
      "description": [
        "Report for pornography"
      ]
    },
    "inputReportReasonSpam": {
      "name": "inputReportReasonSpam",
      "description": [
        "Report for spam"
      ]
    },
    "inputReportReasonViolence": {
      "name": "inputReportReasonViolence",
      "description": [
        "Report for violence"
      ]
    },
    "inputSecureFile": {
      "name": "inputSecureFile",
      "description": [
        "Preuploaded passport file, for more info see the passport docs "
      ],
      "fields": {
        "access_hash": "Secure file access hash",
        "id": "Secure file ID"
      }
    },
    "inputSecureFileLocation": {
      "name": "inputSecureFileLocation",
      "description": [
        "Location of encrypted telegram passport file."
      ],
      "fields": {
        "access_hash": "Checksum, access_hash parameter value from secureFile",
        "id": "File ID, id parameter value from secureFile"
      }
    },
    "inputSecureFileUploaded": {
      "name": "inputSecureFileUploaded",
      "description": [
        "Uploaded secure file, for more info see the passport docs "
      ],
      "fields": {
        "file_hash": "File hash",
        "id": "Secure file ID",
        "md5_checksum": "MD5 hash of encrypted uploaded file, to be checked server-side",
        "parts": "Secure file part count",
        "secret": "Secret"
      }
    },
    "inputSecureValue": {
      "name": "inputSecureValue",
      "description": [
        "Secure value, for more info see the passport docs "
      ],
      "fields": {
        "data": "Encrypted Telegram Passport element data",
        "files": "Array of encrypted passport files with photos the of the documents",
        "flags": "Flags, see TL conditional fields",
        "front_side": "Encrypted passport file with the front side of the document",
        "plain_data": "Plaintext verified passport data",
        "reverse_side": "Encrypted passport file with the reverse side of the document",
        "selfie": "Encrypted passport file with a selfie of the user holding the document",
        "translation": "Array of encrypted passport files with translated versions of the provided documents",
        "type": "Secure passport value type"
      }
    },
    "inputSingleMedia": {
      "name": "inputSingleMedia",
      "description": [
        "A single media in an album or grouped media sent with messages.sendMultiMedia."
      ],
      "fields": {
        "entities": "Message entities for styled text",
        "flags": "Flags, see TL conditional fields",
        "media": "The media",
        "message": "A caption for the media",
        "random_id": "Unique client media ID required to prevent message resending"
      }
    },
    "inputStickerSetAnimatedEmoji": {
      "name": "inputStickerSetAnimatedEmoji",
      "description": [
        "Animated emojis stickerset"
      ]
    },
    "inputStickerSetDice": {
      "name": "inputStickerSetDice",
      "description": [
        "Used for fetching animated dice stickers"
      ],
      "fields": {
        "emoticon": "The emoji, for now ,  and  are supported"
      }
    },
    "inputStickerSetEmpty": {
      "name": "inputStickerSetEmpty",
      "description": [
        "Empty constructor"
      ]
    },
    "inputStickerSetID": {
      "name": "inputStickerSetID",
      "description": [
        "Stickerset by ID"
      ],
      "fields": {
        "access_hash": "Access hash",
        "id": "ID"
      }
    },
    "inputStickerSetItem": {
      "name": "inputStickerSetItem",
      "description": [
        "Sticker in a stickerset"
      ],
      "fields": {
        "document": "The sticker",
        "emoji": "Associated emoji",
        "flags": "Flags, see TL conditional fields",
        "mask_coords": "Coordinates for mask sticker"
      }
    },
    "inputStickerSetShortName": {
      "name": "inputStickerSetShortName",
      "description": [
        "Stickerset by short name, from tg://addstickers?set=short_name"
      ],
      "fields": {
        "short_name": "From tg://addstickers?set=short_name"
      }
    },
    "inputStickerSetThumb": {
      "name": "inputStickerSetThumb",
      "description": [
        "Location of stickerset thumbnail (see files)"
      ],
      "fields": {
        "local_id": "Local ID",
        "stickerset": "Sticker set",
        "volume_id": "Volume ID"
      }
    },
    "inputStickeredMediaDocument": {
      "name": "inputStickeredMediaDocument",
      "description": [
        "A document with stickers attached"
      ],
      "fields": {
        "id": "The document"
      }
    },
    "inputStickeredMediaPhoto": {
      "name": "inputStickeredMediaPhoto",
      "description": [
        "A photo with stickers attached"
      ],
      "fields": {
        "id": "The photo"
      }
    },
    "inputTakeoutFileLocation": {
      "name": "inputTakeoutFileLocation",
      "description": [
        "Empty constructor for takeout"
      ]
    },
    "inputTheme": {
      "name": "inputTheme",
      "description": [
        "Theme"
      ],
      "fields": {
        "access_hash": "Access hash",
        "id": "ID"
      }
    },
    "inputThemeSettings": {
      "name": "inputThemeSettings",
      "description": [
        "Theme settings"
      ],
      "fields": {
        "accent_color": "Accent color, RGB24 format",
        "base_theme": "Default theme on which this theme is based",
        "flags": "Flags, see TL conditional fields",
        "message_bottom_color": "Message gradient color (bottom), RGB24 format",
        "message_top_color": "Message gradient color (top), RGB24 format",
        "wallpaper": "Wallpaper",
        "wallpaper_settings": "Wallpaper settings"
      }
    },
    "inputThemeSlug": {
      "name": "inputThemeSlug",
      "description": [
        "Theme by theme ID"
      ],
      "fields": {
        "slug": "Unique theme ID"
      }
    },
    "inputUser": {
      "name": "inputUser",
      "description": [
        "Defines a user for further interaction."
      ],
      "fields": {
        "access_hash": "access_hash value from the user constructor",
        "user_id": "User identifier"
      }
    },
    "inputUserEmpty": {
      "name": "inputUserEmpty",
      "description": [
        "Empty constructor, does not define a user."
      ]
    },
    "inputUserFromMessage": {
      "name": "inputUserFromMessage",
      "description": [
        "Defines a min user that was seen in a certain message of a certain chat."
      ],
      "fields": {
        "msg_id": "The message ID",
        "peer": "The chat where the user was seen",
        "user_id": "The identifier of the user that was seen"
      }
    },
    "inputUserSelf": {
      "name": "inputUserSelf",
      "description": [
        "Defines the current user."
      ]
    },
    "inputWallPaper": {
      "name": "inputWallPaper",
      "description": [
        "Wallpaper"
      ],
      "fields": {
        "access_hash": "Access hash",
        "id": "Wallpaper ID"
      }
    },
    "inputWallPaperNoFile": {
      "name": "inputWallPaperNoFile",
      "description": [
        "Wallpaper with no file"
      ]
    },
    "inputWallPaperSlug": {
      "name": "inputWallPaperSlug",
      "description": [
        "Wallpaper by slug (a unique ID)"
      ],
      "fields": {
        "slug": "Unique wallpaper ID"
      }
    },
    "inputWebDocument": {
      "name": "inputWebDocument",
      "description": [
        "The document"
      ],
      "fields": {
        "attributes": "Attributes for media types",
        "mime_type": "Mime type",
        "size": "Remote file size",
        "url": "Remote document URL to be downloaded using the appropriate method"
      }
    },
    "inputWebFileGeoPointLocation": {
      "name": "inputWebFileGeoPointLocation",
      "description": [
        "Geolocation"
      ],
      "fields": {
        "access_hash": "Access hash",
        "geo_point": "Geolocation",
        "h": "Map height in pixels before applying scale; 16-1024",
        "scale": "Map scale; 1-3",
        "w": "Map width in pixels before applying scale; 16-1024",
        "zoom": "Map zoom level; 13-20"
      }
    },
    "inputWebFileLocation": {
      "name": "inputWebFileLocation",
      "description": [
        "Location of a remote HTTP(s) file"
      ],
      "fields": {
        "access_hash": "Access hash",
        "url": "HTTP URL of file"
      }
    },
    "invoice": {
      "name": "invoice",
      "description": [
        "Invoice"
      ],
      "fields": {
        "currency": "Three-letter ISO 4217 currency code",
        "email_requested": "Set this flag if you require the user's email address to complete the order",
        "email_to_provider": "Set this flag if user's email address should be sent to provider",
        "flags": "Flags, see TL conditional fields",
        "flexible": "Set this flag if the final price depends on the shipping method",
        "name_requested": "Set this flag if you require the user's full name to complete the order",
        "phone_requested": "Set this flag if you require the user's phone number to complete the order",
        "phone_to_provider": "Set this flag if user's phone number should be sent to provider",
        "prices": "Price breakdown, a list of components (e.g. product price, tax, discount, delivery cost, delivery tax, bonus, etc.)",
        "shipping_address_requested": "Set this flag if you require the user's shipping address to complete the order",
        "test": "Test invoice"
      }
    },
    "jsonArray": {
      "name": "jsonArray",
      "description": [
        "JSON array"
      ],
      "fields": {
        "value": "JSON values"
      }
    },
    "jsonBool": {
      "name": "jsonBool",
      "description": [
        "JSON boolean value"
      ],
      "fields": {
        "value": "Value"
      }
    },
    "jsonNull": {
      "name": "jsonNull",
      "description": [
        "null JSON value"
      ]
    },
    "jsonNumber": {
      "name": "jsonNumber",
      "description": [
        "JSON numeric value"
      ],
      "fields": {
        "value": "Value"
      }
    },
    "jsonObject": {
      "name": "jsonObject",
      "description": [
        "JSON object value"
      ],
      "fields": {
        "value": "Values"
      }
    },
    "jsonObjectValue": {
      "name": "jsonObjectValue",
      "description": [
        "JSON key: value pair"
      ],
      "fields": {
        "key": "Key",
        "value": "Value"
      }
    },
    "jsonString": {
      "name": "jsonString",
      "description": [
        "JSON string"
      ],
      "fields": {
        "value": "Value"
      }
    },
    "keyboardButton": {
      "name": "keyboardButton",
      "description": [
        "Bot keyboard button"
      ],
      "fields": {
        "text": "Button text"
      }
    },
    "keyboardButtonBuy": {
      "name": "keyboardButtonBuy",
      "description": [
        "Button to buy a product"
      ],
      "fields": {
        "text": "Button text"
      }
    },
    "keyboardButtonCallback": {
      "name": "keyboardButtonCallback",
      "description": [
        "Callback button"
      ],
      "fields": {
        "data": "Callback data",
        "flags": "Flags, see TL conditional fields",
        "requires_password": "Whether the user should verify his identity by entering his 2FA SRP parameters to the messages.getBotCallbackAnswer method. NOTE: telegram and the bot WILL NOT have access to the plaintext password, thanks to SRP. This button is mainly used by the official @botfather bot, for verifying the user's identity before transferring ownership of a bot to another user.",
        "text": "Button text"
      }
    },
    "keyboardButtonGame": {
      "name": "keyboardButtonGame",
      "description": [
        "Button to start a game"
      ],
      "fields": {
        "text": "Button text"
      }
    },
    "keyboardButtonRequestGeoLocation": {
      "name": "keyboardButtonRequestGeoLocation",
      "description": [
        "Button to request a user's geolocation"
      ],
      "fields": {
        "text": "Button text"
      }
    },
    "keyboardButtonRequestPhone": {
      "name": "keyboardButtonRequestPhone",
      "description": [
        "Button to request a user's phone number"
      ],
      "fields": {
        "text": "Button text"
      }
    },
    "keyboardButtonRequestPoll": {
      "name": "keyboardButtonRequestPoll",
      "description": [
        "A button that allows the user to create and send a poll when pressed; available only in private"
      ],
      "fields": {
        "flags": "Flags, see TL conditional fields",
        "quiz": "If set, only quiz polls can be sent",
        "text": "Button text"
      }
    },
    "keyboardButtonRow": {
      "name": "keyboardButtonRow",
      "description": [
        "Inline keyboard row"
      ],
      "fields": {
        "buttons": "Bot or inline keyboard buttons"
      }
    },
    "keyboardButtonSwitchInline": {
      "name": "keyboardButtonSwitchInline",
      "description": [
        "Button to force a user to switch to inline mode Pressing the button will prompt the user to select one of their chats, open that chat and insert the bots username and the specified inline query in the input field."
      ],
      "fields": {
        "flags": "Flags, see TL conditional fields",
        "query": "The inline query to use",
        "same_peer": "If set, pressing the button will insert the bots username and the specified inline query in the current chat's input field.",
        "text": "Button label"
      }
    },
    "keyboardButtonUrl": {
      "name": "keyboardButtonUrl",
      "description": [
        "URL button"
      ],
      "fields": {
        "text": "Button label",
        "url": "URL"
      }
    },
    "keyboardButtonUrlAuth": {
      "name": "keyboardButtonUrlAuth",
      "description": [
        "Button to request a user to authorize via URL using Seamless Telegram Login. When the user clicks on such a button, messages.requestUrlAuth should be called, providing the button_id and the ID of the container message. The returned urlAuthResultRequest object will contain more details about the authorization request (request_write_access if the bot would like to send messages to the user along with the username of the bot which will be used for user authorization). Finally, the user can choose to call messages.acceptUrlAuth to get a urlAuthResultAccepted with the URL to open instead of the url of this constructor, or a urlAuthResultDefault, in which case the url of this constructor must be opened, instead. If the user refuses the authorization request but still wants to open the link, the url of this constructor must be used."
      ],
      "fields": {
        "button_id": "ID of the button to pass to messages.requestUrlAuth",
        "flags": "Flags, see TL conditional fields",
        "fwd_text": "New text of the button in forwarded messages.",
        "text": "Button label",
        "url": "An HTTP URL to be opened with user authorization data added to the query string when the button is pressed. If the user refuses to provide authorization data, the original URL without information about the user will be opened. The data added is the same as described in Receiving authorization data.NOTE: Services must always check the hash of the received data to verify the authentication and the integrity of the data as described in Checking authorization."
      }
    },
    "labeledPrice": {
      "name": "labeledPrice",
      "description": [
        "This object represents a portion of the price for goods or services."
      ],
      "fields": {
        "amount": "Price of the product in the smallest units of the currency (integer, not float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies).",
        "label": "Portion label"
      }
    },
    "langPackDifference": {
      "name": "langPackDifference",
      "description": [
        "Changes to the app's localization pack"
      ],
      "fields": {
        "from_version": "Previous version number",
        "lang_code": "Language code",
        "strings": "Localized strings",
        "version": "New version number"
      }
    },
    "langPackLanguage": {
      "name": "langPackLanguage",
      "description": [
        "Identifies a localization pack"
      ],
      "fields": {
        "base_lang_code": "Identifier of a base language pack; may be empty. If a string is missed in the language pack, then it should be fetched from base language pack. Unsupported in custom language packs",
        "beta": "Is this a beta localization pack?",
        "flags": "Flags, see TL conditional fields",
        "lang_code": "Language code (pack identifier)",
        "name": "Language name",
        "native_name": "Language name in the language itself",
        "official": "Whether the language pack is official",
        "plural_code": "A language code to be used to apply plural forms. See https://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html for more info",
        "rtl": "Is this a localization pack for an RTL language",
        "strings_count": "Total number of non-deleted strings from the language pack",
        "translated_count": "Total number of translated strings from the language pack",
        "translations_url": "Link to language translation interface; empty for custom local language packs"
      }
    },
    "langPackString": {
      "name": "langPackString",
      "description": [
        "Translated localization string"
      ],
      "fields": {
        "key": "Language key",
        "value": "Value"
      }
    },
    "langPackStringDeleted": {
      "name": "langPackStringDeleted",
      "description": [
        "Deleted localization string"
      ],
      "fields": {
        "key": "Localization key"
      }
    },
    "langPackStringPluralized": {
      "name": "langPackStringPluralized",
      "description": [
        "A language pack string which has different forms based on the number of some object it mentions. See https://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html for more info"
      ],
      "fields": {
        "few_value": "Value for a few objects",
        "flags": "Flags, see TL conditional fields",
        "key": "Localization key",
        "many_value": "Value for many objects",
        "one_value": "Value for one object",
        "other_value": "Default value",
        "two_value": "Value for two objects",
        "zero_value": "Value for zero objects"
      }
    },
    "maskCoords": {
      "name": "maskCoords",
      "description": [
        "Position on a photo where a mask should be placed",
        "The n position indicates where the mask should be placed:"
      ],
      "fields": {
        "n": "Part of the face, relative to which the mask should be placed",
        "x": "Shift by X-axis measured in widths of the mask scaled to the face size, from left to right. (For example, -1.0 will place the mask just to the left of the default mask position)",
        "y": "Shift by Y-axis measured in widths of the mask scaled to the face size, from left to right. (For example, -1.0 will place the mask just to the left of the default mask position)",
        "zoom": "Mask scaling coefficient. (For example, 2.0 means a doubled size)"
      }
    },
    "message": {
      "name": "message",
      "description": [
        "A message"
      ],
      "fields": {
        "date": "Date of the message",
        "edit_date": "Last edit date of this message",
        "edit_hide": "Whether the message should be shown as not modified to the user, even if an edit date is present",
        "entities": "Message entities for styled text",
        "flags": "Flags, see TL conditional fields",
        "forwards": "Forward counter",
        "from_id": "ID of the sender of the message",
        "from_scheduled": "Whether this is a scheduled message",
        "fwd_from": "Info about forwarded messages",
        "grouped_id": "Multiple media messages sent using messages.sendMultiMedia with the same grouped ID indicate an album or media group",
        "id": "ID of the message",
        "legacy": "This is a legacy message: it has to be refetched with the new layer",
        "media": "Media attachment",
        "media_unread": "Whether there are unread media attachments in this message",
        "mentioned": "Whether we were mentioned in this message",
        "message": "The message",
        "out": "Is this an outgoing message",
        "peer_id": "Peer ID, the chat where this message was sent",
        "pinned": "Whether this message is pinned",
        "post": "Whether this is a channel post",
        "post_author": "Name of the author of this message for channel posts (with signatures enabled)",
        "replies": "Info about post comments (for channels) or message replies (for groups)",
        "reply_markup": "Reply markup (bot/inline keyboards)",
        "reply_to": "Reply information",
        "restriction_reason": "Contains the reason why access to this message must be restricted.",
        "silent": "Whether this is a silent message (no notification triggered)",
        "via_bot_id": "ID of the inline bot that generated the message",
        "views": "View count for channel posts"
      }
    },
    "messageActionBotAllowed": {
      "name": "messageActionBotAllowed",
      "description": [
        "The domain name of the website on which the user has logged in. More about Telegram Login "
      ],
      "fields": {
        "domain": "The domain name of the website on which the user has logged in."
      }
    },
    "messageActionChannelCreate": {
      "name": "messageActionChannelCreate",
      "description": [
        "The channel was created"
      ],
      "fields": {
        "title": "Original channel/supergroup title"
      }
    },
    "messageActionChannelMigrateFrom": {
      "name": "messageActionChannelMigrateFrom",
      "description": [
        "Indicates the channel was migrated from the specified chat"
      ],
      "fields": {
        "chat_id": "The old chat ID",
        "title": "The old chat tite"
      }
    },
    "messageActionChatAddUser": {
      "name": "messageActionChatAddUser",
      "description": [
        "New member in the group"
      ],
      "fields": {
        "users": "Users that were invited to the chat"
      }
    },
    "messageActionChatCreate": {
      "name": "messageActionChatCreate",
      "description": [
        "Group created"
      ],
      "fields": {
        "title": "Group name",
        "users": "List of group members"
      }
    },
    "messageActionChatDeletePhoto": {
      "name": "messageActionChatDeletePhoto",
      "description": [
        "Group profile photo removed."
      ]
    },
    "messageActionChatDeleteUser": {
      "name": "messageActionChatDeleteUser",
      "description": [
        "User left the group."
      ],
      "fields": {
        "user_id": "Leaving user ID"
      }
    },
    "messageActionChatEditPhoto": {
      "name": "messageActionChatEditPhoto",
      "description": [
        "Group profile changed"
      ],
      "fields": {
        "photo": "New group pofile photo"
      }
    },
    "messageActionChatEditTitle": {
      "name": "messageActionChatEditTitle",
      "description": [
        "Group name changed."
      ],
      "fields": {
        "title": "New group name"
      }
    },
    "messageActionChatJoinedByLink": {
      "name": "messageActionChatJoinedByLink",
      "description": [
        "A user joined the chat via an invite link"
      ],
      "fields": {
        "inviter_id": "ID of the user that created the invite link"
      }
    },
    "messageActionChatMigrateTo": {
      "name": "messageActionChatMigrateTo",
      "description": [
        "Indicates the chat was migrated to the specified supergroup"
      ],
      "fields": {
        "channel_id": "The supergroup it was migrated to"
      }
    },
    "messageActionContactSignUp": {
      "name": "messageActionContactSignUp",
      "description": [
        "A contact just signed up to telegram"
      ]
    },
    "messageActionCustomAction": {
      "name": "messageActionCustomAction",
      "description": [
        "Custom action (most likely not supported by the current layer, an upgrade might be needed)"
      ],
      "fields": {
        "message": "Action message"
      }
    },
    "messageActionEmpty": {
      "name": "messageActionEmpty",
      "description": [
        "Empty constructor."
      ]
    },
    "messageActionGameScore": {
      "name": "messageActionGameScore",
      "description": [
        "Someone scored in a game"
      ],
      "fields": {
        "game_id": "Game ID",
        "score": "Score"
      }
    },
    "messageActionGeoProximityReached": {
      "name": "messageActionGeoProximityReached",
      "description": [
        "A user of the chat is now in proximity of another user"
      ],
      "fields": {
        "distance": "Distance, in meters (0-100000)",
        "from_id": "The user or chat that is now in proximity of to_id",
        "to_id": "The user or chat that subscribed to live geolocation proximity alerts"
      }
    },
    "messageActionHistoryClear": {
      "name": "messageActionHistoryClear",
      "description": [
        "Chat history was cleared"
      ]
    },
    "messageActionPaymentSent": {
      "name": "messageActionPaymentSent",
      "description": [
        "A payment was sent"
      ],
      "fields": {
        "currency": "Three-letter ISO 4217 currency code",
        "total_amount": "Price of the product in the smallest units of the currency (integer, not float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies)."
      }
    },
    "messageActionPaymentSentMe": {
      "name": "messageActionPaymentSentMe",
      "description": [
        "A user just sent a payment to me (a bot)"
      ],
      "fields": {
        "charge": "Provider payment identifier",
        "currency": "Three-letter ISO 4217 currency code",
        "flags": "Flags, see TL conditional fields",
        "info": "Order info provided by the user",
        "payload": "Bot specified invoice payload",
        "shipping_option_id": "Identifier of the shipping option chosen by the user",
        "total_amount": "Price of the product in the smallest units of the currency (integer, not float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies)."
      }
    },
    "messageActionPhoneCall": {
      "name": "messageActionPhoneCall",
      "description": [
        "A phone call"
      ],
      "fields": {
        "call_id": "Call ID",
        "duration": "Duration of the call in seconds",
        "flags": "Flags, see TL conditional fields",
        "reason": "If the call has ended, the reason why it ended",
        "video": "Is this a video call?"
      }
    },
    "messageActionPinMessage": {
      "name": "messageActionPinMessage",
      "description": [
        "A message was pinned"
      ]
    },
    "messageActionScreenshotTaken": {
      "name": "messageActionScreenshotTaken",
      "description": [
        "A screenshot of the chat was taken"
      ]
    },
    "messageActionSecureValuesSent": {
      "name": "messageActionSecureValuesSent",
      "description": [
        "Request for secure telegram passport values was sent"
      ],
      "fields": {
        "types": "Secure value types"
      }
    },
    "messageActionSecureValuesSentMe": {
      "name": "messageActionSecureValuesSentMe",
      "description": [
        "Secure telegram passport values were received"
      ],
      "fields": {
        "credentials": "Encrypted credentials required to decrypt the data",
        "values": "Vector with information about documents and other Telegram Passport elements that were shared with the bot"
      }
    },
    "messageEmpty": {
      "name": "messageEmpty",
      "description": [
        "Empty constructor, non-existent message."
      ],
      "fields": {
        "id": "Message identifier"
      }
    },
    "messageEntityBankCard": {
      "name": "messageEntityBankCard",
      "description": [
        "Indicates a credit card number"
      ],
      "fields": {
        "length": "Length of message entity within message (in UTF-8 codepoints)",
        "offset": "Offset of message entity within message (in UTF-8 codepoints)"
      }
    },
    "messageEntityBlockquote": {
      "name": "messageEntityBlockquote",
      "description": [
        "Message entity representing a block quote."
      ],
      "fields": {
        "length": "Length of message entity within message (in UTF-8 codepoints)",
        "offset": "Offset of message entity within message (in UTF-8 codepoints)"
      }
    },
    "messageEntityBold": {
      "name": "messageEntityBold",
      "description": [
        "Message entity representing bold text."
      ],
      "fields": {
        "length": "Length of message entity within message (in UTF-8 codepoints)",
        "offset": "Offset of message entity within message (in UTF-8 codepoints)"
      }
    },
    "messageEntityBotCommand": {
      "name": "messageEntityBotCommand",
      "description": [
        "Message entity representing a bot /command"
      ],
      "fields": {
        "length": "Length of message entity within message (in UTF-8 codepoints)",
        "offset": "Offset of message entity within message (in UTF-8 codepoints)"
      }
    },
    "messageEntityCashtag": {
      "name": "messageEntityCashtag",
      "description": [
        "Message entity representing a $cashtag."
      ],
      "fields": {
        "length": "Length of message entity within message (in UTF-8 codepoints)",
        "offset": "Offset of message entity within message (in UTF-8 codepoints)"
      }
    },
    "messageEntityCode": {
      "name": "messageEntityCode",
      "description": [
        "Message entity representing a codeblock."
      ],
      "fields": {
        "length": "Length of message entity within message (in UTF-8 codepoints)",
        "offset": "Offset of message entity within message (in UTF-8 codepoints)"
      }
    },
    "messageEntityEmail": {
      "name": "messageEntityEmail",
      "description": [
        "Message entity representing an email@example.com."
      ],
      "fields": {
        "length": "Length of message entity within message (in UTF-8 codepoints)",
        "offset": "Offset of message entity within message (in UTF-8 codepoints)"
      }
    },
    "messageEntityHashtag": {
      "name": "messageEntityHashtag",
      "description": [
        "#hashtag message entity"
      ],
      "fields": {
        "length": "Length of message entity within message (in UTF-8 codepoints)",
        "offset": "Offset of message entity within message (in UTF-8 codepoints)"
      }
    },
    "messageEntityItalic": {
      "name": "messageEntityItalic",
      "description": [
        "Message entity representing italic text."
      ],
      "fields": {
        "length": "Length of message entity within message (in UTF-8 codepoints)",
        "offset": "Offset of message entity within message (in UTF-8 codepoints)"
      }
    },
    "messageEntityMention": {
      "name": "messageEntityMention",
      "description": [
        "Message entity mentioning the current user"
      ],
      "fields": {
        "length": "Length of message entity within message (in UTF-8 codepoints)",
        "offset": "Offset of message entity within message (in UTF-8 codepoints)"
      }
    },
    "messageEntityMentionName": {
      "name": "messageEntityMentionName",
      "description": [
        "Message entity representing a user mention: for creating a mention use inputMessageEntityMentionName."
      ],
      "fields": {
        "length": "Length of message entity within message (in UTF-8 codepoints)",
        "offset": "Offset of message entity within message (in UTF-8 codepoints)",
        "user_id": "Identifier of the user that was mentioned"
      }
    },
    "messageEntityPhone": {
      "name": "messageEntityPhone",
      "description": [
        "Message entity representing a phone number."
      ],
      "fields": {
        "length": "Length of message entity within message (in UTF-8 codepoints)",
        "offset": "Offset of message entity within message (in UTF-8 codepoints)"
      }
    },
    "messageEntityPre": {
      "name": "messageEntityPre",
      "description": [
        "Message entity representing a preformatted codeblock, allowing the user to specify a programming language for the codeblock."
      ],
      "fields": {
        "language": "Programming language of the code",
        "length": "Length of message entity within message (in UTF-8 codepoints)",
        "offset": "Offset of message entity within message (in UTF-8 codepoints)"
      }
    },
    "messageEntityStrike": {
      "name": "messageEntityStrike",
      "description": [
        "Message entity representing strikethrough text."
      ],
      "fields": {
        "length": "Length of message entity within message (in UTF-8 codepoints)",
        "offset": "Offset of message entity within message (in UTF-8 codepoints)"
      }
    },
    "messageEntityTextUrl": {
      "name": "messageEntityTextUrl",
      "description": [
        "Message entity representing a text url: for in-text urls like https://google.com use messageEntityUrl."
      ],
      "fields": {
        "length": "Length of message entity within message (in UTF-8 codepoints)",
        "offset": "Offset of message entity within message (in UTF-8 codepoints)",
        "url": "The actual URL"
      }
    },
    "messageEntityUnderline": {
      "name": "messageEntityUnderline",
      "description": [
        "Message entity representing underlined text."
      ],
      "fields": {
        "length": "Length of message entity within message (in UTF-8 codepoints)",
        "offset": "Offset of message entity within message (in UTF-8 codepoints)"
      }
    },
    "messageEntityUnknown": {
      "name": "messageEntityUnknown",
      "description": [
        "Unknown message entity"
      ],
      "fields": {
        "length": "Length of message entity within message (in UTF-8 codepoints)",
        "offset": "Offset of message entity within message (in UTF-8 codepoints)"
      }
    },
    "messageEntityUrl": {
      "name": "messageEntityUrl",
      "description": [
        "Message entity representing an in-text url: https://google.com; for text urls, use messageEntityTextUrl."
      ],
      "fields": {
        "length": "Length of message entity within message (in UTF-8 codepoints)",
        "offset": "Offset of message entity within message (in UTF-8 codepoints)"
      }
    },
    "messageFwdHeader": {
      "name": "messageFwdHeader",
      "description": [
        "Info about a forwarded message"
      ],
      "fields": {
        "channel_post": "ID of the channel message that was forwarded",
        "date": "When was the message originally sent",
        "flags": "Flags, see TL conditional fields",
        "from_id": "The ID of the user that originally sent the message",
        "from_name": "The name of the user that originally sent the message",
        "post_author": "For channels and if signatures are enabled, author of the channel message",
        "psa_type": "PSA type",
        "saved_from_msg_id": "Only for messages forwarded to the current user (inputPeerSelf), ID of the message that was forwarded from the original user/channel",
        "saved_from_peer": "Only for messages forwarded to the current user (inputPeerSelf), full info about the user/channel that originally sent the message"
      }
    },
    "messageInteractionCounters": {
      "name": "messageInteractionCounters",
      "description": [
        "Message interaction counters"
      ],
      "fields": {
        "forwards": "Number of times this message was forwarded",
        "msg_id": "Message ID",
        "views": "Views"
      }
    },
    "messageMediaContact": {
      "name": "messageMediaContact",
      "description": [
        "Attached contact."
      ],
      "fields": {
        "first_name": "Contact's first name",
        "last_name": "Contact's last name",
        "phone_number": "Phone number",
        "user_id": "User identifier or 0, if the user with the given phone number is not registered",
        "vcard": "VCARD of contact"
      }
    },
    "messageMediaDice": {
      "name": "messageMediaDice",
      "description": [
        "Dice-based animated sticker"
      ],
      "fields": {
        "emoticon": "The emoji, for now ,  and  are supported",
        "value": "Dice value"
      }
    },
    "messageMediaDocument": {
      "name": "messageMediaDocument",
      "description": [
        "Document (video, audio, voice, sticker, any media type except photo)"
      ],
      "fields": {
        "document": "Attached document",
        "flags": "Flags, see TL conditional fields",
        "ttl_seconds": "Time to live of self-destructing document"
      }
    },
    "messageMediaEmpty": {
      "name": "messageMediaEmpty",
      "description": [
        "Empty constructor."
      ]
    },
    "messageMediaGame": {
      "name": "messageMediaGame",
      "description": [
        "Telegram game"
      ],
      "fields": {
        "game": "Game"
      }
    },
    "messageMediaGeo": {
      "name": "messageMediaGeo",
      "description": [
        "Attached map."
      ],
      "fields": {
        "geo": "GeoPoint"
      }
    },
    "messageMediaGeoLive": {
      "name": "messageMediaGeoLive",
      "description": [
        "Indicates a live geolocation"
      ],
      "fields": {
        "flags": "Flags, see TL conditional fields",
        "geo": "Geolocation",
        "heading": "For live locations, a direction in which the location moves, in degrees; 1-360",
        "period": "Validity period of provided geolocation",
        "proximity_notification_radius": "For live locations, a maximum distance to another chat member for proximity alerts, in meters (0-100000)."
      }
    },
    "messageMediaInvoice": {
      "name": "messageMediaInvoice",
      "description": [
        "Invoice"
      ],
      "fields": {
        "currency": "Three-letter ISO 4217 currency code",
        "description": "Product description, 1-255 characters",
        "flags": "Flags, see TL conditional fields",
        "photo": "URL of the product photo for the invoice. Can be a photo of the goods or a marketing image for a service. People like it better when they see what they are paying for.",
        "receipt_msg_id": "Message ID of receipt: if set, clients should change the text of the first keyboardButtonBuy button always attached to the message to a localized version of the word Receipt",
        "shipping_address_requested": "Whether the shipping address was requested",
        "start_param": "Unique bot deep-linking parameter that can be used to generate this invoice",
        "test": "Whether this is an example invoice",
        "title": "Product name, 1-32 characters",
        "total_amount": "Total price in the smallest units of the currency (integer, not float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies)."
      }
    },
    "messageMediaPhoto": {
      "name": "messageMediaPhoto",
      "description": [
        "Attached photo."
      ],
      "fields": {
        "flags": "Flags, see TL conditional fields",
        "photo": "Photo",
        "ttl_seconds": "Time to live in seconds of self-destructing photo"
      }
    },
    "messageMediaPoll": {
      "name": "messageMediaPoll",
      "description": [
        "Poll"
      ],
      "fields": {
        "poll": "The poll",
        "results": "The results of the poll"
      }
    },
    "messageMediaUnsupported": {
      "name": "messageMediaUnsupported",
      "description": [
        "Current version of the client does not support this media type."
      ]
    },
    "messageMediaVenue": {
      "name": "messageMediaVenue",
      "description": [
        "Venue"
      ],
      "fields": {
        "address": "Address",
        "geo": "Geolocation of venue",
        "provider": "Venue provider: currently only \"foursquare\" needs to be supported",
        "title": "Venue name",
        "venue_id": "Venue ID in the provider's database",
        "venue_type": "Venue type in the provider's database"
      }
    },
    "messageMediaWebPage": {
      "name": "messageMediaWebPage",
      "description": [
        "Preview of webpage"
      ],
      "fields": {
        "webpage": "Webpage preview"
      }
    },
    "messageRange": {
      "name": "messageRange",
      "description": [
        "Indicates a range of chat messages"
      ],
      "fields": {
        "max_id": "End of range (message ID)",
        "min_id": "Start of range (message ID)"
      }
    },
    "messageReplies": {
      "name": "messageReplies",
      "description": [
        "Info about the comment section of a channel post, or a simple message thread"
      ],
      "fields": {
        "channel_id": "For channel post comments, contains the ID of the associated discussion supergroup",
        "comments": "Whether this constructor contains information about the comment section of a channel post, or a simple message thread",
        "flags": "Flags, see TL conditional fields",
        "max_id": "ID of the latest message in this thread or comment section.",
        "read_max_id": "Contains the ID of the latest read message in this thread or comment section.",
        "recent_repliers": "For channel post comments, contains information about the last few comment posters for a specific thread, to show a small list of commenter profile pictures in client previews.",
        "replies": "Contains the total number of replies in this thread or comment section.",
        "replies_pts": "PTS of the message that started this thread."
      }
    },
    "messageReplyHeader": {
      "name": "messageReplyHeader",
      "description": [
        "Message replies and thread information"
      ],
      "fields": {
        "flags": "Flags, see TL conditional fields",
        "reply_to_msg_id": "ID of message to which this message is replying",
        "reply_to_peer_id": "For replies sent in channel discussion threads of which the current user is not a member, the discussion group ID",
        "reply_to_top_id": "ID of the message that started this message thread"
      }
    },
    "messageService": {
      "name": "messageService",
      "description": [
        "Indicates a service message"
      ],
      "fields": {
        "action": "Event connected with the service message",
        "date": "Message date",
        "flags": "Flags, see TL conditional fields",
        "from_id": "ID of the sender of this message",
        "id": "Message ID",
        "legacy": "This is a legacy message: it has to be refetched with the new layer",
        "media_unread": "Whether the message contains unread media",
        "mentioned": "Whether we were mentioned in the message",
        "out": "Whether the message is outgoing",
        "peer_id": "Sender of service message",
        "post": "Whether it's a channel post",
        "reply_to": "Reply (thread) information",
        "silent": "Whether the message is silent"
      }
    },
    "messageUserVote": {
      "name": "messageUserVote",
      "description": [
        "How a user voted in a poll"
      ],
      "fields": {
        "date": "When did the user cast the vote",
        "option": "The option chosen by the user",
        "user_id": "User ID"
      }
    },
    "messageUserVoteInputOption": {
      "name": "messageUserVoteInputOption",
      "description": [
        "How a user voted in a poll (reduced constructor, returned if an option was provided to messages.getPollVotes)"
      ],
      "fields": {
        "date": "When did the user cast the vote",
        "user_id": "The user that voted for the queried option"
      }
    },
    "messageUserVoteMultiple": {
      "name": "messageUserVoteMultiple",
      "description": [
        "How a user voted in a multiple-choice poll"
      ],
      "fields": {
        "date": "When did the user cast their votes",
        "options": "Options chosen by the user",
        "user_id": "User ID"
      }
    },
    "messageViews": {
      "name": "messageViews",
      "description": [
        "View, forward counter + info about replies of a specific message"
      ],
      "fields": {
        "flags": "Flags, see TL conditional fields",
        "forwards": "Forward count of message",
        "replies": "Reply and thread information of message",
        "views": "Viewcount of message"
      }
    },
    "messages.affectedHistory": {
      "name": "messages.affectedHistory",
      "description": [
        "Affected part of communication history with the user or in a chat."
      ],
      "fields": {
        "offset": "If a parameter contains positive value, it is necessary to repeat the method call using the given value; during the proceeding of all the history the value itself shall gradually decrease",
        "pts": "Number of events occured in a text box",
        "pts_count": "Number of affected events"
      }
    },
    "messages.affectedMessages": {
      "name": "messages.affectedMessages",
      "description": [
        "Events affected by operation"
      ],
      "fields": {
        "pts": "Event count after generation",
        "pts_count": "Number of events that were generated"
      }
    },
    "messages.allStickers": {
      "name": "messages.allStickers",
      "description": [
        "Info about all installed stickers"
      ],
      "fields": {
        "hash": "Hash for pagination, for more info click here",
        "sets": "All stickersets"
      }
    },
    "messages.allStickersNotModified": {
      "name": "messages.allStickersNotModified",
      "description": [
        "Info about all installed stickers hasn't changed"
      ]
    },
    "messages.archivedStickers": {
      "name": "messages.archivedStickers",
      "description": [
        "Archived stickersets"
      ],
      "fields": {
        "count": "Number of archived stickers",
        "sets": "Archived stickersets"
      }
    },
    "messages.botCallbackAnswer": {
      "name": "messages.botCallbackAnswer",
      "description": [
        "Callback answer sent by the bot in response to a button press"
      ],
      "fields": {
        "alert": "Whether an alert should be shown to the user instead of a toast notification",
        "cache_time": "For how long should this answer be cached",
        "flags": "Flags, see TL conditional fields",
        "has_url": "Whether an URL is present",
        "message": "Alert to show",
        "native_ui": "Whether to show games in WebView or in native UI.",
        "url": "URL to open"
      }
    },
    "messages.botResults": {
      "name": "messages.botResults",
      "description": [
        "Result of a query to an inline bot"
      ],
      "fields": {
        "cache_time": "Caching validity of the results",
        "flags": "Flags, see TL conditional fields",
        "gallery": "Whether the result is a picture gallery",
        "next_offset": "The next offset to use when navigating through results",
        "query_id": "Query ID",
        "results": "The results",
        "switch_pm": "Whether the bot requested the user to message him in private",
        "users": "Users mentioned in the results"
      }
    },
    "messages.channelMessages": {
      "name": "messages.channelMessages",
      "description": [
        "Channel messages"
      ],
      "fields": {
        "chats": "Chats",
        "count": "Total number of results were found server-side (may not be all included here)",
        "flags": "Flags, see TL conditional fields",
        "inexact": "If set, returned results may be inexact",
        "messages": "Found messages",
        "offset_id_offset": "Indicates the absolute position of messages[0] within the total result set with count count. This is useful, for example, if the result was fetched using offset_id, and we need to display a progress/total counter (like photo 134 of 200, for all media in a chat, we could simply use photo ${offset_id_offset} of ${count}.",
        "pts": "Event count after generation",
        "users": "Users"
      }
    },
    "messages.chatFull": {
      "name": "messages.chatFull",
      "description": [
        "Extended info on chat and auxiliary data."
      ],
      "fields": {
        "chats": "List containing basic info on chat",
        "full_chat": "Extended info on a chat",
        "users": "List of users mentioned above"
      }
    },
    "messages.chats": {
      "name": "messages.chats",
      "description": [
        "List of chats with auxiliary data."
      ],
      "fields": {
        "chats": "List of chats"
      }
    },
    "messages.chatsSlice": {
      "name": "messages.chatsSlice",
      "description": [
        "Partial list of chats, more would have to be fetched with pagination"
      ],
      "fields": {
        "chats": "Chats",
        "count": "Total number of results that were found server-side (not all are included in chats)"
      }
    },
    "messages.dhConfig": {
      "name": "messages.dhConfig",
      "description": [
        "New set of configuring parameters."
      ],
      "fields": {
        "g": "New value prime, see Wikipedia",
        "p": "New value primitive root, see Wikipedia",
        "random": "Random sequence of bytes of assigned length",
        "version": "Vestion of set of parameters"
      }
    },
    "messages.dhConfigNotModified": {
      "name": "messages.dhConfigNotModified",
      "description": [
        "Configuring parameters did not change."
      ],
      "fields": {
        "random": "Random sequence of bytes of assigned length"
      }
    },
    "messages.dialogs": {
      "name": "messages.dialogs",
      "description": [
        "Full list of chats with messages and auxiliary data."
      ],
      "fields": {
        "chats": "List of groups mentioned in the chats",
        "dialogs": "List of chats",
        "messages": "List of last messages from each chat",
        "users": "List of users mentioned in messages and groups"
      }
    },
    "messages.dialogsNotModified": {
      "name": "messages.dialogsNotModified",
      "description": [
        "Dialogs haven't changed"
      ],
      "fields": {
        "count": "Number of dialogs found server-side by the query"
      }
    },
    "messages.dialogsSlice": {
      "name": "messages.dialogsSlice",
      "description": [
        "Incomplete list of dialogs with messages and auxiliary data."
      ],
      "fields": {
        "chats": "List of chats mentioned in dialogs",
        "count": "Total number of dialogs",
        "dialogs": "List of dialogs",
        "messages": "List of last messages from dialogs",
        "users": "List of users mentioned in messages and chats"
      }
    },
    "messages.discussionMessage": {
      "name": "messages.discussionMessage",
      "description": [
        "Information about a message thread"
      ],
      "fields": {
        "chats": "Chats mentioned in constructor",
        "flags": "Flags, see TL conditional fields",
        "max_id": "Message ID of latest reply in this thread",
        "messages": "Discussion messages",
        "read_inbox_max_id": "Message ID of latest read incoming message in this thread",
        "read_outbox_max_id": "Message ID of latest read outgoing message in this thread",
        "users": "Users mentioned in constructor"
      }
    },
    "messages.favedStickers": {
      "name": "messages.favedStickers",
      "description": [
        "Favorited stickers"
      ],
      "fields": {
        "hash": "Hash for pagination, for more info click here",
        "packs": "Emojis associated to stickers",
        "stickers": "Favorited stickers"
      }
    },
    "messages.favedStickersNotModified": {
      "name": "messages.favedStickersNotModified",
      "description": [
        "No new favorited stickers were found"
      ]
    },
    "messages.featuredStickers": {
      "name": "messages.featuredStickers",
      "description": [
        "Featured stickersets"
      ],
      "fields": {
        "count": "Total number of featured stickers",
        "hash": "Hash for pagination, for more info click here",
        "sets": "Featured stickersets",
        "unread": "IDs of new featured stickersets"
      }
    },
    "messages.featuredStickersNotModified": {
      "name": "messages.featuredStickersNotModified",
      "description": [
        "Featured stickers haven't changed"
      ],
      "fields": {
        "count": "Total number of featured stickers"
      }
    },
    "messages.foundStickerSets": {
      "name": "messages.foundStickerSets",
      "description": [
        "Found stickersets"
      ],
      "fields": {
        "hash": "Hash for pagination, for more info click here",
        "sets": "Found stickersets"
      }
    },
    "messages.foundStickerSetsNotModified": {
      "name": "messages.foundStickerSetsNotModified",
      "description": [
        "No further results were found"
      ]
    },
    "messages.highScores": {
      "name": "messages.highScores",
      "description": [
        "Highscores in a game"
      ],
      "fields": {
        "scores": "Highscores",
        "users": "Users, associated to the highscores"
      }
    },
    "messages.inactiveChats": {
      "name": "messages.inactiveChats",
      "description": [
        "Inactive chat list"
      ],
      "fields": {
        "chats": "Chat list",
        "dates": "When was the chat last active",
        "users": "Users mentioned in the chat list"
      }
    },
    "messages.messageEditData": {
      "name": "messages.messageEditData",
      "description": [
        "Message edit data for media"
      ],
      "fields": {
        "caption": "Media caption, if the specified media's caption can be edited",
        "flags": "Flags, see TL conditional fields"
      }
    },
    "messages.messageViews": {
      "name": "messages.messageViews",
      "description": [
        "View, forward counter + info about replies"
      ],
      "fields": {
        "chats": "Chats mentioned in constructor",
        "users": "Users mentioned in constructor",
        "views": "View, forward counter + info about replies"
      }
    },
    "messages.messages": {
      "name": "messages.messages",
      "description": [
        "Full list of messages with auxilary data."
      ],
      "fields": {
        "chats": "List of chats mentioned in dialogs",
        "messages": "List of messages",
        "users": "List of users mentioned in messages and chats"
      }
    },
    "messages.messagesNotModified": {
      "name": "messages.messagesNotModified",
      "description": [
        "No new messages matching the query were found"
      ],
      "fields": {
        "count": "Number of results found server-side by the given query"
      }
    },
    "messages.messagesSlice": {
      "name": "messages.messagesSlice",
      "description": [
        "Incomplete list of messages and auxiliary data."
      ],
      "fields": {
        "chats": "List of chats mentioned in messages",
        "count": "Total number of messages in the list",
        "flags": "Flags, see TL conditional fields",
        "inexact": "If set, indicates that the results may be inexact",
        "messages": "List of messages",
        "next_rate": "Rate to use in the offset_rate parameter in the next call to messages.searchGlobal",
        "offset_id_offset": "Indicates the absolute position of messages[0] within the total result set with count count. This is useful, for example, if the result was fetched using offset_id, and we need to display a progress/total counter (like photo 134 of 200, for all media in a chat, we could simply use photo ${offset_id_offset} of ${count}.",
        "users": "List of users mentioned in messages and chats"
      }
    },
    "messages.peerDialogs": {
      "name": "messages.peerDialogs",
      "description": [
        "Dialog info of multiple peers"
      ],
      "fields": {
        "chats": "Chats",
        "dialogs": "Dialog info",
        "messages": "Messages mentioned in dialog info",
        "state": "Current update state of dialog",
        "users": "Users"
      }
    },
    "messages.recentStickers": {
      "name": "messages.recentStickers",
      "description": [
        "Recently used stickers"
      ],
      "fields": {
        "dates": "When was each sticker last used",
        "hash": "Hash for pagination, for more info click here",
        "packs": "Emojis associated to stickers",
        "stickers": "Recent stickers"
      }
    },
    "messages.recentStickersNotModified": {
      "name": "messages.recentStickersNotModified",
      "description": [
        "No new recent sticker was found"
      ]
    },
    "messages.savedGifs": {
      "name": "messages.savedGifs",
      "description": [
        "Saved gifs"
      ],
      "fields": {
        "gifs": "List of saved gifs",
        "hash": "Hash for pagination, for more info click here"
      }
    },
    "messages.savedGifsNotModified": {
      "name": "messages.savedGifsNotModified",
      "description": [
        "No new saved gifs were found"
      ]
    },
    "messages.searchCounter": {
      "name": "messages.searchCounter",
      "description": [
        "Indicates how many results would be found by a messages.search call with the same parameters"
      ],
      "fields": {
        "count": "Number of results that were found server-side",
        "filter": "Provided message filter",
        "flags": "Flags, see TL conditional fields",
        "inexact": "If set, the results may be inexact"
      }
    },
    "messages.sentEncryptedFile": {
      "name": "messages.sentEncryptedFile",
      "description": [
        "Message with a file enclosure sent to a protected chat"
      ],
      "fields": {
        "date": "Sending date",
        "file": "Attached file"
      }
    },
    "messages.sentEncryptedMessage": {
      "name": "messages.sentEncryptedMessage",
      "description": [
        "Message without file attachemts sent to an encrypted file."
      ],
      "fields": {
        "date": "Date of sending"
      }
    },
    "messages.stickerSet": {
      "name": "messages.stickerSet",
      "description": [
        "Stickerset and stickers inside it"
      ],
      "fields": {
        "documents": "Stickers in stickerset",
        "packs": "Emoji info for stickers",
        "set": "The stickerset"
      }
    },
    "messages.stickerSetInstallResultArchive": {
      "name": "messages.stickerSetInstallResultArchive",
      "description": [
        "The stickerset was installed, but since there are too many stickersets some were archived"
      ],
      "fields": {
        "sets": "Archived stickersets"
      }
    },
    "messages.stickerSetInstallResultSuccess": {
      "name": "messages.stickerSetInstallResultSuccess",
      "description": [
        "The stickerset was installed successfully"
      ]
    },
    "messages.stickers": {
      "name": "messages.stickers",
      "description": [
        "Found stickers"
      ],
      "fields": {
        "hash": "Hash for pagination, for more info click here",
        "stickers": "Stickers"
      }
    },
    "messages.stickersNotModified": {
      "name": "messages.stickersNotModified",
      "description": [
        "No new stickers were found for the given query"
      ]
    },
    "messages.votesList": {
      "name": "messages.votesList",
      "description": [
        "How users voted in a poll"
      ],
      "fields": {
        "count": "Total number of votes for all options (or only for the chosen option, if provided to messages.getPollVotes)",
        "flags": "Flags, see TL conditional fields",
        "next_offset": "Offset to use with the next messages.getPollVotes request, empty string if no more results are available.",
        "users": "Info about users that voted in the poll",
        "votes": "Vote info for each user"
      }
    },
    "nearestDc": {
      "name": "nearestDc",
      "description": [
        "Nearest data centre, according to geo-ip."
      ],
      "fields": {
        "country": "Country code determined by geo-ip",
        "nearest_dc": "Number of nearest data centre",
        "this_dc": "Number of current data centre"
      }
    },
    "notifyBroadcasts": {
      "name": "notifyBroadcasts",
      "description": [
        "Channel notification settings"
      ]
    },
    "notifyChats": {
      "name": "notifyChats",
      "description": [
        "Notifications generated by all groups."
      ]
    },
    "notifyPeer": {
      "name": "notifyPeer",
      "description": [
        "Notifications generated by a certain user or group."
      ],
      "fields": {
        "peer": "user or group"
      }
    },
    "notifyUsers": {
      "name": "notifyUsers",
      "description": [
        "Notifications generated by all users."
      ]
    },
    "null": {
      "name": "null",
      "description": [
        "Corresponds to an arbitrary empty object."
      ]
    },
    "page": {
      "name": "page",
      "description": [
        "Instant view page"
      ],
      "fields": {
        "blocks": "Page elements (like with HTML elements, only as TL constructors)",
        "documents": "Media in page",
        "flags": "Flags, see TL conditional fields",
        "part": "Indicates that not full page preview is available to the client and it will need to fetch full Instant View from the server using messages.getWebPagePreview.",
        "photos": "Photos in page",
        "rtl": "Whether the page contains RTL text",
        "url": "Original page HTTP URL",
        "v2": "Whether this is an IV v2 page",
        "views": "Viewcount"
      }
    },
    "pageBlockAnchor": {
      "name": "pageBlockAnchor",
      "description": [
        "Link to section within the page itself (like \u003ca href=\"#target\"\u003eanchor\u003c/a\u003e)"
      ],
      "fields": {
        "name": "Name of target section"
      }
    },
    "pageBlockAudio": {
      "name": "pageBlockAudio",
      "description": [
        "Audio"
      ],
      "fields": {
        "audio_id": "Audio ID (to be fetched from the container page constructor",
        "caption": "Audio caption"
      }
    },
    "pageBlockAuthorDate": {
      "name": "pageBlockAuthorDate",
      "description": [
        "Author and date of creation of article"
      ],
      "fields": {
        "author": "Author name",
        "published_date": "Date of pubblication"
      }
    },
    "pageBlockBlockquote": {
      "name": "pageBlockBlockquote",
      "description": [
        "Quote (equivalent to the HTML \u003cblockquote\u003e)"
      ],
      "fields": {
        "caption": "Caption",
        "text": "Quote contents"
      }
    },
    "pageBlockChannel": {
      "name": "pageBlockChannel",
      "description": [
        "Reference to a telegram channel"
      ],
      "fields": {
        "channel": "The channel/supergroup/chat"
      }
    },
    "pageBlockCollage": {
      "name": "pageBlockCollage",
      "description": [
        "Collage of media"
      ],
      "fields": {
        "caption": "Caption",
        "items": "Media elements"
      }
    },
    "pageBlockCover": {
      "name": "pageBlockCover",
      "description": [
        "A page cover"
      ],
      "fields": {
        "cover": "Cover"
      }
    },
    "pageBlockDetails": {
      "name": "pageBlockDetails",
      "description": [
        "A collapsible details block"
      ],
      "fields": {
        "blocks": "Block contents",
        "flags": "Flags, see TL conditional fields",
        "open": "Whether the block is open by default",
        "title": "Always visible heading for the block"
      }
    },
    "pageBlockDivider": {
      "name": "pageBlockDivider",
      "description": [
        "An empty block separating a page"
      ]
    },
    "pageBlockEmbed": {
      "name": "pageBlockEmbed",
      "description": [
        "An embedded webpage"
      ],
      "fields": {
        "allow_scrolling": "Whether scrolling should be allowed",
        "caption": "Caption",
        "flags": "Flags, see TL conditional fields",
        "full_width": "Whether the block should be full width",
        "h": "Block height, if known",
        "html": "HTML-markup of the embedded page",
        "poster_photo_id": "Poster photo, if available",
        "url": "Web page URL, if available",
        "w": "Block width, if known"
      }
    },
    "pageBlockEmbedPost": {
      "name": "pageBlockEmbedPost",
      "description": [
        "An embedded post"
      ],
      "fields": {
        "author": "Author name",
        "author_photo_id": "ID of the author's photo",
        "blocks": "Post contents",
        "caption": "Caption",
        "date": "Creation date",
        "url": "Web page URL",
        "webpage_id": "ID of generated webpage preview"
      }
    },
    "pageBlockFooter": {
      "name": "pageBlockFooter",
      "description": [
        "Page footer"
      ],
      "fields": {
        "text": "Contents"
      }
    },
    "pageBlockHeader": {
      "name": "pageBlockHeader",
      "description": [
        "Page header"
      ],
      "fields": {
        "text": "Contents"
      }
    },
    "pageBlockKicker": {
      "name": "pageBlockKicker",
      "description": [
        "Kicker"
      ],
      "fields": {
        "text": "Contents"
      }
    },
    "pageBlockList": {
      "name": "pageBlockList",
      "description": [
        "Unordered list of IV blocks"
      ],
      "fields": {
        "items": "List of blocks in an IV page"
      }
    },
    "pageBlockMap": {
      "name": "pageBlockMap",
      "description": [
        "A map"
      ],
      "fields": {
        "caption": "Caption",
        "geo": "Location of the map center",
        "h": "Map height in pixels before applying scale; 16-1024",
        "w": "Map width in pixels before applying scale; 16-102",
        "zoom": "Map zoom level; 13-20"
      }
    },
    "pageBlockOrderedList": {
      "name": "pageBlockOrderedList",
      "description": [
        "Ordered list of IV blocks"
      ],
      "fields": {
        "items": "List items"
      }
    },
    "pageBlockParagraph": {
      "name": "pageBlockParagraph",
      "description": [
        "A paragraph"
      ],
      "fields": {
        "text": "Text"
      }
    },
    "pageBlockPhoto": {
      "name": "pageBlockPhoto",
      "description": [
        "A photo"
      ],
      "fields": {
        "caption": "Caption",
        "flags": "Flags, see TL conditional fields",
        "photo_id": "Photo ID",
        "url": "HTTP URL of page the photo leads to when clicked",
        "webpage_id": "ID of preview of the page the photo leads to when clicked"
      }
    },
    "pageBlockPreformatted": {
      "name": "pageBlockPreformatted",
      "description": [
        "Preformatted (\u003cpre\u003e text)"
      ],
      "fields": {
        "language": "Programming language of preformatted text",
        "text": "Text"
      }
    },
    "pageBlockPullquote": {
      "name": "pageBlockPullquote",
      "description": [
        "Pullquote"
      ],
      "fields": {
        "caption": "Caption",
        "text": "Text"
      }
    },
    "pageBlockRelatedArticles": {
      "name": "pageBlockRelatedArticles",
      "description": [
        "Related articles"
      ],
      "fields": {
        "articles": "Related articles",
        "title": "Title"
      }
    },
    "pageBlockSlideshow": {
      "name": "pageBlockSlideshow",
      "description": [
        "Slideshow"
      ],
      "fields": {
        "caption": "Caption",
        "items": "Slideshow items"
      }
    },
    "pageBlockSubheader": {
      "name": "pageBlockSubheader",
      "description": [
        "Subheader"
      ],
      "fields": {
        "text": "Subheader"
      }
    },
    "pageBlockSubtitle": {
      "name": "pageBlockSubtitle",
      "description": [
        "Subtitle"
      ],
      "fields": {
        "text": "Text"
      }
    },
    "pageBlockTable": {
      "name": "pageBlockTable",
      "description": [
        "Table"
      ],
      "fields": {
        "bordered": "Does the table have a visible border?",
        "flags": "Flags, see TL conditional fields",
        "rows": "Table rows",
        "striped": "Is the table striped?",
        "title": "Title"
      }
    },
    "pageBlockTitle": {
      "name": "pageBlockTitle",
      "description": [
        "Title"
      ],
      "fields": {
        "text": "Title"
      }
    },
    "pageBlockUnsupported": {
      "name": "pageBlockUnsupported",
      "description": [
        "Unsupported IV element"
      ]
    },
    "pageBlockVideo": {
      "name": "pageBlockVideo",
      "description": [
        "Video"
      ],
      "fields": {
        "autoplay": "Whether the video is set to autoplay",
        "caption": "Caption",
        "flags": "Flags, see TL conditional fields",
        "loop": "Whether the video is set to loop",
        "video_id": "Video ID"
      }
    },
    "pageCaption": {
      "name": "pageCaption",
      "description": [
        "Page caption"
      ],
      "fields": {
        "credit": "Credits",
        "text": "Caption"
      }
    },
    "pageListItemBlocks": {
      "name": "pageListItemBlocks",
      "description": [
        "List item"
      ],
      "fields": {
        "blocks": "Blocks"
      }
    },
    "pageListItemText": {
      "name": "pageListItemText",
      "description": [
        "List item"
      ],
      "fields": {
        "text": "Text"
      }
    },
    "pageListOrderedItemBlocks": {
      "name": "pageListOrderedItemBlocks",
      "description": [
        "Ordered list of IV blocks"
      ],
      "fields": {
        "blocks": "Item contents",
        "num": "Number of element within ordered list"
      }
    },
    "pageListOrderedItemText": {
      "name": "pageListOrderedItemText",
      "description": [
        "Ordered list of text items"
      ],
      "fields": {
        "num": "Number of element within ordered list",
        "text": "Text"
      }
    },
    "pageRelatedArticle": {
      "name": "pageRelatedArticle",
      "description": [
        "Related article"
      ],
      "fields": {
        "author": "Author name",
        "description": "Description",
        "flags": "Flags, see TL conditional fields",
        "photo_id": "ID of preview photo",
        "published_date": "Date of pubblication",
        "title": "Title",
        "url": "URL of article",
        "webpage_id": "Webpage ID of generated IV preview"
      }
    },
    "pageTableCell": {
      "name": "pageTableCell",
      "description": [
        "Table cell"
      ],
      "fields": {
        "align_center": "Horizontally centered block",
        "align_right": "Right-aligned block",
        "colspan": "For how many columns should this cell extend",
        "flags": "Flags, see TL conditional fields",
        "header": "Is this element part of the column header",
        "rowspan": "For how many rows should this cell extend",
        "text": "Content",
        "valign_bottom": "Block vertically-alligned to the bottom",
        "valign_middle": "Vertically centered block"
      }
    },
    "pageTableRow": {
      "name": "pageTableRow",
      "description": [
        "Table row"
      ],
      "fields": {
        "cells": "Table cells"
      }
    },
    "passwordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow": {
      "name": "passwordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow",
      "description": [
        "This key derivation algorithm defines that SRP 2FA login must be used"
      ],
      "fields": {
        "g": "Base (see SRP 2FA login)",
        "p": "2048-bit modulus (see SRP 2FA login)",
        "salt1": "One of two salts used by the derivation function (see SRP 2FA login)",
        "salt2": "One of two salts used by the derivation function (see SRP 2FA login)"
      }
    },
    "passwordKdfAlgoUnknown": {
      "name": "passwordKdfAlgoUnknown",
      "description": [
        "Unknown KDF (most likely, the client is outdated and does not support the specified KDF algorithm)"
      ]
    },
    "paymentCharge": {
      "name": "paymentCharge",
      "description": [
        "Payment identifier"
      ],
      "fields": {
        "id": "Telegram payment identifier",
        "provider_charge_id": "Provider payment identifier"
      }
    },
    "paymentRequestedInfo": {
      "name": "paymentRequestedInfo",
      "description": [
        "Order info provided by the user"
      ],
      "fields": {
        "email": "User's email address",
        "flags": "Flags, see TL conditional fields",
        "name": "User's full name",
        "phone": "User's phone number",
        "shipping_address": "User's shipping address"
      }
    },
    "paymentSavedCredentialsCard": {
      "name": "paymentSavedCredentialsCard",
      "description": [
        "Saved credit card"
      ],
      "fields": {
        "id": "Card ID",
        "title": "Title"
      }
    },
    "payments.ValidatedRequestedInfo": {
      "name": "payments.ValidatedRequestedInfo",
      "description": [
        "Validated user-provided info"
      ],
      "fields": {
        "flags": "Flags, see TL conditional fields",
        "id": "ID",
        "shipping_options": "Shipping options"
      }
    },
    "payments.bankCardData": {
      "name": "payments.bankCardData",
      "description": [
        "Credit card info, provided by the card's bank(s)"
      ],
      "fields": {
        "open_urls": "Info URL(s) provided by the card's bank(s)",
        "title": "Credit card title"
      }
    },
    "payments.paymentForm": {
      "name": "payments.paymentForm",
      "description": [
        "Payment form"
      ],
      "fields": {
        "bot_id": "Bot ID",
        "can_save_credentials": "Whether the user can choose to save credentials.",
        "flags": "Flags, see TL conditional fields",
        "invoice": "Invoice",
        "native_params": "Contains information about the payment provider, if available, to support it natively without the need for opening the URL.A JSON object that can contain the following fields:- publishable_key: Stripe API publishable key- apple_pay_merchant_id: Apple Pay merchant ID- android_pay_public_key: Android Pay public key- android_pay_bgcolor: Android Pay form background color- android_pay_inverse: Whether to use the dark theme in the Android Pay form- need_country: True, if the user country must be provided,- need_zip: True, if the user ZIP/postal code must be provided,- need_cardholder_name: True, if the cardholder name must be provided",
        "native_provider": "Payment provider name.One of the following:- stripe",
        "password_missing": "Indicates that the user can save payment credentials, but only after setting up a 2FA password (currently the account doesn't have a 2FA password)",
        "provider_id": "Payment provider ID.",
        "saved_credentials": "Contains information about saved card credentials",
        "saved_info": "Saved server-side order information",
        "url": "Payment form URL",
        "users": "Users"
      }
    },
    "payments.paymentReceipt": {
      "name": "payments.paymentReceipt",
      "description": [
        "Receipt"
      ],
      "fields": {
        "bot_id": "Bot ID",
        "credentials_title": "Payment credential name",
        "currency": "Three-letter ISO 4217 currency code",
        "date": "Date of generation",
        "flags": "Flags, see TL conditional fields",
        "info": "Info",
        "invoice": "Invoice",
        "provider_id": "Provider ID",
        "shipping": "Selected shipping option",
        "total_amount": "Total amount in the smallest units of the currency (integer, not float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies).",
        "users": "Users"
      }
    },
    "payments.paymentResult": {
      "name": "payments.paymentResult",
      "description": [
        "Payment result"
      ],
      "fields": {
        "updates": "Info about the payment"
      }
    },
    "payments.paymentVerificationNeeded": {
      "name": "payments.paymentVerificationNeeded",
      "description": [
        "Payment was not successful, additional verification is needed"
      ],
      "fields": {
        "url": "URL for additional payment credentials verification"
      }
    },
    "payments.savedInfo": {
      "name": "payments.savedInfo",
      "description": [
        "Saved server-side order information"
      ],
      "fields": {
        "flags": "Flags, see TL conditional fields",
        "has_saved_credentials": "Whether the user has some saved payment credentials",
        "saved_info": "Saved server-side order information"
      }
    },
    "peerBlocked": {
      "name": "peerBlocked",
      "description": [
        "Information about a blocked peer"
      ],
      "fields": {
        "date": "When was the peer blocked",
        "peer_id": "Peer ID"
      }
    },
    "peerChannel": {
      "name": "peerChannel",
      "description": [
        "Channel/supergroup"
      ],
      "fields": {
        "channel_id": "Channel ID"
      }
    },
    "peerChat": {
      "name": "peerChat",
      "description": [
        "Group."
      ],
      "fields": {
        "chat_id": "Group identifier"
      }
    },
    "peerLocated": {
      "name": "peerLocated",
      "description": [
        "Peer geolocated nearby"
      ],
      "fields": {
        "distance": "Distance from the peer in meters",
        "expires": "Validity period of current data",
        "peer": "Peer"
      }
    },
    "peerNotifySettings": {
      "name": "peerNotifySettings",
      "description": [
        "Notification settings."
      ],
      "fields": {
        "flags": "Flags, see TL conditional fields",
        "mute_until": "Mute all notifications until this date",
        "show_previews": "Display text in notifications",
        "silent": "Mute peer?",
        "sound": "Audio file name for notifications"
      }
    },
    "peerSelfLocated": {
      "name": "peerSelfLocated",
      "description": [
        "Current peer"
      ],
      "fields": {
        "expires": "Expiry of geolocation info for current peer"
      }
    },
    "peerSettings": {
      "name": "peerSettings",
      "description": [
        "Peer settings"
      ],
      "fields": {
        "add_contact": "Whether we can add the user as contact",
        "autoarchived": "Whether this peer was automatically archived according to privacy settings",
        "block_contact": "Whether we can block the user",
        "flags": "Flags, see TL conditional fields",
        "geo_distance": "Distance in meters between us and this peer",
        "need_contacts_exception": "Whether a special exception for contacts is needed",
        "report_geo": "Whether we can report a geogroup is irrelevant for this location",
        "report_spam": "Whether we can still report the user for spam",
        "share_contact": "Whether we can share the user's contact"
      }
    },
    "peerUser": {
      "name": "peerUser",
      "description": [
        "Chat partner"
      ],
      "fields": {
        "user_id": "User identifier"
      }
    },
    "phone.phoneCall": {
      "name": "phone.phoneCall",
      "description": [
        "A VoIP phone call"
      ],
      "fields": {
        "phone_call": "The VoIP phone call",
        "users": "VoIP phone call participants"
      }
    },
    "phoneCall": {
      "name": "phoneCall",
      "description": [
        "Phone call"
      ],
      "fields": {
        "access_hash": "Access hash",
        "admin_id": "User ID of the creator of the call",
        "connections": "List of endpoints the user can connect to to exchange call data",
        "date": "Date of creation of the call",
        "flags": "Flags, see TL conditional fields",
        "g_a_or_b": "Parameter for key exchange",
        "id": "Call ID",
        "key_fingerprint": "Key fingerprint",
        "p2p_allowed": "Whether P2P connection to the other peer is allowed",
        "participant_id": "User ID of the other participant in the call",
        "protocol": "Call protocol info to be passed to libtgvoip",
        "start_date": "When was the call actually started",
        "video": "Whether this is a video call"
      }
    },
    "phoneCallAccepted": {
      "name": "phoneCallAccepted",
      "description": [
        "An accepted phone call"
      ],
      "fields": {
        "access_hash": "Access hash of phone call",
        "admin_id": "ID of the call creator",
        "date": "When was the call accepted",
        "flags": "Flags, see TL conditional fields",
        "g_b": "B parameter for secure E2E phone call key exchange",
        "id": "ID of accepted phone call",
        "participant_id": "ID of the other user in the call",
        "protocol": "Protocol to use for phone call",
        "video": "Whether this is a video call"
      }
    },
    "phoneCallDiscardReasonBusy": {
      "name": "phoneCallDiscardReasonBusy",
      "description": [
        "The phone call was discared because the user is busy in another call"
      ]
    },
    "phoneCallDiscardReasonDisconnect": {
      "name": "phoneCallDiscardReasonDisconnect",
      "description": [
        "The phone call was disconnected"
      ]
    },
    "phoneCallDiscardReasonHangup": {
      "name": "phoneCallDiscardReasonHangup",
      "description": [
        "The phone call was ended normally"
      ]
    },
    "phoneCallDiscardReasonMissed": {
      "name": "phoneCallDiscardReasonMissed",
      "description": [
        "The phone call was missed"
      ]
    },
    "phoneCallDiscarded": {
      "name": "phoneCallDiscarded",
      "description": [
        "Indicates a discarded phone call"
      ],
      "fields": {
        "duration": "Duration of the phone call in seconds",
        "flags": "Flags, see TL conditional fields",
        "id": "Call ID",
        "need_debug": "Whether the server required the client to send the libtgvoip call debug data",
        "need_rating": "Whether the server required the user to rate the call",
        "reason": "Why was the phone call discarded",
        "video": "Whether the call was a video call"
      }
    },
    "phoneCallEmpty": {
      "name": "phoneCallEmpty",
      "description": [
        "Empty constructor"
      ],
      "fields": {
        "id": "Call ID"
      }
    },
    "phoneCallProtocol": {
      "name": "phoneCallProtocol",
      "description": [
        "Protocol info for libtgvoip"
      ],
      "fields": {
        "flags": "Flags, see TL conditional fields",
        "library_versions": "When using phone.requestCall and phone.acceptCall, specify all library versions supported by the client. The server will merge and choose the best library version supported by both peers, returning only the best value in the result of the callee's phone.acceptCall and in the phoneCallAccepted update received by the caller.",
        "max_layer": "Maximum layer for remote libtgvoip",
        "min_layer": "Minimum layer for remote libtgvoip",
        "udp_p2p": "Whether to allow P2P connection to the other participant",
        "udp_reflector": "Whether to allow connection to the other participants through the reflector servers"
      }
    },
    "phoneCallRequested": {
      "name": "phoneCallRequested",
      "description": [
        "Requested phone call"
      ],
      "fields": {
        "access_hash": "Access hash",
        "admin_id": "ID of the creator of the phone call",
        "date": "When was the phone call created",
        "flags": "Flags, see TL conditional fields",
        "g_a_hash": "Parameter for key exchange",
        "id": "Phone call ID",
        "participant_id": "ID of the other participant of the phone call",
        "protocol": "Call protocol info to be passed to libtgvoip",
        "video": "Whether this is a video call"
      }
    },
    "phoneCallWaiting": {
      "name": "phoneCallWaiting",
      "description": [
        "Incoming phone call"
      ],
      "fields": {
        "access_hash": "Access hash",
        "admin_id": "Admin ID",
        "date": "Date",
        "flags": "Flags, see TL conditional fields",
        "id": "Call ID",
        "participant_id": "Participant ID",
        "protocol": "Phone call protocol info",
        "receive_date": "When was the phone call received",
        "video": "Is this a video call"
      }
    },
    "phoneConnection": {
      "name": "phoneConnection",
      "description": [
        "Identifies an endpoint that can be used to connect to the other user in a phone call"
      ],
      "fields": {
        "id": "Endpoint ID",
        "ip": "IP address of endpoint",
        "ipv6": "IPv6 address of endpoint",
        "peer_tag": "Our peer tag",
        "port": "Port ID"
      }
    },
    "phoneConnectionWebrtc": {
      "name": "phoneConnectionWebrtc",
      "description": [
        "WebRTC connection parameters"
      ],
      "fields": {
        "flags": "Flags, see TL conditional fields",
        "id": "Endpoint ID",
        "ip": "IP address",
        "ipv6": "IPv6 address",
        "password": "Password",
        "port": "Port",
        "stun": "Whether this is a STUN endpoint",
        "turn": "Whether this is a TURN endpoint",
        "username": "Username"
      }
    },
    "photo": {
      "name": "photo",
      "description": [
        "Photo"
      ],
      "fields": {
        "access_hash": "Access hash",
        "date": "Date of upload",
        "dc_id": "DC ID to use for download",
        "file_reference": "file reference",
        "flags": "Flags, see TL conditional fields",
        "has_stickers": "Whether the photo has mask stickers attached to it",
        "id": "ID",
        "sizes": "Available sizes for download",
        "video_sizes": "For animated profiles, the MPEG4 videos"
      }
    },
    "photoCachedSize": {
      "name": "photoCachedSize",
      "description": [
        "Description of an image and its content."
      ],
      "fields": {
        "bytes": "Binary data, file content",
        "h": "Image height",
        "location": "File location",
        "type": "Thumbnail type",
        "w": "Image width"
      }
    },
    "photoEmpty": {
      "name": "photoEmpty",
      "description": [
        "Empty constructor, non-existent photo"
      ],
      "fields": {
        "id": "Photo identifier"
      }
    },
    "photoPathSize": {
      "name": "photoPathSize",
      "description": [
        "Messages with animated stickers can have a compressed svg (\u003c 300 bytes) to show the outline of the sticker before fetching the actual lottie animation."
      ],
      "fields": {
        "bytes": "Compressed SVG path payload, see here for decompression instructions",
        "type": "Always j"
      }
    },
    "photoSize": {
      "name": "photoSize",
      "description": [
        "Image description."
      ],
      "fields": {
        "h": "Image height",
        "location": "File location",
        "size": "File size",
        "type": "Thumbnail type",
        "w": "Image width"
      }
    },
    "photoSizeEmpty": {
      "name": "photoSizeEmpty",
      "description": [
        "Empty constructor. Image with this thumbnail is unavailable."
      ],
      "fields": {
        "type": "Thumbnail type (see. photoSize)"
      }
    },
    "photoSizeProgressive": {
      "name": "photoSizeProgressive",
      "description": [
        "Progressively encoded photosize"
      ],
      "fields": {
        "h": "Photo height",
        "location": "File location",
        "sizes": "Sizes of progressive JPEG file prefixes, which can be used to preliminarily show the image.",
        "type": "Photosize type",
        "w": "Photo width"
      }
    },
    "photoStrippedSize": {
      "name": "photoStrippedSize",
      "description": [
        "A low-resolution compressed JPG payload"
      ],
      "fields": {
        "bytes": "Thumbnail data, see here for more info on decompression ",
        "type": "Thumbnail type"
      }
    },
    "photos.photo": {
      "name": "photos.photo",
      "description": [
        "Photo with auxiliary data."
      ],
      "fields": {
        "photo": "Photo",
        "users": "Users"
      }
    },
    "photos.photos": {
      "name": "photos.photos",
      "description": [
        "Full list of photos with auxiliary data."
      ],
      "fields": {
        "photos": "List of photos",
        "users": "List of mentioned users"
      }
    },
    "photos.photosSlice": {
      "name": "photos.photosSlice",
      "description": [
        "Incomplete list of photos with auxiliary data."
      ],
      "fields": {
        "count": "Total number of photos",
        "photos": "List of photos",
        "users": "List of mentioned users"
      }
    },
    "poll": {
      "name": "poll",
      "description": [
        "Poll"
      ],
      "fields": {
        "answers": "The possible answers, vote using messages.sendVote.",
        "close_date": "Point in time (Unix timestamp) when the poll will be automatically closed. Must be at least 5 and no more than 600 seconds in the future; can't be used together with close_period.",
        "close_period": "Amount of time in seconds the poll will be active after creation, 5-600. Can't be used together with close_date.",
        "closed": "Whether the poll is closed and doesn't accept any more answers",
        "flags": "Flags, see TL conditional fields",
        "id": "ID of the poll",
        "multiple_choice": "Whether multiple options can be chosen as answer",
        "public_voters": "Whether cast votes are publicly visible to all users (non-anonymous poll)",
        "question": "The question of the poll",
        "quiz": "Whether this is a quiz (with wrong and correct answers, results shown in the return type)"
      }
    },
    "pollAnswer": {
      "name": "pollAnswer",
      "description": [
        "A possible answer of a poll"
      ],
      "fields": {
        "option": "The param that has to be passed to messages.sendVote.",
        "text": "Textual representation of the answer"
      }
    },
    "pollAnswerVoters": {
      "name": "pollAnswerVoters",
      "description": [
        "A poll answer, and how users voted on it"
      ],
      "fields": {
        "chosen": "Whether we have chosen this answer",
        "correct": "For quizes, whether the option we have chosen is correct",
        "flags": "Flags, see TL conditional fields",
        "option": "The param that has to be passed to messages.sendVote.",
        "voters": "How many users voted for this option"
      }
    },
    "pollResults": {
      "name": "pollResults",
      "description": [
        "Results of poll"
      ],
      "fields": {
        "flags": "Flags, see TL conditional fields",
        "min": "Similar to min objects, used for poll constructors that are the same for all users so they don't have option chosen by the current user (you can use messages.getPollResults to get the full poll results).",
        "recent_voters": "IDs of the last users that recently voted in the poll",
        "results": "Poll results",
        "solution": "Explanation of quiz solution",
        "solution_entities": "Message entities for styled text in quiz solution",
        "total_voters": "Total number of people that voted in the poll"
      }
    },
    "popularContact": {
      "name": "popularContact",
      "description": [
        "Popular contact"
      ],
      "fields": {
        "client_id": "Contact identifier",
        "importers": "How many people imported this contact"
      }
    },
    "postAddress": {
      "name": "postAddress",
      "description": [
        "Shipping address"
      ],
      "fields": {
        "city": "City",
        "country_iso2": "ISO 3166-1 alpha-2 country code",
        "post_code": "Address post code",
        "state": "State, if applicable (empty otherwise)",
        "street_line1": "First line for the address",
        "street_line2": "Second line for the address"
      }
    },
    "privacyKeyAddedByPhone": {
      "name": "privacyKeyAddedByPhone",
      "description": [
        "Whether people can add you to their contact list by your phone number"
      ]
    },
    "privacyKeyChatInvite": {
      "name": "privacyKeyChatInvite",
      "description": [
        "Whether the user can be invited to chats"
      ]
    },
    "privacyKeyForwards": {
      "name": "privacyKeyForwards",
      "description": [
        "Whether messages forwarded from the user will be anonymously forwarded"
      ]
    },
    "privacyKeyPhoneCall": {
      "name": "privacyKeyPhoneCall",
      "description": [
        "Whether the user accepts phone calls"
      ]
    },
    "privacyKeyPhoneNumber": {
      "name": "privacyKeyPhoneNumber",
      "description": [
        "Whether the user allows us to see his phone number"
      ]
    },
    "privacyKeyPhoneP2P": {
      "name": "privacyKeyPhoneP2P",
      "description": [
        "Whether P2P connections in phone calls are allowed"
      ]
    },
    "privacyKeyProfilePhoto": {
      "name": "privacyKeyProfilePhoto",
      "description": [
        "Whether the profile picture of the user is visible"
      ]
    },
    "privacyKeyStatusTimestamp": {
      "name": "privacyKeyStatusTimestamp",
      "description": [
        "Whether we can see the last online timestamp"
      ]
    },
    "privacyValueAllowAll": {
      "name": "privacyValueAllowAll",
      "description": [
        "Allow all users"
      ]
    },
    "privacyValueAllowChatParticipants": {
      "name": "privacyValueAllowChatParticipants",
      "description": [
        "Allow all participants of certain chats"
      ],
      "fields": {
        "chats": "Allowed chats"
      }
    },
    "privacyValueAllowContacts": {
      "name": "privacyValueAllowContacts",
      "description": [
        "Allow all contacts"
      ]
    },
    "privacyValueAllowUsers": {
      "name": "privacyValueAllowUsers",
      "description": [
        "Allow only certain users"
      ],
      "fields": {
        "users": "Allowed users"
      }
    },
    "privacyValueDisallowAll": {
      "name": "privacyValueDisallowAll",
      "description": [
        "Disallow all users"
      ]
    },
    "privacyValueDisallowChatParticipants": {
      "name": "privacyValueDisallowChatParticipants",
      "description": [
        "Disallow only participants of certain chats"
      ],
      "fields": {
        "chats": "Disallowed chats"
      }
    },
    "privacyValueDisallowContacts": {
      "name": "privacyValueDisallowContacts",
      "description": [
        "Disallow only contacts"
      ]
    },
    "privacyValueDisallowUsers": {
      "name": "privacyValueDisallowUsers",
      "description": [
        "Disallow only certain users"
      ],
      "fields": {
        "users": "Disallowed users"
      }
    },
    "receivedNotifyMessage": {
      "name": "receivedNotifyMessage",
      "description": [
        "Message ID, for which PUSH-notifications were cancelled."
      ],
      "fields": {
        "flags": "Reserved for future use",
        "id": "Message ID, for which PUSH-notifications were canceled"
      }
    },
    "recentMeUrlChat": {
      "name": "recentMeUrlChat",
      "description": [
        "Recent t.me link to a chat"
      ],
      "fields": {
        "chat_id": "Chat ID",
        "url": "t.me URL"
      }
    },
    "recentMeUrlChatInvite": {
      "name": "recentMeUrlChatInvite",
      "description": [
        "Recent t.me invite link to a chat"
      ],
      "fields": {
        "chat_invite": "Chat invitation",
        "url": "t.me URL"
      }
    },
    "recentMeUrlStickerSet": {
      "name": "recentMeUrlStickerSet",
      "description": [
        "Recent t.me stickerset installation URL"
      ],
      "fields": {
        "set": "Stickerset",
        "url": "t.me URL"
      }
    },
    "recentMeUrlUnknown": {
      "name": "recentMeUrlUnknown",
      "description": [
        "Unknown t.me url"
      ],
      "fields": {
        "url": "URL"
      }
    },
    "recentMeUrlUser": {
      "name": "recentMeUrlUser",
      "description": [
        "Recent t.me link to a user"
      ],
      "fields": {
        "url": "URL",
        "user_id": "User ID"
      }
    },
    "replyInlineMarkup": {
      "name": "replyInlineMarkup",
      "description": [
        "Bot or inline keyboard"
      ],
      "fields": {
        "rows": "Bot or inline keyboard rows"
      }
    },
    "replyKeyboardForceReply": {
      "name": "replyKeyboardForceReply",
      "description": [
        "Force the user to send a reply"
      ],
      "fields": {
        "flags": "Flags, see TL conditional fields",
        "selective": "Use this parameter if you want to show the keyboard to specific users only. Targets: 1) users that are @mentioned in the text of the Message object; 2) if the bot's message is a reply (has reply_to_message_id), sender of the original message. Example: A user requests to change the bots language, bot replies to the request with a keyboard to select the new language. Other users in the group dont see the keyboard.",
        "single_use": "Requests clients to hide the keyboard as soon as it's been used. The keyboard will still be available, but clients will automatically display the usual letter-keyboard in the chat  the user can press a special button in the input field to see the custom keyboard again."
      }
    },
    "replyKeyboardHide": {
      "name": "replyKeyboardHide",
      "description": [
        "Hide sent bot keyboard"
      ],
      "fields": {
        "flags": "Flags, see TL conditional fields",
        "selective": "Use this flag if you want to remove the keyboard for specific users only. Targets: 1) users that are @mentioned in the text of the Message object; 2) if the bot's message is a reply (has reply_to_message_id), sender of the original message.Example: A user votes in a poll, bot returns confirmation message in reply to the vote and removes the keyboard for that user, while still showing the keyboard with poll options to users who haven't voted yet"
      }
    },
    "replyKeyboardMarkup": {
      "name": "replyKeyboardMarkup",
      "description": [
        "Bot keyboard"
      ],
      "fields": {
        "flags": "Flags, see TL conditional fields",
        "resize": "Requests clients to resize the keyboard vertically for optimal fit (e.g., make the keyboard smaller if there are just two rows of buttons). If not set, the custom keyboard is always of the same height as the app's standard keyboard.",
        "rows": "Button row",
        "selective": "Use this parameter if you want to show the keyboard to specific users only. Targets: 1) users that are @mentioned in the text of the Message object; 2) if the bot's message is a reply (has reply_to_message_id), sender of the original message.Example: A user requests to change the bots language, bot replies to the request with a keyboard to select the new language. Other users in the group dont see the keyboard.",
        "single_use": "Requests clients to hide the keyboard as soon as it's been used. The keyboard will still be available, but clients will automatically display the usual letter-keyboard in the chat  the user can press a special button in the input field to see the custom keyboard again."
      }
    },
    "restrictionReason": {
      "name": "restrictionReason",
      "description": [
        "Restriction reason.",
        "Contains the reason why access to a certain object must be restricted. Clients are supposed to deny access to the channel if the platform field is equal to all or to the current platform (ios, android, wp, etc.). Platforms can be concatenated (ios-android, ios-wp), unknown platforms are to be ignored. The text is the error message that should be shown to the user."
      ],
      "fields": {
        "platform": "Platform identifier (ios, android, wp, all, etc.), can be concatenated with a dash as separator (android-ios, ios-wp, etc)",
        "reason": "Restriction reason (porno, terms, etc.)",
        "text": "Error message to be shown to the user"
      }
    },
    "savedPhoneContact": {
      "name": "savedPhoneContact",
      "description": [
        "Saved contact"
      ],
      "fields": {
        "date": "Date added",
        "first_name": "First name",
        "last_name": "Last name",
        "phone": "Phone number"
      }
    },
    "secureCredentialsEncrypted": {
      "name": "secureCredentialsEncrypted",
      "description": [
        "Encrypted credentials required to decrypt telegram passport data."
      ],
      "fields": {
        "data": "Encrypted JSON-serialized data with unique user's payload, data hashes and secrets required for EncryptedPassportElement decryption and authentication, as described in decrypting data ",
        "hash": "Data hash for data authentication as described in decrypting data ",
        "secret": "Secret, encrypted with the bot's public RSA key, required for data decryption as described in decrypting data "
      }
    },
    "secureData": {
      "name": "secureData",
      "description": [
        "Secure passport data, for more info see the passport docs "
      ],
      "fields": {
        "data": "Data",
        "data_hash": "Data hash",
        "secret": "Secret"
      }
    },
    "secureFile": {
      "name": "secureFile",
      "description": [
        "Secure passport file, for more info see the passport docs "
      ],
      "fields": {
        "access_hash": "Access hash",
        "date": "Date of upload",
        "dc_id": "DC ID",
        "file_hash": "File hash",
        "id": "ID",
        "secret": "Secret",
        "size": "File size"
      }
    },
    "secureFileEmpty": {
      "name": "secureFileEmpty",
      "description": [
        "Empty constructor"
      ]
    },
    "securePasswordKdfAlgoPBKDF2HMACSHA512iter100000": {
      "name": "securePasswordKdfAlgoPBKDF2HMACSHA512iter100000",
      "description": [
        "PBKDF2 with SHA512 and 100000 iterations KDF algo"
      ],
      "fields": {
        "salt": "Salt"
      }
    },
    "securePasswordKdfAlgoSHA512": {
      "name": "securePasswordKdfAlgoSHA512",
      "description": [
        "SHA512 KDF algo"
      ],
      "fields": {
        "salt": "Salt"
      }
    },
    "securePasswordKdfAlgoUnknown": {
      "name": "securePasswordKdfAlgoUnknown",
      "description": [
        "Unknown KDF algo (most likely the client has to be updated)"
      ]
    },
    "securePlainEmail": {
      "name": "securePlainEmail",
      "description": [
        "Email address to use in telegram passport: it must be verified, first ."
      ],
      "fields": {
        "email": "Email address"
      }
    },
    "securePlainPhone": {
      "name": "securePlainPhone",
      "description": [
        "Phone number to use in telegram passport: it must be verified, first ."
      ],
      "fields": {
        "phone": "Phone number"
      }
    },
    "secureRequiredType": {
      "name": "secureRequiredType",
      "description": [
        "Required type"
      ],
      "fields": {
        "flags": "Flags, see TL conditional fields",
        "native_names": "Native names",
        "selfie_required": "Is a selfie required",
        "translation_required": "Is a translation required",
        "type": "Secure value type"
      }
    },
    "secureRequiredTypeOneOf": {
      "name": "secureRequiredTypeOneOf",
      "description": [
        "One of"
      ],
      "fields": {
        "types": "Secure required value types"
      }
    },
    "secureSecretSettings": {
      "name": "secureSecretSettings",
      "description": [
        "Secure settings"
      ],
      "fields": {
        "secure_algo": "Secure KDF algo",
        "secure_secret": "Secure secret",
        "secure_secret_id": "Secret ID"
      }
    },
    "secureValue": {
      "name": "secureValue",
      "description": [
        "Secure value"
      ],
      "fields": {
        "data": "Encrypted Telegram Passport element data",
        "files": "Array of encrypted passport files with photos the of the documents",
        "flags": "Flags, see TL conditional fields",
        "front_side": "Encrypted passport file with the front side of the document",
        "hash": "Data hash",
        "plain_data": "Plaintext verified passport data",
        "reverse_side": "Encrypted passport file with the reverse side of the document",
        "selfie": "Encrypted passport file with a selfie of the user holding the document",
        "translation": "Array of encrypted passport files with translated versions of the provided documents",
        "type": "Secure passport value type"
      }
    },
    "secureValueError": {
      "name": "secureValueError",
      "description": [
        "Secure value error"
      ],
      "fields": {
        "hash": "Hash",
        "text": "Error message",
        "type": "Type of element which has the issue"
      }
    },
    "secureValueErrorData": {
      "name": "secureValueErrorData",
      "description": [
        "Represents an issue in one of the data fields that was provided by the user. The error is considered resolved when the field's value changes."
      ],
      "fields": {
        "data_hash": "Data hash",
        "field": "Name of the data field which has the error",
        "text": "Error message",
        "type": "The section of the user's Telegram Passport which has the error, one of secureValueTypePersonalDetails, secureValueTypePassport, secureValueTypeDriverLicense, secureValueTypeIdentityCard, secureValueTypeInternalPassport, secureValueTypeAddress"
      }
    },
    "secureValueErrorFile": {
      "name": "secureValueErrorFile",
      "description": [
        "Represents an issue with a document scan. The error is considered resolved when the file with the document scan changes."
      ],
      "fields": {
        "file_hash": "File hash",
        "text": "Error message",
        "type": "One of secureValueTypeUtilityBill, secureValueTypeBankStatement, secureValueTypeRentalAgreement, secureValueTypePassportRegistration, secureValueTypeTemporaryRegistration"
      }
    },
    "secureValueErrorFiles": {
      "name": "secureValueErrorFiles",
      "description": [
        "Represents an issue with a list of scans. The error is considered resolved when the list of files containing the scans changes."
      ],
      "fields": {
        "file_hash": "File hash",
        "text": "Error message",
        "type": "One of secureValueTypeUtilityBill, secureValueTypeBankStatement, secureValueTypeRentalAgreement, secureValueTypePassportRegistration, secureValueTypeTemporaryRegistration"
      }
    },
    "secureValueErrorFrontSide": {
      "name": "secureValueErrorFrontSide",
      "description": [
        "Represents an issue with the front side of a document. The error is considered resolved when the file with the front side of the document changes."
      ],
      "fields": {
        "file_hash": "File hash",
        "text": "Error message",
        "type": "One of secureValueTypePassport, secureValueTypeDriverLicense, secureValueTypeIdentityCard, secureValueTypeInternalPassport"
      }
    },
    "secureValueErrorReverseSide": {
      "name": "secureValueErrorReverseSide",
      "description": [
        "Represents an issue with the reverse side of a document. The error is considered resolved when the file with reverse side of the document changes."
      ],
      "fields": {
        "file_hash": "File hash",
        "text": "Error message",
        "type": "One of secureValueTypeDriverLicense, secureValueTypeIdentityCard"
      }
    },
    "secureValueErrorSelfie": {
      "name": "secureValueErrorSelfie",
      "description": [
        "Represents an issue with the selfie with a document. The error is considered resolved when the file with the selfie changes."
      ],
      "fields": {
        "file_hash": "File hash",
        "text": "Error message",
        "type": "One of secureValueTypePassport, secureValueTypeDriverLicense, secureValueTypeIdentityCard, secureValueTypeInternalPassport"
      }
    },
    "secureValueErrorTranslationFile": {
      "name": "secureValueErrorTranslationFile",
      "description": [
        "Represents an issue with one of the files that constitute the translation of a document. The error is considered resolved when the file changes."
      ],
      "fields": {
        "file_hash": "File hash",
        "text": "Error message",
        "type": "One of secureValueTypePersonalDetails, secureValueTypePassport, secureValueTypeDriverLicense, secureValueTypeIdentityCard, secureValueTypeInternalPassport, secureValueTypeUtilityBill, secureValueTypeBankStatement, secureValueTypeRentalAgreement, secureValueTypePassportRegistration, secureValueTypeTemporaryRegistration"
      }
    },
    "secureValueErrorTranslationFiles": {
      "name": "secureValueErrorTranslationFiles",
      "description": [
        "Represents an issue with the translated version of a document. The error is considered resolved when a file with the document translation changes."
      ],
      "fields": {
        "file_hash": "Hash",
        "text": "Error message",
        "type": "One of secureValueTypePersonalDetails, secureValueTypePassport, secureValueTypeDriverLicense, secureValueTypeIdentityCard, secureValueTypeInternalPassport, secureValueTypeUtilityBill, secureValueTypeBankStatement, secureValueTypeRentalAgreement, secureValueTypePassportRegistration, secureValueTypeTemporaryRegistration"
      }
    },
    "secureValueHash": {
      "name": "secureValueHash",
      "description": [
        "Secure value hash"
      ],
      "fields": {
        "hash": "Hash",
        "type": "Secure value type"
      }
    },
    "secureValueTypeAddress": {
      "name": "secureValueTypeAddress",
      "description": [
        "Address"
      ]
    },
    "secureValueTypeBankStatement": {
      "name": "secureValueTypeBankStatement",
      "description": [
        "Bank statement"
      ]
    },
    "secureValueTypeDriverLicense": {
      "name": "secureValueTypeDriverLicense",
      "description": [
        "Driver's license"
      ]
    },
    "secureValueTypeEmail": {
      "name": "secureValueTypeEmail",
      "description": [
        "Email"
      ]
    },
    "secureValueTypeIdentityCard": {
      "name": "secureValueTypeIdentityCard",
      "description": [
        "Identity card"
      ]
    },
    "secureValueTypeInternalPassport": {
      "name": "secureValueTypeInternalPassport",
      "description": [
        "Internal passport"
      ]
    },
    "secureValueTypePassport": {
      "name": "secureValueTypePassport",
      "description": [
        "Passport"
      ]
    },
    "secureValueTypePassportRegistration": {
      "name": "secureValueTypePassportRegistration",
      "description": [
        "Internal registration passport"
      ]
    },
    "secureValueTypePersonalDetails": {
      "name": "secureValueTypePersonalDetails",
      "description": [
        "Personal details"
      ]
    },
    "secureValueTypePhone": {
      "name": "secureValueTypePhone",
      "description": [
        "Phone"
      ]
    },
    "secureValueTypeRentalAgreement": {
      "name": "secureValueTypeRentalAgreement",
      "description": [
        "Rental agreement"
      ]
    },
    "secureValueTypeTemporaryRegistration": {
      "name": "secureValueTypeTemporaryRegistration",
      "description": [
        "Temporary registration"
      ]
    },
    "secureValueTypeUtilityBill": {
      "name": "secureValueTypeUtilityBill",
      "description": [
        "Utility bill"
      ]
    },
    "sendMessageCancelAction": {
      "name": "sendMessageCancelAction",
      "description": [
        "Invalidate all previous action updates. E.g. when user deletes entered text or aborts a video upload."
      ]
    },
    "sendMessageChooseContactAction": {
      "name": "sendMessageChooseContactAction",
      "description": [
        "User is selecting a contact to share."
      ]
    },
    "sendMessageGamePlayAction": {
      "name": "sendMessageGamePlayAction",
      "description": [
        "User is playing a game"
      ]
    },
    "sendMessageGeoLocationAction": {
      "name": "sendMessageGeoLocationAction",
      "description": [
        "User is selecting a location to share."
      ]
    },
    "sendMessageRecordAudioAction": {
      "name": "sendMessageRecordAudioAction",
      "description": [
        "User is recording a voice message."
      ]
    },
    "sendMessageRecordRoundAction": {
      "name": "sendMessageRecordRoundAction",
      "description": [
        "User is recording a round video to share"
      ]
    },
    "sendMessageRecordVideoAction": {
      "name": "sendMessageRecordVideoAction",
      "description": [
        "User is recording a video."
      ]
    },
    "sendMessageTypingAction": {
      "name": "sendMessageTypingAction",
      "description": [
        "User is typing."
      ]
    },
    "sendMessageUploadAudioAction": {
      "name": "sendMessageUploadAudioAction",
      "description": [
        "User is uploading a voice message."
      ],
      "fields": {
        "progress": "Progress percentage"
      }
    },
    "sendMessageUploadDocumentAction": {
      "name": "sendMessageUploadDocumentAction",
      "description": [
        "User is uploading a file."
      ],
      "fields": {
        "progress": "Progress percentage"
      }
    },
    "sendMessageUploadPhotoAction": {
      "name": "sendMessageUploadPhotoAction",
      "description": [
        "User is uploading a photo."
      ],
      "fields": {
        "progress": "Progress percentage"
      }
    },
    "sendMessageUploadRoundAction": {
      "name": "sendMessageUploadRoundAction",
      "description": [
        "User is uploading a round video"
      ],
      "fields": {
        "progress": "Progress percentage"
      }
    },
    "sendMessageUploadVideoAction": {
      "name": "sendMessageUploadVideoAction",
      "description": [
        "User is uploading a video."
      ],
      "fields": {
        "progress": "Progress percentage"
      }
    },
    "shippingOption": {
      "name": "shippingOption",
      "description": [
        "Shipping option"
      ],
      "fields": {
        "id": "Option ID",
        "prices": "List of price portions",
        "title": "Title"
      }
    },
    "stats.broadcastStats": {
      "name": "stats.broadcastStats",
      "description": [
        "Channel statistics."
      ],
      "fields": {
        "enabled_notifications": "Percentage of subscribers with enabled notifications",
        "followers": "Follower count change for period in consideration",
        "followers_graph": "Followers growth graph (relative subscriber count)",
        "growth_graph": "Channel growth graph (absolute subscriber count)",
        "interactions_graph": "Interactions graph (absolute)",
        "iv_interactions_graph": "IV interactions graph (absolute)",
        "languages_graph": "Subscriber language graph (piechart)",
        "mute_graph": "Muted users graph (relative)",
        "new_followers_by_source_graph": "New followers by source graph (absolute)",
        "period": "Period in consideration",
        "recent_message_interactions": "Recent message interactions",
        "shares_per_post": "total_viewcount/postcount, for posts posted during the period in consideration (views_per_post). Note that in this case, current refers to the period in consideration (min_date till max_date), and prev refers to the previous period ((min_date - (max_date - min_date)) till min_date)",
        "top_hours_graph": "Views per hour graph (absolute)",
        "views_by_source_graph": "Views by source graph (absolute)",
        "views_per_post": "total_viewcount/postcount, for posts posted during the period in consideration (views_per_post). Note that in this case, current refers to the period in consideration (min_date till max_date), and prev refers to the previous period ((min_date - (max_date - min_date)) till min_date)."
      }
    },
    "stats.megagroupStats": {
      "name": "stats.megagroupStats",
      "description": [
        "Supergroup statistics"
      ],
      "fields": {
        "actions_graph": "Group activity graph (deleted, modified messages, blocked users)",
        "growth_graph": "Supergroup growth graph (absolute subscriber count)",
        "languages_graph": "Subscriber language graph (piechart)",
        "members": "Member count change for period in consideration",
        "members_graph": "Members growth (relative subscriber count)",
        "messages": "Message number change for period in consideration",
        "messages_graph": "Message activity graph (stacked bar graph, message type)",
        "new_members_by_source_graph": "New members by source graph",
        "period": "Period in consideration",
        "posters": "Number of users that posted messages, for range in consideration",
        "top_admins": "Info about most active group admins",
        "top_hours_graph": "Activity per hour graph (absolute)",
        "top_inviters": "Info about most active group inviters",
        "top_posters": "Info about most active group members",
        "users": "Info about users mentioned in statistics",
        "viewers": "Number of users that viewed messages, for range in consideration",
        "weekdays_graph": "Activity per day of week graph (absolute)"
      }
    },
    "stats.messageStats": {
      "name": "stats.messageStats",
      "description": [
        "Message statistics"
      ],
      "fields": {
        "views_graph": "Message view graph"
      }
    },
    "statsAbsValueAndPrev": {
      "name": "statsAbsValueAndPrev",
      "description": [
        "Statistics value couple; intial and final value for period of time currently in consideration"
      ],
      "fields": {
        "current": "Current value",
        "previous": "Previous value"
      }
    },
    "statsDateRangeDays": {
      "name": "statsDateRangeDays",
      "description": [
        "Channel statistics date range"
      ],
      "fields": {
        "max_date": "Final date",
        "min_date": "Initial date"
      }
    },
    "statsGraph": {
      "name": "statsGraph",
      "description": [
        "Channel statistics graph"
      ],
      "fields": {
        "flags": "Flags, see TL conditional fields",
        "json": "Statistics data",
        "zoom_token": "Zoom token"
      }
    },
    "statsGraphAsync": {
      "name": "statsGraphAsync",
      "description": [
        "This channel statistics graph must be generated asynchronously using stats.loadAsyncGraph to reduce server load"
      ],
      "fields": {
        "token": "Token to use for fetching the async graph"
      }
    },
    "statsGraphError": {
      "name": "statsGraphError",
      "description": [
        "An error occurred while generating the statistics graph"
      ],
      "fields": {
        "error": "The error"
      }
    },
    "statsGroupTopAdmin": {
      "name": "statsGroupTopAdmin",
      "description": [
        "Information about an active admin in a supergroup"
      ],
      "fields": {
        "banned": "Number of banned users for statistics period in consideration",
        "deleted": "Number of deleted messages for statistics period in consideration",
        "kicked": "Number of kicked users for statistics period in consideration",
        "user_id": "User ID"
      }
    },
    "statsGroupTopInviter": {
      "name": "statsGroupTopInviter",
      "description": [
        "Information about an active supergroup inviter"
      ],
      "fields": {
        "invitations": "Number of invitations for statistics period in consideration",
        "user_id": "User ID"
      }
    },
    "statsGroupTopPoster": {
      "name": "statsGroupTopPoster",
      "description": [
        "Information about an active user in a supergroup"
      ],
      "fields": {
        "avg_chars": "Average number of characters per message",
        "messages": "Number of messages for statistics period in consideration",
        "user_id": "User ID"
      }
    },
    "statsPercentValue": {
      "name": "statsPercentValue",
      "description": [
        "Channel statistics percentage.\nCompute the percentage simply by doing part * total / 100"
      ],
      "fields": {
        "part": "Partial value",
        "total": "Total value"
      }
    },
    "statsURL": {
      "name": "statsURL",
      "description": [
        "URL with chat statistics"
      ],
      "fields": {
        "url": "Chat statistics"
      }
    },
    "stickerPack": {
      "name": "stickerPack",
      "description": [
        "A stickerpack is a group of stickers associated to the same emoji.\nIt is not a sticker pack the way it is usually intended, you may be looking for a StickerSet."
      ],
      "fields": {
        "documents": "Stickers",
        "emoticon": "Emoji"
      }
    },
    "stickerSet": {
      "name": "stickerSet",
      "description": [
        "Represents a stickerset (stickerpack)"
      ],
      "fields": {
        "access_hash": "Access hash of stickerset",
        "animated": "Is this an animated stickerpack",
        "archived": "Whether this stickerset was archived (due to too many saved stickers in the current account)",
        "count": "Number of stickers in pack",
        "flags": "Flags, see TL conditional fields",
        "hash": "Hash",
        "id": "ID of the stickerset",
        "installed_date": "When was this stickerset installed",
        "masks": "Is this a mask stickerset",
        "official": "Is this stickerset official",
        "short_name": "Short name of stickerset to use in tg://addstickers?set=short_name",
        "thumb": "Thumbnail for stickerset",
        "thumb_dc_id": "DC ID of thumbnail",
        "title": "Title of stickerset"
      }
    },
    "stickerSetCovered": {
      "name": "stickerSetCovered",
      "description": [
        "Stickerset, with a specific sticker as preview"
      ],
      "fields": {
        "cover": "Preview",
        "set": "Stickerset"
      }
    },
    "stickerSetMultiCovered": {
      "name": "stickerSetMultiCovered",
      "description": [
        "Stickerset, with a specific stickers as preview"
      ],
      "fields": {
        "covers": "Preview stickers",
        "set": "Stickerset"
      }
    },
    "storage.fileGif": {
      "name": "storage.fileGif",
      "description": [
        "GIF image. MIME type: image/gif."
      ]
    },
    "storage.fileJpeg": {
      "name": "storage.fileJpeg",
      "description": [
        "JPEG image. MIME type: image/jpeg."
      ]
    },
    "storage.fileMov": {
      "name": "storage.fileMov",
      "description": [
        "Quicktime video. MIME type: video/quicktime."
      ]
    },
    "storage.fileMp3": {
      "name": "storage.fileMp3",
      "description": [
        "Mp3 audio. MIME type: audio/mpeg."
      ]
    },
    "storage.fileMp4": {
      "name": "storage.fileMp4",
      "description": [
        "MPEG-4 video. MIME type: video/mp4."
      ]
    },
    "storage.filePartial": {
      "name": "storage.filePartial",
      "description": [
        "Part of a bigger file."
      ]
    },
    "storage.filePdf": {
      "name": "storage.filePdf",
      "description": [
        "PDF document image. MIME type: application/pdf."
      ]
    },
    "storage.filePng": {
      "name": "storage.filePng",
      "description": [
        "PNG image. MIME type: image/png."
      ]
    },
    "storage.fileUnknown": {
      "name": "storage.fileUnknown",
      "description": [
        "Unknown type."
      ]
    },
    "storage.fileWebp": {
      "name": "storage.fileWebp",
      "description": [
        "WEBP image. MIME type: image/webp."
      ]
    },
    "textAnchor": {
      "name": "textAnchor",
      "description": [
        "Text linking to another section of the page"
      ],
      "fields": {
        "name": "Section name",
        "text": "Text"
      }
    },
    "textBold": {
      "name": "textBold",
      "description": [
        "Bold text"
      ],
      "fields": {
        "text": "Text"
      }
    },
    "textConcat": {
      "name": "textConcat",
      "description": [
        "Concatenation of rich texts"
      ],
      "fields": {
        "texts": "Concatenated rich texts"
      }
    },
    "textEmail": {
      "name": "textEmail",
      "description": [
        "Rich text email link"
      ],
      "fields": {
        "email": "Email address",
        "text": "Link text"
      }
    },
    "textEmpty": {
      "name": "textEmpty",
      "description": [
        "Empty rich text element"
      ]
    },
    "textFixed": {
      "name": "textFixed",
      "description": [
        "fixed-width rich text"
      ],
      "fields": {
        "text": "Text"
      }
    },
    "textImage": {
      "name": "textImage",
      "description": [
        "Inline image"
      ],
      "fields": {
        "document_id": "Document ID",
        "h": "Height",
        "w": "Width"
      }
    },
    "textItalic": {
      "name": "textItalic",
      "description": [
        "Italic text"
      ],
      "fields": {
        "text": "Text"
      }
    },
    "textMarked": {
      "name": "textMarked",
      "description": [
        "Highlighted text"
      ],
      "fields": {
        "text": "Text"
      }
    },
    "textPhone": {
      "name": "textPhone",
      "description": [
        "Rich text linked to a phone number"
      ],
      "fields": {
        "phone": "Phone number",
        "text": "Text"
      }
    },
    "textPlain": {
      "name": "textPlain",
      "description": [
        "Plain text"
      ],
      "fields": {
        "text": "Text"
      }
    },
    "textStrike": {
      "name": "textStrike",
      "description": [
        "Strikethrough text"
      ],
      "fields": {
        "text": "Text"
      }
    },
    "textSubscript": {
      "name": "textSubscript",
      "description": [
        "Subscript text"
      ],
      "fields": {
        "text": "Text"
      }
    },
    "textSuperscript": {
      "name": "textSuperscript",
      "description": [
        "Superscript text"
      ],
      "fields": {
        "text": "Text"
      }
    },
    "textUnderline": {
      "name": "textUnderline",
      "description": [
        "Underlined text"
      ],
      "fields": {
        "text": "Text"
      }
    },
    "textUrl": {
      "name": "textUrl",
      "description": [
        "Link"
      ],
      "fields": {
        "text": "Text of link",
        "url": "Webpage HTTP URL",
        "webpage_id": "If a preview was already generated for the page, the page ID"
      }
    },
    "theme": {
      "name": "theme",
      "description": [
        "Theme"
      ],
      "fields": {
        "access_hash": "Theme access hash",
        "creator": "Whether the current user is the creator of this theme",
        "default": "Whether this is the default theme",
        "document": "Theme",
        "flags": "Flags, see TL conditional fields",
        "id": "Theme ID",
        "installs_count": "Installation count",
        "settings": "Theme settings",
        "slug": "Unique theme ID",
        "title": "Theme name"
      }
    },
    "themeSettings": {
      "name": "themeSettings",
      "description": [
        "Theme settings"
      ],
      "fields": {
        "accent_color": "Accent color, RGB24 format",
        "base_theme": "Base theme",
        "flags": "Flags, see TL conditional fields",
        "message_bottom_color": "Message gradient color (bottom), RGB24 format",
        "message_top_color": "Message gradient color (top), RGB24 format",
        "wallpaper": "Wallpaper"
      }
    },
    "topPeer": {
      "name": "topPeer",
      "description": [
        "Top peer"
      ],
      "fields": {
        "peer": "Peer",
        "rating": "Rating as computed in top peer rating "
      }
    },
    "topPeerCategoryBotsInline": {
      "name": "topPeerCategoryBotsInline",
      "description": [
        "Most used inline bots"
      ]
    },
    "topPeerCategoryBotsPM": {
      "name": "topPeerCategoryBotsPM",
      "description": [
        "Most used bots"
      ]
    },
    "topPeerCategoryChannels": {
      "name": "topPeerCategoryChannels",
      "description": [
        "Most frequently visited channels"
      ]
    },
    "topPeerCategoryCorrespondents": {
      "name": "topPeerCategoryCorrespondents",
      "description": [
        "Users we've chatted most frequently with"
      ]
    },
    "topPeerCategoryForwardChats": {
      "name": "topPeerCategoryForwardChats",
      "description": [
        "Chats to which the users often forwards messages to"
      ]
    },
    "topPeerCategoryForwardUsers": {
      "name": "topPeerCategoryForwardUsers",
      "description": [
        "Users to which the users often forwards messages to"
      ]
    },
    "topPeerCategoryGroups": {
      "name": "topPeerCategoryGroups",
      "description": [
        "Often-opened groups and supergroups"
      ]
    },
    "topPeerCategoryPeers": {
      "name": "topPeerCategoryPeers",
      "description": [
        "Top peer category"
      ],
      "fields": {
        "category": "Top peer category of peers",
        "count": "Count of peers",
        "peers": "Peers"
      }
    },
    "topPeerCategoryPhoneCalls": {
      "name": "topPeerCategoryPhoneCalls",
      "description": [
        "Most frequently called users"
      ]
    },
    "true": {
      "name": "true",
      "description": [
        "See predefined identifiers."
      ]
    },
    "updateBotCallbackQuery": {
      "name": "updateBotCallbackQuery",
      "description": [
        "A callback button was pressed, and the button data was sent to the bot that created the button"
      ],
      "fields": {
        "chat_instance": "Global identifier, uniquely corresponding to the chat to which the message with the callback button was sent. Useful for high scores in games.",
        "data": "Callback data",
        "flags": "Flags, see TL conditional fields",
        "game_short_name": "Short name of a Game to be returned, serves as the unique identifier for the game",
        "msg_id": "Message ID",
        "peer": "Chat where the inline keyboard was sent",
        "query_id": "Query ID",
        "user_id": "ID of the user that pressed the button"
      }
    },
    "updateBotInlineQuery": {
      "name": "updateBotInlineQuery",
      "description": [
        "An incoming inline query"
      ],
      "fields": {
        "flags": "Flags, see TL conditional fields",
        "geo": "Attached geolocation",
        "offset": "Offset to navigate through results",
        "query": "Text of query",
        "query_id": "Query ID",
        "user_id": "User that sent the query"
      }
    },
    "updateBotInlineSend": {
      "name": "updateBotInlineSend",
      "description": [
        "The result of an inline query that was chosen by a user and sent to their chat partner. Please see our documentation on the feedback collecting for details on how to enable these updates for your bot."
      ],
      "fields": {
        "flags": "Flags, see TL conditional fields",
        "geo": "Optional. Sender location, only for bots that require user location",
        "id": "The unique identifier for the result that was chosen",
        "msg_id": "Identifier of the sent inline message. Available only if there is an inline keyboard attached to the message. Will be also received in callback queries and can be used to edit the message.",
        "query": "The query that was used to obtain the result",
        "user_id": "The user that chose the result"
      }
    },
    "updateBotPrecheckoutQuery": {
      "name": "updateBotPrecheckoutQuery",
      "description": [
        "This object contains information about an incoming pre-checkout query."
      ],
      "fields": {
        "currency": "Three-letter ISO 4217 currency code",
        "flags": "Flags, see TL conditional fields",
        "info": "Order info provided by the user",
        "payload": "Bot specified invoice payload",
        "query_id": "Unique query identifier",
        "shipping_option_id": "Identifier of the shipping option chosen by the user",
        "total_amount": "Total amount in the smallest units of the currency (integer, not float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies).",
        "user_id": "User who sent the query"
      }
    },
    "updateBotShippingQuery": {
      "name": "updateBotShippingQuery",
      "description": [
        "This object contains information about an incoming shipping query."
      ],
      "fields": {
        "payload": "Bot specified invoice payload",
        "query_id": "Unique query identifier",
        "shipping_address": "User specified shipping address",
        "user_id": "User who sent the query"
      }
    },
    "updateBotWebhookJSON": {
      "name": "updateBotWebhookJSON",
      "description": [
        "A new incoming event; for bots only"
      ],
      "fields": {
        "data": "The event"
      }
    },
    "updateBotWebhookJSONQuery": {
      "name": "updateBotWebhookJSONQuery",
      "description": [
        "A new incoming query; for bots only"
      ],
      "fields": {
        "data": "Query data",
        "query_id": "Query identifier",
        "timeout": "Query timeout"
      }
    },
    "updateChannel": {
      "name": "updateChannel",
      "description": [
        "A new channel is available"
      ],
      "fields": {
        "channel_id": "Channel ID"
      }
    },
    "updateChannelAvailableMessages": {
      "name": "updateChannelAvailableMessages",
      "description": [
        "The history of a channel/supergroup was hidden."
      ],
      "fields": {
        "available_min_id": "Identifier of a maximum unavailable message in a channel due to hidden history.",
        "channel_id": "Channel/supergroup ID"
      }
    },
    "updateChannelMessageForwards": {
      "name": "updateChannelMessageForwards",
      "description": [
        "The forward counter of a message in a channel has changed"
      ],
      "fields": {
        "channel_id": "Channel ID",
        "forwards": "New forward counter",
        "id": "ID of the message"
      }
    },
    "updateChannelMessageViews": {
      "name": "updateChannelMessageViews",
      "description": [
        "The view counter of a message in a channel has changed"
      ],
      "fields": {
        "channel_id": "Channel ID",
        "id": "ID of the message",
        "views": "New view counter"
      }
    },
    "updateChannelParticipant": {
      "name": "updateChannelParticipant",
      "description": [
        "A participant has left, joined, was banned or admined in a channel or supergroup."
      ],
      "fields": {
        "channel_id": "Channel ID",
        "date": "Date of the event",
        "flags": "Flags, see TL conditional fields",
        "new_participant": "New participant status",
        "prev_participant": "Previous participant status",
        "qts": "PTS",
        "user_id": "User in question"
      }
    },
    "updateChannelReadMessagesContents": {
      "name": "updateChannelReadMessagesContents",
      "description": [
        "The specified channel/supergroup messages were read"
      ],
      "fields": {
        "channel_id": "Channel/supergroup ID",
        "messages": "IDs of messages that were read"
      }
    },
    "updateChannelTooLong": {
      "name": "updateChannelTooLong",
      "description": [
        "There are new updates in the specified channel, the client must fetch them.\nIf the difference is too long or if the channel isn't currently in the states, start fetching from the specified pts."
      ],
      "fields": {
        "channel_id": "The channel",
        "flags": "Flags, see TL conditional fields",
        "pts": "The PTS."
      }
    },
    "updateChannelUserTyping": {
      "name": "updateChannelUserTyping",
      "description": [
        "A user is typing in a supergroup, channel or message thread"
      ],
      "fields": {
        "action": "Whether the user is typing, sending a media or doing something else",
        "channel_id": "Channel ID",
        "flags": "Flags, see TL conditional fields",
        "top_msg_id": "Thread ID",
        "user_id": "User ID"
      }
    },
    "updateChannelWebPage": {
      "name": "updateChannelWebPage",
      "description": [
        "A webpage preview of a link in a channel/supergroup message was generated"
      ],
      "fields": {
        "channel_id": "Channel/supergroup ID",
        "pts": "Event count after generation",
        "pts_count": "Number of events that were generated",
        "webpage": "Generated webpage preview"
      }
    },
    "updateChatDefaultBannedRights": {
      "name": "updateChatDefaultBannedRights",
      "description": [
        "Default banned rights in a normal chat were updated"
      ],
      "fields": {
        "default_banned_rights": "New default banned rights",
        "peer": "The chat",
        "version": "Version"
      }
    },
    "updateChatParticipantAdd": {
      "name": "updateChatParticipantAdd",
      "description": [
        "New group member."
      ],
      "fields": {
        "chat_id": "Group ID",
        "date": "When was the participant added",
        "inviter_id": "ID of the user, who added member to the group",
        "user_id": "ID of the new member",
        "version": "Chat version number"
      }
    },
    "updateChatParticipantAdmin": {
      "name": "updateChatParticipantAdmin",
      "description": [
        "Admin permissions of a user in a legacy group were changed"
      ],
      "fields": {
        "chat_id": "Chat ID",
        "is_admin": "Whether the user was rendered admin",
        "user_id": "ID of the (de)admined user",
        "version": "Used in basic groups to reorder updates and make sure that all of them was received."
      }
    },
    "updateChatParticipantDelete": {
      "name": "updateChatParticipantDelete",
      "description": [
        "A member has left the group."
      ],
      "fields": {
        "chat_id": "Group ID",
        "user_id": "ID of the user",
        "version": "Used in basic groups to reorder updates and make sure that all of them was received."
      }
    },
    "updateChatParticipants": {
      "name": "updateChatParticipants",
      "description": [
        "Composition of chat participants changed."
      ],
      "fields": {
        "participants": "Updated chat participants"
      }
    },
    "updateChatUserTyping": {
      "name": "updateChatUserTyping",
      "description": [
        "The user is preparing a message in a group; typing, recording, uploading, etc. This update is valid for 6 seconds. If no repeated update received after 6 seconds, it should be considered that the user stopped doing whatever he's been doing."
      ],
      "fields": {
        "action": "Type of actionParameter added in Layer 17.",
        "chat_id": "Group id",
        "user_id": "User id"
      }
    },
    "updateConfig": {
      "name": "updateConfig",
      "description": [
        "The server-side configuration has changed; the client should re-fetch the config using help.getConfig"
      ]
    },
    "updateContactsReset": {
      "name": "updateContactsReset",
      "description": [
        "All contacts were deleted"
      ]
    },
    "updateDcOptions": {
      "name": "updateDcOptions",
      "description": [
        "Changes in the data center configuration options."
      ],
      "fields": {
        "dc_options": "New connection options"
      }
    },
    "updateDeleteChannelMessages": {
      "name": "updateDeleteChannelMessages",
      "description": [
        "Some messages in a supergroup/channel were deleted"
      ],
      "fields": {
        "channel_id": "Channel ID",
        "messages": "IDs of messages that were deleted",
        "pts": "Event count after generation",
        "pts_count": "Number of events that were generated"
      }
    },
    "updateDeleteMessages": {
      "name": "updateDeleteMessages",
      "description": [
        "Messages were deleted."
      ],
      "fields": {
        "messages": "List of identifiers of deleted messages",
        "pts": "New quality of actions in a message box",
        "pts_count": "Number of generated events"
      }
    },
    "updateDeleteScheduledMessages": {
      "name": "updateDeleteScheduledMessages",
      "description": [
        "Some scheduled messages were deleted from the schedule queue of a chat"
      ],
      "fields": {
        "messages": "Deleted scheduled messages",
        "peer": "Peer"
      }
    },
    "updateDialogFilter": {
      "name": "updateDialogFilter",
      "description": [
        "A new folder was added"
      ],
      "fields": {
        "filter": "Folder info",
        "flags": "Flags, see TL conditional fields",
        "id": "Folder ID"
      }
    },
    "updateDialogFilterOrder": {
      "name": "updateDialogFilterOrder",
      "description": [
        "New folder order"
      ],
      "fields": {
        "order": "Ordered folder IDs"
      }
    },
    "updateDialogFilters": {
      "name": "updateDialogFilters",
      "description": [
        "Clients should update folder info"
      ]
    },
    "updateDialogPinned": {
      "name": "updateDialogPinned",
      "description": [
        "A dialog was pinned/unpinned"
      ],
      "fields": {
        "flags": "Flags, see TL conditional fields",
        "folder_id": "Peer folder ID, for more info click here",
        "peer": "The dialog",
        "pinned": "Whether the dialog was pinned"
      }
    },
    "updateDialogUnreadMark": {
      "name": "updateDialogUnreadMark",
      "description": [
        "The manual unread mark of a chat was changed"
      ],
      "fields": {
        "flags": "Flags, see TL conditional fields",
        "peer": "The dialog",
        "unread": "Was the chat marked or unmarked as read"
      }
    },
    "updateDraftMessage": {
      "name": "updateDraftMessage",
      "description": [
        "Notifies a change of a message draft."
      ],
      "fields": {
        "draft": "The draft",
        "peer": "The peer to which the draft is associated"
      }
    },
    "updateEditChannelMessage": {
      "name": "updateEditChannelMessage",
      "description": [
        "A message was edited in a channel/supergroup"
      ],
      "fields": {
        "message": "The new message",
        "pts": "Event count after generation",
        "pts_count": "Number of events that were generated"
      }
    },
    "updateEditMessage": {
      "name": "updateEditMessage",
      "description": [
        "A message was edited"
      ],
      "fields": {
        "message": "The new edited message",
        "pts": "PTS",
        "pts_count": "PTS count"
      }
    },
    "updateEncryptedChatTyping": {
      "name": "updateEncryptedChatTyping",
      "description": [
        "Interlocutor is typing a message in an encrypted chat. Update period is 6 second. If upon this time there is no repeated update, it shall be considered that the interlocutor stopped typing."
      ],
      "fields": {
        "chat_id": "Chat ID"
      }
    },
    "updateEncryptedMessagesRead": {
      "name": "updateEncryptedMessagesRead",
      "description": [
        "Communication history in an encrypted chat was marked as read."
      ],
      "fields": {
        "chat_id": "Chat ID",
        "date": "Time when messages were read",
        "max_date": "Maximum value of data for read messages"
      }
    },
    "updateEncryption": {
      "name": "updateEncryption",
      "description": [
        "Change of state in an encrypted chat."
      ],
      "fields": {
        "chat": "Encrypted chat",
        "date": "Date of change"
      }
    },
    "updateFavedStickers": {
      "name": "updateFavedStickers",
      "description": [
        "The list of favorited stickers was changed, the client should call messages.getFavedStickers to refetch the new list"
      ]
    },
    "updateFolderPeers": {
      "name": "updateFolderPeers",
      "description": [
        "The peer list of a peer folder was updated"
      ],
      "fields": {
        "folder_peers": "New peer list",
        "pts": "Event count after generation",
        "pts_count": "Number of events that were generated"
      }
    },
    "updateGeoLiveViewed": {
      "name": "updateGeoLiveViewed",
      "description": [
        "Live geoposition message was viewed"
      ],
      "fields": {
        "msg_id": "Message ID of geoposition message",
        "peer": "The user that viewed the live geoposition"
      }
    },
    "updateInlineBotCallbackQuery": {
      "name": "updateInlineBotCallbackQuery",
      "description": [
        "This notification is received by bots when a button is pressed"
      ],
      "fields": {
        "chat_instance": "Global identifier, uniquely corresponding to the chat to which the message with the callback button was sent. Useful for high scores in games.",
        "data": "Data associated with the callback button. Be aware that a bad client can send arbitrary data in this field.",
        "flags": "Flags, see TL conditional fields",
        "game_short_name": "Short name of a Game to be returned, serves as the unique identifier for the game",
        "msg_id": "ID of the inline message with the button",
        "query_id": "Query ID",
        "user_id": "ID of the user that pressed the button"
      }
    },
    "updateLangPack": {
      "name": "updateLangPack",
      "description": [
        "Language pack updated"
      ],
      "fields": {
        "difference": "Changed strings"
      }
    },
    "updateLangPackTooLong": {
      "name": "updateLangPackTooLong",
      "description": [
        "A language pack has changed, the client should manually fetch the changed strings using langpack.getDifference"
      ],
      "fields": {
        "lang_code": "Language code"
      }
    },
    "updateLoginToken": {
      "name": "updateLoginToken",
      "description": [
        "A login token (for login via QR code) was accepted."
      ]
    },
    "updateMessageID": {
      "name": "updateMessageID",
      "description": [
        "Sent message with random_id client identifier was assigned an identifier."
      ],
      "fields": {
        "id": "id identifier of a respective Message",
        "random_id": "Previuosly transferred client random_id identifier"
      }
    },
    "updateMessagePoll": {
      "name": "updateMessagePoll",
      "description": [
        "The results of a poll have changed"
      ],
      "fields": {
        "flags": "Flags, see TL conditional fields",
        "poll": "If the server knows the client hasn't cached this poll yet, the poll itself",
        "poll_id": "Poll ID",
        "results": "New poll results"
      }
    },
    "updateMessagePollVote": {
      "name": "updateMessagePollVote",
      "description": [
        "A specific user has voted in a poll"
      ],
      "fields": {
        "options": "Chosen option(s)",
        "poll_id": "Poll ID",
        "user_id": "User ID"
      }
    },
    "updateNewChannelMessage": {
      "name": "updateNewChannelMessage",
      "description": [
        "A new message was sent in a channel/supergroup"
      ],
      "fields": {
        "message": "New message",
        "pts": "Event count after generation",
        "pts_count": "Number of events that were generated"
      }
    },
    "updateNewEncryptedMessage": {
      "name": "updateNewEncryptedMessage",
      "description": [
        "New encrypted message."
      ],
      "fields": {
        "message": "Message",
        "qts": "New qts value"
      }
    },
    "updateNewMessage": {
      "name": "updateNewMessage",
      "description": [
        "New message in a private chat or in a legacy group."
      ],
      "fields": {
        "message": "Message",
        "pts": "New quantity of actions in a message box",
        "pts_count": "Number of generated events"
      }
    },
    "updateNewScheduledMessage": {
      "name": "updateNewScheduledMessage",
      "description": [
        "A message was added to the schedule queue of a chat"
      ],
      "fields": {
        "message": "Message"
      }
    },
    "updateNewStickerSet": {
      "name": "updateNewStickerSet",
      "description": [
        "A new stickerset was installed"
      ],
      "fields": {
        "stickerset": "The installed stickerset"
      }
    },
    "updateNotifySettings": {
      "name": "updateNotifySettings",
      "description": [
        "Changes in notification settings."
      ],
      "fields": {
        "notify_settings": "New notification settings",
        "peer": "Nofication source"
      }
    },
    "updatePeerBlocked": {
      "name": "updatePeerBlocked",
      "description": [
        "A peer was blocked"
      ],
      "fields": {
        "blocked": "Whether the peer was blocked or unblocked",
        "peer_id": "The blocked peer"
      }
    },
    "updatePeerLocated": {
      "name": "updatePeerLocated",
      "description": [
        "List of peers near you was updated"
      ],
      "fields": {
        "peers": "Geolocated peer list update"
      }
    },
    "updatePeerSettings": {
      "name": "updatePeerSettings",
      "description": [
        "Settings of a certain peer have changed"
      ],
      "fields": {
        "peer": "The peer",
        "settings": "Associated peer settings"
      }
    },
    "updatePhoneCall": {
      "name": "updatePhoneCall",
      "description": [
        "An incoming phone call"
      ],
      "fields": {
        "phone_call": "Phone call"
      }
    },
    "updatePhoneCallSignalingData": {
      "name": "updatePhoneCallSignalingData",
      "description": [
        "Incoming phone call signaling payload"
      ],
      "fields": {
        "data": "Signaling payload",
        "phone_call_id": "Phone call ID"
      }
    },
    "updatePinnedChannelMessages": {
      "name": "updatePinnedChannelMessages",
      "description": [
        "Messages were pinned/unpinned in a channel/supergroup"
      ],
      "fields": {
        "channel_id": "Channel ID",
        "flags": "Flags, see TL conditional fields",
        "messages": "Messages",
        "pinned": "Whether the messages were pinned or unpinned",
        "pts": "Event count after generation",
        "pts_count": "Number of events that were generated"
      }
    },
    "updatePinnedDialogs": {
      "name": "updatePinnedDialogs",
      "description": [
        "Pinned dialogs were updated"
      ],
      "fields": {
        "flags": "Flags, see TL conditional fields",
        "folder_id": "Peer folder ID, for more info click here",
        "order": "New order of pinned dialogs"
      }
    },
    "updatePinnedMessages": {
      "name": "updatePinnedMessages",
      "description": [
        "Some messages were pinned in a chat"
      ],
      "fields": {
        "flags": "Flags, see TL conditional fields",
        "messages": "Message IDs",
        "peer": "Peer",
        "pinned": "Whether the messages were pinned or unpinned",
        "pts": "Event count after generation",
        "pts_count": "Number of events that were generated"
      }
    },
    "updatePrivacy": {
      "name": "updatePrivacy",
      "description": [
        "Privacy rules were changed"
      ],
      "fields": {
        "key": "Peers to which the privacy rules apply",
        "rules": "New privacy rules"
      }
    },
    "updatePtsChanged": {
      "name": "updatePtsChanged",
      "description": [
        "Common message box sequence PTS has changed, state has to be refetched using updates.getState"
      ]
    },
    "updateReadChannelDiscussionInbox": {
      "name": "updateReadChannelDiscussionInbox",
      "description": [
        "Incoming comments in a discussion thread were marked as read"
      ],
      "fields": {
        "broadcast_id": "If set, contains the ID of the channel that contains the post that started the comment thread in the discussion group (channel_id)",
        "broadcast_post": "If set, contains the ID of the channel post that started the the comment thread",
        "channel_id": "Discussion group ID",
        "flags": "Flags, see TL conditional fields",
        "read_max_id": "Message ID of latest read incoming message for this thread",
        "top_msg_id": "ID of the group message that started the thread (message in linked discussion group)"
      }
    },
    "updateReadChannelDiscussionOutbox": {
      "name": "updateReadChannelDiscussionOutbox",
      "description": [
        "Outgoing comments in a discussion thread were marked as read"
      ],
      "fields": {
        "channel_id": "Supergroup ID",
        "read_max_id": "Message ID of latest read outgoing message for this thread",
        "top_msg_id": "ID of the group message that started the thread"
      }
    },
    "updateReadChannelInbox": {
      "name": "updateReadChannelInbox",
      "description": [
        "Incoming messages in a channel/supergroup were read"
      ],
      "fields": {
        "channel_id": "Channel/supergroup ID",
        "flags": "Flags, see TL conditional fields",
        "folder_id": "Peer folder ID, for more info click here",
        "max_id": "Position up to which all incoming messages are read.",
        "pts": "Event count after generation",
        "still_unread_count": "Count of messages weren't read yet"
      }
    },
    "updateReadChannelOutbox": {
      "name": "updateReadChannelOutbox",
      "description": [
        "Outgoing messages in a channel/supergroup were read"
      ],
      "fields": {
        "channel_id": "Channel/supergroup ID",
        "max_id": "Position up to which all outgoing messages are read."
      }
    },
    "updateReadFeaturedStickers": {
      "name": "updateReadFeaturedStickers",
      "description": [
        "Some featured stickers were marked as read"
      ]
    },
    "updateReadHistoryInbox": {
      "name": "updateReadHistoryInbox",
      "description": [
        "Incoming messages were read"
      ],
      "fields": {
        "flags": "Flags, see TL conditional fields",
        "folder_id": "Peer folder ID, for more info click here",
        "max_id": "Maximum ID of messages read",
        "peer": "Peer",
        "pts": "Event count after generation",
        "pts_count": "Number of events that were generated",
        "still_unread_count": "Number of messages that are still unread"
      }
    },
    "updateReadHistoryOutbox": {
      "name": "updateReadHistoryOutbox",
      "description": [
        "Outgoing messages were read"
      ],
      "fields": {
        "max_id": "Maximum ID of read outgoing messages",
        "peer": "Peer",
        "pts": "Event count after generation",
        "pts_count": "Number of events that were generated"
      }
    },
    "updateReadMessagesContents": {
      "name": "updateReadMessagesContents",
      "description": [
        "Contents of messages in the common message box were read"
      ],
      "fields": {
        "messages": "IDs of read messages",
        "pts": "Event count after generation",
        "pts_count": "Number of events that were generated"
      }
    },
    "updateRecentStickers": {
      "name": "updateRecentStickers",
      "description": [
        "The recent sticker list was updated"
      ]
    },
    "updateSavedGifs": {
      "name": "updateSavedGifs",
      "description": [
        "The saved gif list has changed, the client should refetch it using messages.getSavedGifs"
      ]
    },
    "updateServiceNotification": {
      "name": "updateServiceNotification",
      "description": [
        "A service message for the user.",
        "The app must show the message to the user upon receiving this update. In case the popup parameter was passed, the text message must be displayed in a popup alert immediately upon receipt. It is recommended to handle the text as you would an ordinary message in terms of highlighting links, etc. The message must also be stored locally as part of the message history with the user id 777000 (Telegram Notifications)."
      ],
      "fields": {
        "entities": "Message entities for styled text",
        "flags": "Flags, see TL conditional fields",
        "inbox_date": "When was the notification receivedThe message must also be stored locally as part of the message history with the user id 777000 (Telegram Notifications).",
        "media": "Media content (optional)",
        "message": "Message text",
        "popup": "(boolTrue) if the message must be displayed in a popup.",
        "type": "String, identical in format and contents to the type field in API errors. Describes type of service message. It is acceptable to ignore repeated messages of the same type within a short period of time (15 minutes)."
      }
    },
    "updateShort": {
      "name": "updateShort",
      "description": [
        "Shortened constructor containing info on one update not requiring auxiliary data"
      ],
      "fields": {
        "date": "Date of event",
        "update": "Update"
      }
    },
    "updateShortChatMessage": {
      "name": "updateShortChatMessage",
      "description": [
        "Shortened constructor containing info on one new incoming text message from a chat"
      ],
      "fields": {
        "chat_id": "ID of the chat where the message was sent",
        "date": "date",
        "entities": "Entities for styled text",
        "flags": "Flags, see TL conditional fields",
        "from_id": "ID of the sender of the message",
        "fwd_from": "Info about a forwarded message",
        "id": "ID of the message",
        "media_unread": "Whether the message contains some unread mentions",
        "mentioned": "Whether we were mentioned in this message",
        "message": "Message",
        "out": "Whether the message is outgoing",
        "pts": "PTS",
        "pts_count": "PTS count",
        "reply_to": "Reply (thread) information",
        "silent": "If true, the message is a silent message, no notifications should be triggered",
        "via_bot_id": "Info about the inline bot used to generate this message"
      }
    },
    "updateShortMessage": {
      "name": "updateShortMessage",
      "description": [
        "Info about a message sent to (received from) another user"
      ],
      "fields": {
        "date": "date",
        "entities": "Entities for styled text",
        "flags": "Flags, see TL conditional fields",
        "fwd_from": "Info about a forwarded message",
        "id": "The message ID",
        "media_unread": "Whether there are some unread mentions in this message",
        "mentioned": "Whether we were mentioned in the message",
        "message": "The message",
        "out": "Whether the message is outgoing",
        "pts": "PTS",
        "pts_count": "PTS count",
        "reply_to": "Reply and thread information",
        "silent": "If true, the message is a silent message, no notifications should be triggered",
        "user_id": "The ID of the sender (if outgoing will be the ID of the destination) of the message",
        "via_bot_id": "Info about the inline bot used to generate this message"
      }
    },
    "updateShortSentMessage": {
      "name": "updateShortSentMessage",
      "description": [
        "Shortened constructor containing info on one outgoing message to a contact (the destination chat has to be extracted from the method call that returned this object)."
      ],
      "fields": {
        "date": "date",
        "entities": "Entities for styled text",
        "flags": "Flags, see TL conditional fields",
        "id": "ID of the sent message",
        "media": "Attached media",
        "out": "Whether the message is outgoing",
        "pts": "PTS",
        "pts_count": "PTS count"
      }
    },
    "updateStickerSets": {
      "name": "updateStickerSets",
      "description": [
        "Installed stickersets have changed, the client should refetch them using messages.getAllStickers"
      ]
    },
    "updateStickerSetsOrder": {
      "name": "updateStickerSetsOrder",
      "description": [
        "The order of stickersets was changed"
      ],
      "fields": {
        "flags": "Flags, see TL conditional fields",
        "masks": "Whether the updated stickers are mask stickers",
        "order": "New sticker order by sticker ID"
      }
    },
    "updateTheme": {
      "name": "updateTheme",
      "description": [
        "A cloud theme was updated"
      ],
      "fields": {
        "theme": "Theme"
      }
    },
    "updateUserName": {
      "name": "updateUserName",
      "description": [
        "Changes the user's first name, last name and username."
      ],
      "fields": {
        "first_name": "New first name. Corresponds to the new value of real_first_name field of the userFull constructor.",
        "last_name": "New last name. Corresponds to the new value of real_last_name field of the userFull constructor.",
        "user_id": "User identifier",
        "username": "New username.Parameter added in Layer 18."
      }
    },
    "updateUserPhone": {
      "name": "updateUserPhone",
      "description": [
        "A user's phone number was changed"
      ],
      "fields": {
        "phone": "New phone number",
        "user_id": "User ID"
      }
    },
    "updateUserPhoto": {
      "name": "updateUserPhoto",
      "description": [
        "Change of contact's profile photo."
      ],
      "fields": {
        "date": "Date of photo update.",
        "photo": "New profile photo",
        "previous": "(boolTrue), if one of the previously used photos is set a profile photo.",
        "user_id": "User identifier"
      }
    },
    "updateUserStatus": {
      "name": "updateUserStatus",
      "description": [
        "Contact status update."
      ],
      "fields": {
        "status": "New status",
        "user_id": "User identifier"
      }
    },
    "updateUserTyping": {
      "name": "updateUserTyping",
      "description": [
        "The user is preparing a message; typing, recording, uploading, etc. This update is valid for 6 seconds. If no repeated update received after 6 seconds, it should be considered that the user stopped doing whatever he's been doing."
      ],
      "fields": {
        "action": "Action typeParam added in Layer 17.",
        "user_id": "User id"
      }
    },
    "updateWebPage": {
      "name": "updateWebPage",
      "description": [
        "An instant view webpage preview was generated"
      ],
      "fields": {
        "pts": "Event count after generation",
        "pts_count": "Number of events that were generated",
        "webpage": "Webpage preview"
      }
    },
    "updates.channelDifference": {
      "name": "updates.channelDifference",
      "description": [
        "The new updates"
      ],
      "fields": {
        "chats": "Chats",
        "final": "Whether there are more updates to be fetched using getDifference, starting from the provided pts",
        "flags": "Flags, see TL conditional fields",
        "new_messages": "New messages",
        "other_updates": "Other updates",
        "pts": "The PTS from which to start getting updates the next time",
        "timeout": "Clients are supposed to refetch the channel difference after timeout seconds have elapsed",
        "users": "Users"
      }
    },
    "updates.channelDifferenceEmpty": {
      "name": "updates.channelDifferenceEmpty",
      "description": [
        "There are no new updates"
      ],
      "fields": {
        "final": "Whether there are more updates that must be fetched (always false)",
        "flags": "Flags, see TL conditional fields",
        "pts": "The latest PTS",
        "timeout": "Clients are supposed to refetch the channel difference after timeout seconds have elapsed"
      }
    },
    "updates.channelDifferenceTooLong": {
      "name": "updates.channelDifferenceTooLong",
      "description": [
        "The provided pts + limit \u003c remote pts. Simply, there are too many updates to be fetched (more than limit), the client has to resolve the update gap in one of the following ways:"
      ],
      "fields": {
        "chats": "Chats from messages",
        "dialog": "Dialog containing the latest PTS that can be used to reset the channel state",
        "final": "Whether there are more updates that must be fetched (always false)",
        "flags": "Flags, see TL conditional fields",
        "messages": "The latest messages",
        "timeout": "Clients are supposed to refetch the channel difference after timeout seconds have elapsed",
        "users": "Users from messages"
      }
    },
    "updates.difference": {
      "name": "updates.difference",
      "description": [
        "Full list of occurred events."
      ],
      "fields": {
        "chats": "List of chats mentioned in events",
        "new_encrypted_messages": "List of new encrypted secret chat messages",
        "new_messages": "List of new messages",
        "other_updates": "List of updates",
        "state": "Current state",
        "users": "List of users mentioned in events"
      }
    },
    "updates.differenceEmpty": {
      "name": "updates.differenceEmpty",
      "description": [
        "No events."
      ],
      "fields": {
        "date": "Current date",
        "seq": "Number of sent updates"
      }
    },
    "updates.differenceSlice": {
      "name": "updates.differenceSlice",
      "description": [
        "Incomplete list of occurred events."
      ],
      "fields": {
        "chats": "List of chats mentioned in events",
        "intermediate_state": "Intermediary state",
        "new_encrypted_messages": "New messages from the encrypted event sequence",
        "new_messages": "List of new messgaes",
        "other_updates": "List of updates",
        "users": "List of users mentioned in events"
      }
    },
    "updates.differenceTooLong": {
      "name": "updates.differenceTooLong",
      "description": [
        "The difference is too long, and the specified state must be used to refetch updates."
      ],
      "fields": {
        "pts": "The new state to use."
      }
    },
    "updates.state": {
      "name": "updates.state",
      "description": [
        "Updates state."
      ],
      "fields": {
        "date": "Date of condition",
        "pts": "Number of events occured in a text box",
        "qts": "Position in a sequence of updates in secret chats. For further detailes refer to article secret chatsParameter was added in eigth layer.",
        "seq": "Number of sent updates",
        "unread_count": "Number of unread messages"
      }
    },
    "updatesCombined": {
      "name": "updatesCombined",
      "description": [
        "Constructor for a group of updates."
      ],
      "fields": {
        "chats": "List of chats mentioned in updates",
        "date": "Current date",
        "seq": "Value seq for the latest update in a group",
        "seq_start": "Value seq for the earliest update in a group",
        "updates": "List of updates",
        "users": "List of users mentioned in updates"
      }
    },
    "updatesTooLong": {
      "name": "updatesTooLong",
      "description": [
        "Too many updates, it is necessary to execute updates.getDifference."
      ]
    },
    "upload.cdnFile": {
      "name": "upload.cdnFile",
      "description": [
        "Represent a chunk of a CDN file."
      ],
      "fields": {
        "bytes": "The data"
      }
    },
    "upload.cdnFileReuploadNeeded": {
      "name": "upload.cdnFileReuploadNeeded",
      "description": [
        "The file was cleared from the temporary RAM cache of the CDN and has to be reuploaded."
      ],
      "fields": {
        "request_token": "Request token (see CDN)"
      }
    },
    "upload.file": {
      "name": "upload.file",
      "description": [
        "File content."
      ],
      "fields": {
        "bytes": "Binary data, file content",
        "mtime": "Modification type",
        "type": "File type"
      }
    },
    "upload.fileCdnRedirect": {
      "name": "upload.fileCdnRedirect",
      "description": [
        "The file must be downloaded from a CDN DC."
      ],
      "fields": {
        "dc_id": "CDN DC ID",
        "encryption_iv": "Encryption IV (see CDN files)",
        "encryption_key": "Encryption key (see CDN files)",
        "file_hashes": "File hashes (see CDN files)",
        "file_token": "File token (see CDN files)"
      }
    },
    "upload.webFile": {
      "name": "upload.webFile",
      "description": [
        "Represents a chunk of an HTTP webfile downloaded through telegram's secure MTProto servers"
      ],
      "fields": {
        "bytes": "Data",
        "file_type": "File type",
        "mime_type": "Mime type",
        "mtime": "Modified time",
        "size": "File size"
      }
    },
    "urlAuthResultAccepted": {
      "name": "urlAuthResultAccepted",
      "description": [
        "Details about an accepted authorization request, for more info click here "
      ],
      "fields": {
        "url": "The URL name of the website on which the user has logged in."
      }
    },
    "urlAuthResultDefault": {
      "name": "urlAuthResultDefault",
      "description": [
        "Details about an accepted authorization request, for more info click here "
      ]
    },
    "urlAuthResultRequest": {
      "name": "urlAuthResultRequest",
      "description": [
        "Details about the authorization request, for more info click here "
      ],
      "fields": {
        "bot": "Username of a bot, which will be used for user authorization. If not specified, the current bot's username will be assumed. The url's domain must be the same as the domain linked with the bot. See Linking your domain to the bot for more details.",
        "domain": "The domain name of the website on which the user will log in.",
        "flags": "Flags, see TL conditional fields",
        "request_write_access": "Whether the bot would like to send messages to the user"
      }
    },
    "user": {
      "name": "user",
      "description": [
        "Indicates info about a certain user"
      ],
      "fields": {
        "access_hash": "Access hash of the user",
        "apply_min_photo": "If set, the profile picture for this user should be refetched",
        "bot": "Is this user a bot?",
        "bot_chat_history": "Can the bot see all messages in groups?",
        "bot_info_version": "Version of the bot_info field in userFull, incremented every time it changes",
        "bot_inline_geo": "Whether the bot can request our geolocation in inline mode",
        "bot_inline_placeholder": "Inline placeholder for this inline bot",
        "bot_nochats": "Can the bot be added to groups?",
        "contact": "Whether this user is a contact",
        "deleted": "Whether the account of this user was deleted",
        "first_name": "First name",
        "flags": "Flags, see TL conditional fields",
        "id": "ID of the user",
        "lang_code": "Language code of the user",
        "last_name": "Last name",
        "min": "See min",
        "mutual_contact": "Whether this user is a mutual contact",
        "phone": "Phone number",
        "photo": "Profile picture of user",
        "restricted": "Access to this user must be restricted for the reason specified in restriction_reason",
        "restriction_reason": "Contains the reason why access to this user must be restricted.",
        "scam": "This may be a scam user",
        "self": "Whether this user indicates the currently logged in user",
        "status": "Online status of user",
        "support": "Whether this is an official support user",
        "username": "Username",
        "verified": "Whether this user is verified"
      }
    },
    "userEmpty": {
      "name": "userEmpty",
      "description": [
        "Empty constructor, non-existent user."
      ],
      "fields": {
        "id": "User identifier or 0"
      }
    },
    "userFull": {
      "name": "userFull",
      "description": [
        "Extended user info"
      ],
      "fields": {
        "about": "Bio of the user",
        "blocked": "Whether you have blocked this user",
        "bot_info": "For bots, info about the bot (bot commands, etc)",
        "can_pin_message": "Whether you can pin messages in the chat with this user, you can do this only for a chat with yourself",
        "common_chats_count": "Chats in common with this user",
        "flags": "Flags, see TL conditional fields",
        "folder_id": "Peer folder ID, for more info click here",
        "has_scheduled": "Whether scheduled messages are available",
        "notify_settings": "Notification settings",
        "phone_calls_available": "Whether this user can make VoIP calls",
        "phone_calls_private": "Whether this user's privacy settings allow you to call him",
        "pinned_msg_id": "Message ID of the last pinned message",
        "profile_photo": "Profile photo",
        "settings": "Peer settings",
        "user": "Remaining user info",
        "video_calls_available": "Whether the user can receive video calls"
      }
    },
    "userProfilePhoto": {
      "name": "userProfilePhoto",
      "description": [
        "User profile photo."
      ],
      "fields": {
        "dc_id": "DC ID where the photo is stored",
        "flags": "Flags, see TL conditional fields",
        "has_video": "Whether an animated profile picture is available for this user",
        "photo_big": "Location of the file, corresponding to the big profile photo thumbnail",
        "photo_id": "Identifier of the respective photoParameter added in Layer 2",
        "photo_small": "Location of the file, corresponding to the small profile photo thumbnail"
      }
    },
    "userProfilePhotoEmpty": {
      "name": "userProfilePhotoEmpty",
      "description": [
        "Profile photo has not been set, or was hidden."
      ]
    },
    "userStatusEmpty": {
      "name": "userStatusEmpty",
      "description": [
        "User status has not been set yet."
      ]
    },
    "userStatusLastMonth": {
      "name": "userStatusLastMonth",
      "description": [
        "Online status: last seen last month"
      ]
    },
    "userStatusLastWeek": {
      "name": "userStatusLastWeek",
      "description": [
        "Online status: last seen last week"
      ]
    },
    "userStatusOffline": {
      "name": "userStatusOffline",
      "description": [
        "The user's offline status."
      ],
      "fields": {
        "was_online": "Time the user was last seen online"
      }
    },
    "userStatusOnline": {
      "name": "userStatusOnline",
      "description": [
        "Online status of the user."
      ],
      "fields": {
        "expires": "Time to expiration of the current online status"
      }
    },
    "userStatusRecently": {
      "name": "userStatusRecently",
      "description": [
        "Online status: last seen recently"
      ]
    },
    "vector": {
      "name": "vector",
      "description": [
        "A universal vector constructor."
      ]
    },
    "videoSize": {
      "name": "videoSize",
      "description": [
        "Animated profile picture in MPEG4 format"
      ],
      "fields": {
        "flags": "Flags, see TL conditional fields",
        "h": "Video height",
        "location": "File location",
        "size": "File size",
        "type": "u for animated profile pictures, and v for trimmed and downscaled video previews",
        "video_start_ts": "Timestamp that should be shown as static preview to the user (seconds)",
        "w": "Video width"
      }
    },
    "wallPaper": {
      "name": "wallPaper",
      "description": [
        "Wallpaper settings."
      ],
      "fields": {
        "access_hash": "Access hash",
        "creator": "Creator of the wallpaper",
        "dark": "Dark mode",
        "default": "Whether this is the default wallpaper",
        "document": "The actual wallpaper",
        "flags": "Flags, see TL conditional fields",
        "id": "Identifier",
        "pattern": "Pattern",
        "settings": "Wallpaper settings",
        "slug": "Unique wallpaper ID"
      }
    },
    "wallPaperNoFile": {
      "name": "wallPaperNoFile",
      "description": [
        "No file wallpaper"
      ],
      "fields": {
        "dark": "Dark mode",
        "default": "Whether this is the default wallpaper",
        "flags": "Flags, see TL conditional fields",
        "settings": "Wallpaper settings"
      }
    },
    "wallPaperSettings": {
      "name": "wallPaperSettings",
      "description": [
        "Wallpaper settings"
      ],
      "fields": {
        "background_color": "If set, a PNG pattern is to be combined with the color chosen by the user: the main color of the background in RGB24 format",
        "blur": "If set, the wallpaper must be downscaled to fit in 450x450 square and then box-blurred with radius 12",
        "flags": "Flags, see TL conditional fields",
        "intensity": "Intensity of the pattern when it is shown above the main background color, 0-100",
        "motion": "If set, the background needs to be slightly moved when device is rotated",
        "rotation": "Clockwise rotation angle of the gradient, in degrees; 0-359. Should be always divisible by 45",
        "second_background_color": "If set, a PNG pattern is to be combined with the first and second background colors (RGB24 format) in a top-bottom gradient"
      }
    },
    "webAuthorization": {
      "name": "webAuthorization",
      "description": [
        "Represents a bot logged in using the Telegram login widget"
      ],
      "fields": {
        "bot_id": "Bot ID",
        "browser": "Browser user-agent",
        "date_active": "When was the web session last active",
        "date_created": "When was the web session created",
        "domain": "The domain name of the website on which the user has logged in.",
        "hash": "Authorization hash",
        "ip": "IP address",
        "platform": "Platform",
        "region": "Region, determined from IP address"
      }
    },
    "webDocument": {
      "name": "webDocument",
      "description": [
        "Remote document"
      ],
      "fields": {
        "access_hash": "Access hash",
        "attributes": "Attributes for media types",
        "mime_type": "MIME type",
        "size": "File size",
        "url": "Document URL"
      }
    },
    "webDocumentNoProxy": {
      "name": "webDocumentNoProxy",
      "description": [
        "Remote document that can be downloaded without proxying through telegram"
      ],
      "fields": {
        "attributes": "Attributes for media types",
        "mime_type": "MIME type",
        "size": "File size",
        "url": "Document URL"
      }
    },
    "webPage": {
      "name": "webPage",
      "description": [
        "Webpage preview"
      ],
      "fields": {
        "attributes": "Webpage attributes",
        "author": "Author of the content",
        "cached_page": "Page contents in instant view format",
        "description": "Content description",
        "display_url": "Webpage URL to be displayed to the user",
        "document": "Preview of the content as a media file",
        "duration": "Duration of the content, in seconds",
        "embed_height": "Height of the embedded preview",
        "embed_type": "MIME type of the embedded preview, (e.g., text/html or video/mp4)",
        "embed_url": "URL to show in the embedded preview",
        "embed_width": "Width of the embedded preview",
        "flags": "Flags, see TL conditional fields",
        "hash": "Hash for pagination, for more info click here",
        "id": "Preview ID",
        "photo": "Image representing the content",
        "site_name": "Short name of the site (e.g., Google Docs, App Store)",
        "title": "Title of the content",
        "type": "Type of the web page. Can be: article, photo, audio, video, document, profile, app, or something else",
        "url": "URL of previewed webpage"
      }
    },
    "webPageAttributeTheme": {
      "name": "webPageAttributeTheme",
      "description": [
        "Page theme"
      ],
      "fields": {
        "documents": "Theme files",
        "flags": "Flags, see TL conditional fields",
        "settings": "Theme settings"
      }
    },
    "webPageEmpty": {
      "name": "webPageEmpty",
      "description": [
        "No preview is available for the webpage"
      ],
      "fields": {
        "id": "Preview ID"
      }
    },
    "webPageNotModified": {
      "name": "webPageNotModified",
      "description": [
        "The preview of the webpage hasn't changed"
      ],
      "fields": {
        "cached_page_views": "Page view count",
        "flags": "Flags, see TL conditional fields"
      }
    },
    "webPagePending": {
      "name": "webPagePending",
      "description": [
        "A preview of the webpage is currently being generated"
      ],
      "fields": {
        "date": "When was the processing started",
        "id": "ID of preview"
      }
    }
  },
  "types": {
    "#": {
      "name": "#",
      "description": [
        "A basic bare type, the values of which correspond to single-element sequences, i.e. unsigned numbers from 0 to 2^32-1 which in this case represent themselves.",
        "More on basic types "
      ]
    },
    "Account.AuthorizationForm": {
      "name": "Account.AuthorizationForm",
      "description": [
        "Authorization form"
      ]
    },
    "Account.Authorizations": {
      "name": "Account.Authorizations",
      "description": [
        "Logged-in sessions"
      ]
    },
    "Account.AutoDownloadSettings": {
      "name": "Account.AutoDownloadSettings",
      "description": [
        "Media autodownload settings"
      ]
    },
    "Account.PrivacyRules": {
      "name": "Account.PrivacyRules",
      "description": [
        "Privacy rules"
      ]
    },
    "Account.Takeout": {
      "name": "Account.Takeout",
      "description": [
        "Takeout info"
      ]
    },
    "Account.TmpPassword": {
      "name": "Account.TmpPassword",
      "description": [
        "Temporary password"
      ]
    },
    "Account.WallPapers": {
      "name": "Account.WallPapers",
      "description": [
        "Wallpapers"
      ]
    },
    "Account.WebAuthorizations": {
      "name": "Account.WebAuthorizations",
      "description": [
        "Web authorizations"
      ]
    },
    "AccountDaysTTL": {
      "name": "AccountDaysTTL",
      "description": [
        "Time-to-live of current account"
      ]
    },
    "Auth.ExportedAuthorization": {
      "name": "Auth.ExportedAuthorization",
      "description": [
        "Exported authorization"
      ]
    },
    "Authorization": {
      "name": "Authorization",
      "description": [
        "Represents a logged-in session"
      ]
    },
    "AutoDownloadSettings": {
      "name": "AutoDownloadSettings",
      "description": [
        "Media autodownload settings"
      ]
    },
    "BankCardOpenUrl": {
      "name": "BankCardOpenUrl",
      "description": [
        "Credit card info URL provided by the bank"
      ]
    },
    "BaseTheme": {
      "name": "BaseTheme",
      "description": [
        "Basic theme settings"
      ]
    },
    "Bool": {
      "name": "Bool",
      "description": [
        "Boolean type."
      ]
    },
    "BotCommand": {
      "name": "BotCommand",
      "description": [
        "Describes a bot command that can be used in a chat"
      ]
    },
    "BotInfo": {
      "name": "BotInfo",
      "description": [
        "Info about bots (available bot commands, etc)"
      ]
    },
    "BotInlineMessage": {
      "name": "BotInlineMessage",
      "description": [
        "Inline message"
      ]
    },
    "BotInlineResult": {
      "name": "BotInlineResult",
      "description": [
        "Results of an inline query"
      ]
    },
    "CdnConfig": {
      "name": "CdnConfig",
      "description": [
        "Configuration for CDN file downloads."
      ]
    },
    "CdnPublicKey": {
      "name": "CdnPublicKey",
      "description": [
        "Public key to use only during handshakes to CDN DCs."
      ]
    },
    "ChannelAdminLogEvent": {
      "name": "ChannelAdminLogEvent",
      "description": [
        "An event in a channel admin log"
      ]
    },
    "ChannelAdminLogEventAction": {
      "name": "ChannelAdminLogEventAction",
      "description": [
        "Channel admin log event"
      ]
    },
    "ChannelAdminLogEventsFilter": {
      "name": "ChannelAdminLogEventsFilter",
      "description": [
        "Filter for fetching events in the channel admin log"
      ]
    },
    "ChannelLocation": {
      "name": "ChannelLocation",
      "description": [
        "Geographical location of supergroup (geogroups)"
      ]
    },
    "ChannelMessagesFilter": {
      "name": "ChannelMessagesFilter",
      "description": [
        "Filter for fetching only certain types of channel messages"
      ]
    },
    "ChannelParticipant": {
      "name": "ChannelParticipant",
      "description": [
        "Channel participant"
      ]
    },
    "ChannelParticipantsFilter": {
      "name": "ChannelParticipantsFilter",
      "description": [
        "Filter for fetching channel participants"
      ]
    },
    "Channels.AdminLogResults": {
      "name": "Channels.AdminLogResults",
      "description": [
        "Admin log events"
      ]
    },
    "Channels.ChannelParticipant": {
      "name": "Channels.ChannelParticipant",
      "description": [
        "Channel participant"
      ]
    },
    "Channels.ChannelParticipants": {
      "name": "Channels.ChannelParticipants",
      "description": [
        "Channel/supergroup participants"
      ]
    },
    "Chat": {
      "name": "Chat",
      "description": [
        "Object defines a group."
      ]
    },
    "ChatAdminRights": {
      "name": "ChatAdminRights",
      "description": [
        "Represents the rights of an admin in a channel/supergroup."
      ]
    },
    "ChatBannedRights": {
      "name": "ChatBannedRights",
      "description": [
        "Represents the rights of a normal user in a supergroup/channel/chat."
      ]
    },
    "ChatFull": {
      "name": "ChatFull",
      "description": [
        "Object containing detailed group info"
      ]
    },
    "ChatInvite": {
      "name": "ChatInvite",
      "description": [
        "Chat invite"
      ]
    },
    "ChatOnlines": {
      "name": "ChatOnlines",
      "description": [
        "Number of online users in a chat"
      ]
    },
    "ChatParticipant": {
      "name": "ChatParticipant",
      "description": [
        "Details of a group member."
      ]
    },
    "ChatParticipants": {
      "name": "ChatParticipants",
      "description": [
        "Object contains info on group members."
      ]
    },
    "ChatPhoto": {
      "name": "ChatPhoto",
      "description": [
        "Object defines a group profile photo."
      ]
    },
    "CodeSettings": {
      "name": "CodeSettings",
      "description": [
        "Settings for the code type to send"
      ]
    },
    "Config": {
      "name": "Config",
      "description": [
        "Object contains info on API configuring parameters."
      ]
    },
    "Contact": {
      "name": "Contact",
      "description": [
        "A contact of the current user."
      ]
    },
    "ContactStatus": {
      "name": "ContactStatus",
      "description": [
        "Contact status: online / offline."
      ]
    },
    "Contacts.ResolvedPeer": {
      "name": "Contacts.ResolvedPeer",
      "description": [
        "Peer returned after resolving a @username"
      ]
    },
    "Contacts.TopPeers": {
      "name": "Contacts.TopPeers",
      "description": [
        "Top peers"
      ]
    },
    "DataJSON": {
      "name": "DataJSON",
      "description": [
        "Represent a JSON-encoded object"
      ]
    },
    "DcOption": {
      "name": "DcOption",
      "description": [
        "Information for connection to data centre."
      ]
    },
    "Dialog": {
      "name": "Dialog",
      "description": [
        "Chat info."
      ]
    },
    "DialogFilter": {
      "name": "DialogFilter",
      "description": [
        "Dialog filter (folders)"
      ]
    },
    "DialogFilterSuggested": {
      "name": "DialogFilterSuggested",
      "description": [
        "Suggested dialog filters (folders)"
      ]
    },
    "DialogPeer": {
      "name": "DialogPeer",
      "description": [
        "Peer, or all peers in a folder"
      ]
    },
    "Document": {
      "name": "Document",
      "description": [
        "A document."
      ]
    },
    "DocumentAttribute": {
      "name": "DocumentAttribute",
      "description": [
        "Various possible attributes of a document (used to define if it's a sticker, a GIF, a video, a mask sticker, an image, an audio, and so on)"
      ]
    },
    "DraftMessage": {
      "name": "DraftMessage",
      "description": [
        "Represents a message draft."
      ]
    },
    "EmojiKeyword": {
      "name": "EmojiKeyword",
      "description": [
        "Emoji keyword"
      ]
    },
    "EmojiKeywordsDifference": {
      "name": "EmojiKeywordsDifference",
      "description": [
        "New emoji keywords"
      ]
    },
    "EmojiLanguage": {
      "name": "EmojiLanguage",
      "description": [
        "Emoji language"
      ]
    },
    "EmojiURL": {
      "name": "EmojiURL",
      "description": [
        "Emoji URL"
      ]
    },
    "EncryptedChat": {
      "name": "EncryptedChat",
      "description": [
        "Object contains info on an encrypted chat."
      ]
    },
    "EncryptedFile": {
      "name": "EncryptedFile",
      "description": [
        "Seta an encrypted file."
      ]
    },
    "EncryptedMessage": {
      "name": "EncryptedMessage",
      "description": [
        "Object contains encrypted message."
      ]
    },
    "Error": {
      "name": "Error",
      "description": [
        "An object containing a query error."
      ]
    },
    "ExportedChatInvite": {
      "name": "ExportedChatInvite",
      "description": [
        "Exported chat invite"
      ]
    },
    "ExportedMessageLink": {
      "name": "ExportedMessageLink",
      "description": [
        "HTTP link and embed info of channel message"
      ]
    },
    "FileHash": {
      "name": "FileHash",
      "description": [
        "Hash of an uploaded file, to be checked for validity after download"
      ]
    },
    "FileLocation": {
      "name": "FileLocation",
      "description": [
        "Indicates the location of a photo, will be deprecated soon"
      ]
    },
    "Folder": {
      "name": "Folder",
      "description": [
        "A folder"
      ]
    },
    "FolderPeer": {
      "name": "FolderPeer",
      "description": [
        "Peer associated to folder"
      ]
    },
    "Game": {
      "name": "Game",
      "description": [
        "Indicates an already sent game"
      ]
    },
    "GeoPoint": {
      "name": "GeoPoint",
      "description": [
        "Object defines a GeoPoint."
      ]
    },
    "GlobalPrivacySettings": {
      "name": "GlobalPrivacySettings",
      "description": [
        "Global privacy settings"
      ]
    },
    "Help.DeepLinkInfo": {
      "name": "Help.DeepLinkInfo",
      "description": [
        "Contains information about a tg:// deep link"
      ]
    },
    "Help.PassportConfig": {
      "name": "Help.PassportConfig",
      "description": [
        "Telegram passport configuration"
      ]
    },
    "Help.RecentMeUrls": {
      "name": "Help.RecentMeUrls",
      "description": [
        "Recent t.me URLs"
      ]
    },
    "Help.SupportName": {
      "name": "Help.SupportName",
      "description": [
        "Get localized name for support user"
      ]
    },
    "Help.TermsOfServiceUpdate": {
      "name": "Help.TermsOfServiceUpdate",
      "description": [
        "Update of Telegram's terms of service"
      ]
    },
    "Help.UserInfo": {
      "name": "Help.UserInfo",
      "description": [
        "User info"
      ]
    },
    "HighScore": {
      "name": "HighScore",
      "description": [
        "Game high score"
      ]
    },
    "ImportedContact": {
      "name": "ImportedContact",
      "description": [
        "Object contains info on a successfully imported contact."
      ]
    },
    "InlineBotSwitchPM": {
      "name": "InlineBotSwitchPM",
      "description": [
        "The bot requested the user to message him in private"
      ]
    },
    "InputAppEvent": {
      "name": "InputAppEvent",
      "description": [
        "Object contains info about an event that occured in the application."
      ]
    },
    "InputBotInlineMessage": {
      "name": "InputBotInlineMessage",
      "description": [
        "Represents a sent inline message from the perspective of a bot"
      ]
    },
    "InputBotInlineMessageID": {
      "name": "InputBotInlineMessageID",
      "description": [
        "Represents a sent inline message from the perspective of a bot"
      ]
    },
    "InputBotInlineResult": {
      "name": "InputBotInlineResult",
      "description": [
        "Inline bot result"
      ]
    },
    "InputChannel": {
      "name": "InputChannel",
      "description": [
        "Represents a channel"
      ]
    },
    "InputChatPhoto": {
      "name": "InputChatPhoto",
      "description": [
        "Defines a new group profile photo."
      ]
    },
    "InputCheckPasswordSRP": {
      "name": "InputCheckPasswordSRP",
      "description": [
        "Constructors for checking the validity of a 2FA SRP password"
      ]
    },
    "InputClientProxy": {
      "name": "InputClientProxy",
      "description": [
        "Info about an MTProxy used to connect."
      ]
    },
    "InputContact": {
      "name": "InputContact",
      "description": [
        "Object defines a contact from the user's phonebook."
      ]
    },
    "InputDialogPeer": {
      "name": "InputDialogPeer",
      "description": [
        "Peer, or all peers in a certain folder"
      ]
    },
    "InputDocument": {
      "name": "InputDocument",
      "description": [
        "Defines a document for subsequent interaction."
      ]
    },
    "InputEncryptedChat": {
      "name": "InputEncryptedChat",
      "description": [
        "Object sets an encrypted chat ID."
      ]
    },
    "InputEncryptedFile": {
      "name": "InputEncryptedFile",
      "description": [
        "Object sets encrypted file for attachment"
      ]
    },
    "InputFile": {
      "name": "InputFile",
      "description": [
        "Defines a file uploaded by the client."
      ]
    },
    "InputFileLocation": {
      "name": "InputFileLocation",
      "description": [
        "Defines the location of a file for download."
      ]
    },
    "InputFolderPeer": {
      "name": "InputFolderPeer",
      "description": [
        "Peer in a folder"
      ]
    },
    "InputGame": {
      "name": "InputGame",
      "description": [
        "A game to send"
      ]
    },
    "InputGeoPoint": {
      "name": "InputGeoPoint",
      "description": [
        "Defines a GeoPoint."
      ]
    },
    "InputMedia": {
      "name": "InputMedia",
      "description": [
        "Defines media content of a message."
      ]
    },
    "InputMessage": {
      "name": "InputMessage",
      "description": [
        "A message"
      ]
    },
    "InputNotifyPeer": {
      "name": "InputNotifyPeer",
      "description": [
        "Object defines the set of users and/or groups that generate notifications."
      ]
    },
    "InputPaymentCredentials": {
      "name": "InputPaymentCredentials",
      "description": [
        "Payment credentials"
      ]
    },
    "InputPeer": {
      "name": "InputPeer",
      "description": [
        "Peer"
      ]
    },
    "InputPeerNotifySettings": {
      "name": "InputPeerNotifySettings",
      "description": [
        "Notifications settings."
      ]
    },
    "InputPhoneCall": {
      "name": "InputPhoneCall",
      "description": [
        "Phone call"
      ]
    },
    "InputPhoto": {
      "name": "InputPhoto",
      "description": [
        "Defines a photo for further interaction."
      ]
    },
    "InputPrivacyKey": {
      "name": "InputPrivacyKey",
      "description": [
        "Privacy key"
      ]
    },
    "InputPrivacyRule": {
      "name": "InputPrivacyRule",
      "description": [
        "Privacy rule"
      ]
    },
    "InputSecureFile": {
      "name": "InputSecureFile",
      "description": [
        "Secure passport file, for more info see the passport docs "
      ]
    },
    "InputSecureValue": {
      "name": "InputSecureValue",
      "description": [
        "Secure value, for more info see the passport docs "
      ]
    },
    "InputSingleMedia": {
      "name": "InputSingleMedia",
      "description": [
        "A single media in an album or grouped media sent with messages.sendMultiMedia."
      ]
    },
    "InputStickerSet": {
      "name": "InputStickerSet",
      "description": [
        "Represents a stickerset"
      ]
    },
    "InputStickerSetItem": {
      "name": "InputStickerSetItem",
      "description": [
        "Sticker"
      ]
    },
    "InputStickeredMedia": {
      "name": "InputStickeredMedia",
      "description": [
        "Represents a media with attached stickers"
      ]
    },
    "InputTheme": {
      "name": "InputTheme",
      "description": [
        "Cloud theme"
      ]
    },
    "InputThemeSettings": {
      "name": "InputThemeSettings",
      "description": [
        "Theme settings"
      ]
    },
    "InputUser": {
      "name": "InputUser",
      "description": [
        "Defines a user for subsequent interaction."
      ]
    },
    "InputWallPaper": {
      "name": "InputWallPaper",
      "description": [
        "Wallpaper"
      ]
    },
    "InputWebDocument": {
      "name": "InputWebDocument",
      "description": [
        "Specifies a document that will have to be downloaded from the URL by the telegram servers"
      ]
    },
    "InputWebFileLocation": {
      "name": "InputWebFileLocation",
      "description": [
        "Location of remote file"
      ]
    },
    "Invoice": {
      "name": "Invoice",
      "description": [
        "Invoice"
      ]
    },
    "JSONObjectValue": {
      "name": "JSONObjectValue",
      "description": [
        "JSON key: value pair"
      ]
    },
    "JSONValue": {
      "name": "JSONValue",
      "description": [
        "JSON value"
      ]
    },
    "KeyboardButton": {
      "name": "KeyboardButton",
      "description": [
        "Bot or inline keyboard buttons"
      ]
    },
    "KeyboardButtonRow": {
      "name": "KeyboardButtonRow",
      "description": [
        "Bot or inline keyboard rows"
      ]
    },
    "LabeledPrice": {
      "name": "LabeledPrice",
      "description": [
        "Labeled pricetag"
      ]
    },
    "LangPackDifference": {
      "name": "LangPackDifference",
      "description": [
        "Language pack changes"
      ]
    },
    "LangPackLanguage": {
      "name": "LangPackLanguage",
      "description": [
        "Language pack language"
      ]
    },
    "LangPackString": {
      "name": "LangPackString",
      "description": [
        "Language pack string"
      ]
    },
    "MaskCoords": {
      "name": "MaskCoords",
      "description": [
        "Mask coordinates (if this is a mask sticker, attached to a photo)"
      ]
    },
    "Message": {
      "name": "Message",
      "description": [
        "Object describing a message."
      ]
    },
    "MessageAction": {
      "name": "MessageAction",
      "description": [
        "Object describing actions connected to a service message."
      ]
    },
    "MessageEntity": {
      "name": "MessageEntity",
      "description": [
        "Message entities, representing styled text in a message"
      ]
    },
    "MessageFwdHeader": {
      "name": "MessageFwdHeader",
      "description": [
        "Info about a forwarded message"
      ]
    },
    "MessageInteractionCounters": {
      "name": "MessageInteractionCounters",
      "description": [
        "Message interaction counters"
      ]
    },
    "MessageMedia": {
      "name": "MessageMedia",
      "description": [
        "Media"
      ]
    },
    "MessageRange": {
      "name": "MessageRange",
      "description": [
        "Indicates a range of chat messages"
      ]
    },
    "MessageReplies": {
      "name": "MessageReplies",
      "description": [
        "Info about post comments (for channels) or message replies (for groups)"
      ]
    },
    "MessageReplyHeader": {
      "name": "MessageReplyHeader",
      "description": [
        "Reply information"
      ]
    },
    "MessageUserVote": {
      "name": "MessageUserVote",
      "description": [
        "How a user voted in a poll"
      ]
    },
    "MessageViews": {
      "name": "MessageViews",
      "description": [
        "View, forward counter + info about replies of a specific message"
      ]
    },
    "Messages.AffectedMessages": {
      "name": "Messages.AffectedMessages",
      "description": [
        "Messages affected by changes"
      ]
    },
    "Messages.AllStickers": {
      "name": "Messages.AllStickers",
      "description": [
        "All stickers"
      ]
    },
    "Messages.ArchivedStickers": {
      "name": "Messages.ArchivedStickers",
      "description": [
        "Archived stickers"
      ]
    },
    "Messages.BotCallbackAnswer": {
      "name": "Messages.BotCallbackAnswer",
      "description": [
        "Callback answer of bot"
      ]
    },
    "Messages.DhConfig": {
      "name": "Messages.DhConfig",
      "description": [
        "Contains info on cofiguring parameters for key generation by Diffie-Hellman protocol."
      ]
    },
    "Messages.FavedStickers": {
      "name": "Messages.FavedStickers",
      "description": [
        "Favorited stickers"
      ]
    },
    "Messages.FeaturedStickers": {
      "name": "Messages.FeaturedStickers",
      "description": [
        "Featured stickers"
      ]
    },
    "Messages.FoundStickerSets": {
      "name": "Messages.FoundStickerSets",
      "description": [
        "Found stickersets"
      ]
    },
    "Messages.HighScores": {
      "name": "Messages.HighScores",
      "description": [
        "High scores (in games)"
      ]
    },
    "Messages.MessageEditData": {
      "name": "Messages.MessageEditData",
      "description": [
        "Message edit data for media"
      ]
    },
    "Messages.PeerDialogs": {
      "name": "Messages.PeerDialogs",
      "description": [
        "List of dialogs"
      ]
    },
    "Messages.RecentStickers": {
      "name": "Messages.RecentStickers",
      "description": [
        "Recent stickers"
      ]
    },
    "Messages.SavedGifs": {
      "name": "Messages.SavedGifs",
      "description": [
        "Saved GIFs"
      ]
    },
    "Messages.SearchCounter": {
      "name": "Messages.SearchCounter",
      "description": [
        "Number of results that would be returned by a search"
      ]
    },
    "Messages.SentEncryptedMessage": {
      "name": "Messages.SentEncryptedMessage",
      "description": [
        "Contains info on message sent to an encrypted chat."
      ]
    },
    "Messages.StickerSet": {
      "name": "Messages.StickerSet",
      "description": [
        "Stickerset"
      ]
    },
    "Messages.StickerSetInstallResult": {
      "name": "Messages.StickerSetInstallResult",
      "description": [
        "Result of stickerset installation process"
      ]
    },
    "Messages.Stickers": {
      "name": "Messages.Stickers",
      "description": [
        "Stickers"
      ]
    },
    "MessagesFilter": {
      "name": "MessagesFilter",
      "description": [
        "Object describes message filter."
      ]
    },
    "NearestDc": {
      "name": "NearestDc",
      "description": [
        "Object contains info on nearest data centre."
      ]
    },
    "NotifyPeer": {
      "name": "NotifyPeer",
      "description": [
        "Object defines the set of users and/or groups that generate notifications."
      ]
    },
    "Null": {
      "name": "Null",
      "description": [
        "Object corresponds to an arbitrary empty object."
      ]
    },
    "Page": {
      "name": "Page",
      "description": [
        "Instant view page"
      ]
    },
    "PageBlock": {
      "name": "PageBlock",
      "description": [
        "Represents an instant view page element"
      ]
    },
    "PageCaption": {
      "name": "PageCaption",
      "description": [
        "Page caption"
      ]
    },
    "PageListItem": {
      "name": "PageListItem",
      "description": [
        "Item in block list"
      ]
    },
    "PageListOrderedItem": {
      "name": "PageListOrderedItem",
      "description": [
        "Represents an instant view ordered list"
      ]
    },
    "PageRelatedArticle": {
      "name": "PageRelatedArticle",
      "description": [
        "Related articles"
      ]
    },
    "PageTableCell": {
      "name": "PageTableCell",
      "description": [
        "Represents a table in an instant view table"
      ]
    },
    "PageTableRow": {
      "name": "PageTableRow",
      "description": [
        "Table row"
      ]
    },
    "PasswordKdfAlgo": {
      "name": "PasswordKdfAlgo",
      "description": [
        "Key derivation function to use when generating the password hash for SRP two-factor authorization"
      ]
    },
    "PaymentCharge": {
      "name": "PaymentCharge",
      "description": [
        "Charged payment"
      ]
    },
    "PaymentRequestedInfo": {
      "name": "PaymentRequestedInfo",
      "description": [
        "Requested payment info"
      ]
    },
    "PaymentSavedCredentials": {
      "name": "PaymentSavedCredentials",
      "description": [
        "Saved payment credentials"
      ]
    },
    "Payments.PaymentForm": {
      "name": "Payments.PaymentForm",
      "description": [
        "Payment form"
      ]
    },
    "Payments.PaymentReceipt": {
      "name": "Payments.PaymentReceipt",
      "description": [
        "Payment receipt"
      ]
    },
    "Payments.PaymentResult": {
      "name": "Payments.PaymentResult",
      "description": [
        "Payment result"
      ]
    },
    "Payments.SavedInfo": {
      "name": "Payments.SavedInfo",
      "description": [
        "Saved payment info"
      ]
    },
    "Payments.ValidatedRequestedInfo": {
      "name": "Payments.ValidatedRequestedInfo",
      "description": [
        "Validated requested info"
      ]
    },
    "Peer": {
      "name": "Peer",
      "description": [
        "Chat partner or group."
      ]
    },
    "PeerBlocked": {
      "name": "PeerBlocked",
      "description": [
        "Info about a blocked user"
      ]
    },
    "PeerLocated": {
      "name": "PeerLocated",
      "description": [
        "Geolocated peer"
      ]
    },
    "PeerNotifySettings": {
      "name": "PeerNotifySettings",
      "description": [
        "Notification settings."
      ]
    },
    "PeerSettings": {
      "name": "PeerSettings",
      "description": [
        "Peer settings"
      ]
    },
    "Phone.PhoneCall": {
      "name": "Phone.PhoneCall",
      "description": [
        "Phone call"
      ]
    },
    "PhoneCall": {
      "name": "PhoneCall",
      "description": [
        "Phone call"
      ]
    },
    "PhoneCallDiscardReason": {
      "name": "PhoneCallDiscardReason",
      "description": [
        "Why was the phone call discarded?"
      ]
    },
    "PhoneCallProtocol": {
      "name": "PhoneCallProtocol",
      "description": [
        "Phone call protocol"
      ]
    },
    "PhoneConnection": {
      "name": "PhoneConnection",
      "description": [
        "Phone call connection"
      ]
    },
    "Photo": {
      "name": "Photo",
      "description": [
        "Object describes a photo."
      ]
    },
    "PhotoSize": {
      "name": "PhotoSize",
      "description": [
        "Location of a certain size of a picture"
      ]
    },
    "Poll": {
      "name": "Poll",
      "description": [
        "Indicates a poll message"
      ]
    },
    "PollAnswer": {
      "name": "PollAnswer",
      "description": [
        "Indicates a possible answer to a poll."
      ]
    },
    "PollAnswerVoters": {
      "name": "PollAnswerVoters",
      "description": [
        "How users voted on a certain poll answer"
      ]
    },
    "PollResults": {
      "name": "PollResults",
      "description": [
        "Results of poll"
      ]
    },
    "PopularContact": {
      "name": "PopularContact",
      "description": [
        "Popular contact"
      ]
    },
    "PostAddress": {
      "name": "PostAddress",
      "description": [
        "Shipping address"
      ]
    },
    "PrivacyKey": {
      "name": "PrivacyKey",
      "description": [
        "Privacy key"
      ]
    },
    "PrivacyRule": {
      "name": "PrivacyRule",
      "description": [
        "Privacy rule"
      ]
    },
    "ReceivedNotifyMessage": {
      "name": "ReceivedNotifyMessage",
      "description": [
        "Confirmation of message receipt"
      ]
    },
    "RecentMeUrl": {
      "name": "RecentMeUrl",
      "description": [
        "Recent t.me urls"
      ]
    },
    "ReplyMarkup": {
      "name": "ReplyMarkup",
      "description": [
        "Reply markup for bot and inline keyboards"
      ]
    },
    "ReportReason": {
      "name": "ReportReason",
      "description": [
        "Report reason"
      ]
    },
    "RestrictionReason": {
      "name": "RestrictionReason",
      "description": [
        "Restriction reason"
      ]
    },
    "RichText": {
      "name": "RichText",
      "description": [
        "Rich text"
      ]
    },
    "SavedContact": {
      "name": "SavedContact",
      "description": [
        "Saved contact"
      ]
    },
    "SecureCredentialsEncrypted": {
      "name": "SecureCredentialsEncrypted",
      "description": [
        "Encrypted secure credentials"
      ]
    },
    "SecureData": {
      "name": "SecureData",
      "description": [
        "Secure passport data, for more info see the passport docs "
      ]
    },
    "SecureFile": {
      "name": "SecureFile",
      "description": [
        "Secure passport file, for more info see the passport docs "
      ]
    },
    "SecurePasswordKdfAlgo": {
      "name": "SecurePasswordKdfAlgo",
      "description": [
        "KDF algorithm to use for computing telegram passport hash"
      ]
    },
    "SecurePlainData": {
      "name": "SecurePlainData",
      "description": [
        "Plaintext verified passport data."
      ]
    },
    "SecureRequiredType": {
      "name": "SecureRequiredType",
      "description": [
        "Required secure file type"
      ]
    },
    "SecureSecretSettings": {
      "name": "SecureSecretSettings",
      "description": [
        "Telegram passport settings"
      ]
    },
    "SecureValue": {
      "name": "SecureValue",
      "description": [
        "Secure tgpassport value"
      ]
    },
    "SecureValueError": {
      "name": "SecureValueError",
      "description": [
        "Secure value error"
      ]
    },
    "SecureValueHash": {
      "name": "SecureValueHash",
      "description": [
        "Secure value hash"
      ]
    },
    "SecureValueType": {
      "name": "SecureValueType",
      "description": [
        "Secure value type"
      ]
    },
    "SendMessageAction": {
      "name": "SendMessageAction",
      "description": [
        "User actions. Use this to provide users with detailed info about their chat partners' actions: typing or sending attachments of all kinds."
      ]
    },
    "ShippingOption": {
      "name": "ShippingOption",
      "description": [
        "Shipping options"
      ]
    },
    "Stats.BroadcastStats": {
      "name": "Stats.BroadcastStats",
      "description": [
        "Channel statistics"
      ]
    },
    "StatsAbsValueAndPrev": {
      "name": "StatsAbsValueAndPrev",
      "description": [
        "Channel statistics value pair"
      ]
    },
    "StatsDateRangeDays": {
      "name": "StatsDateRangeDays",
      "description": [
        "Channel statistics date range"
      ]
    },
    "StatsGraph": {
      "name": "StatsGraph",
      "description": [
        "Channel statistics graph"
      ]
    },
    "StatsGroupTopAdmin": {
      "name": "StatsGroupTopAdmin",
      "description": [
        "Most active admin in a supergroup"
      ]
    },
    "StatsGroupTopInviter": {
      "name": "StatsGroupTopInviter",
      "description": [
        "Most active inviter in a supergroup"
      ]
    },
    "StatsGroupTopPoster": {
      "name": "StatsGroupTopPoster",
      "description": [
        "Most active user in a supergroup"
      ]
    },
    "StatsPercentValue": {
      "name": "StatsPercentValue",
      "description": [
        "Channel statistics percentage"
      ]
    },
    "StatsURL": {
      "name": "StatsURL",
      "description": [
        "URL with chat statistics"
      ]
    },
    "StickerPack": {
      "name": "StickerPack",
      "description": [
        "Stickerpack"
      ]
    },
    "StickerSet": {
      "name": "StickerSet",
      "description": [
        "Represents a stickerset (stickerpack)"
      ]
    },
    "StickerSetCovered": {
      "name": "StickerSetCovered",
      "description": [
        "Stickerset, with a specific sticker as preview"
      ]
    },
    "Theme": {
      "name": "Theme",
      "description": [
        "Cloud theme"
      ]
    },
    "ThemeSettings": {
      "name": "ThemeSettings",
      "description": [
        "Theme settings"
      ]
    },
    "TopPeer": {
      "name": "TopPeer",
      "description": [
        "Top peer"
      ]
    },
    "TopPeerCategory": {
      "name": "TopPeerCategory",
      "description": [
        "Top peer category"
      ]
    },
    "TopPeerCategoryPeers": {
      "name": "TopPeerCategoryPeers",
      "description": [
        "Top peers by top peer category"
      ]
    },
    "True": {
      "name": "True",
      "description": [
        "See predefined identifiers."
      ]
    },
    "Update": {
      "name": "Update",
      "description": [
        "Object contains info on events occured."
      ]
    },
    "Updates": {
      "name": "Updates",
      "description": [
        "Object which is perceived by the client without a call on its part when an event occurs."
      ]
    },
    "Upload.WebFile": {
      "name": "Upload.WebFile",
      "description": [
        "Remote file"
      ]
    },
    "UrlAuthResult": {
      "name": "UrlAuthResult",
      "description": [
        "URL authorization result"
      ]
    },
    "User": {
      "name": "User",
      "description": [
        "Object defines a user."
      ]
    },
    "UserFull": {
      "name": "UserFull",
      "description": [
        "Object contains extended user info."
      ]
    },
    "UserProfilePhoto": {
      "name": "UserProfilePhoto",
      "description": [
        "Object contains info on the user's profile photo."
      ]
    },
    "UserStatus": {
      "name": "UserStatus",
      "description": [
        "User online status"
      ]
    },
    "Vector t": {
      "name": "Vector t",
      "description": [
        "Universal vector."
      ]
    },
    "VideoSize": {
      "name": "VideoSize",
      "description": [
        "Represents an animated video thumbnail"
      ]
    },
    "WallPaper": {
      "name": "WallPaper",
      "description": [
        "Object contains info on a wallpaper."
      ]
    },
    "WallPaperSettings": {
      "name": "WallPaperSettings",
      "description": [
        "Wallpaper settings"
      ]
    },
    "WebAuthorization": {
      "name": "WebAuthorization",
      "description": [
        "Web authorization"
      ]
    },
    "WebDocument": {
      "name": "WebDocument",
      "description": [
        "Remote document"
      ]
    },
    "WebPage": {
      "name": "WebPage",
      "description": [
        "Instant View webpage preview"
      ]
    },
    "WebPageAttribute": {
      "name": "WebPageAttribute",
      "description": [
        "Webpage attributes"
      ]
    },
    "account.ContentSettings": {
      "name": "account.ContentSettings",
      "description": [
        "Sensitive content settings"
      ]
    },
    "account.Password": {
      "name": "account.Password",
      "description": [
        "Configuration for two-factor authorization"
      ]
    },
    "account.PasswordInputSettings": {
      "name": "account.PasswordInputSettings",
      "description": [
        "Constructor for setting up a new 2FA SRP password"
      ]
    },
    "account.PasswordSettings": {
      "name": "account.PasswordSettings",
      "description": [
        "Private info associated to the password info (recovery email, telegram passport info \u0026 so on)"
      ]
    },
    "account.SentEmailCode": {
      "name": "account.SentEmailCode",
      "description": [
        "The email code that was sent"
      ]
    },
    "account.Themes": {
      "name": "account.Themes",
      "description": [
        "Installed themes"
      ]
    },
    "auth.Authorization": {
      "name": "auth.Authorization",
      "description": [
        "Oject contains info on user authorization."
      ]
    },
    "auth.CodeType": {
      "name": "auth.CodeType",
      "description": [
        "Type of verification code that will be sent next if you call the resendCode method"
      ]
    },
    "auth.LoginToken": {
      "name": "auth.LoginToken",
      "description": [
        "Login token (for QR code login)"
      ]
    },
    "auth.PasswordRecovery": {
      "name": "auth.PasswordRecovery",
      "description": [
        "Recovery info of a 2FA password, only for accounts with a recovery email configured."
      ]
    },
    "auth.SentCode": {
      "name": "auth.SentCode",
      "description": [
        "Contains info on a confirmation code message sent via SMS, phone call or Telegram."
      ]
    },
    "auth.SentCodeType": {
      "name": "auth.SentCodeType",
      "description": [
        "Type of the verification code that was sent"
      ]
    },
    "bytes": {
      "name": "bytes",
      "description": [
        "Basic bare type. It is an alias of the string type, with the difference that the value may contain arbitrary byte sequences, including invalid UTF-8 sequences.",
        "When computing crc32 for a constructor or method it is necessary to replace all byte types with string types.",
        "A basic bare type. Values of type string look differently depending on the length L of the string being serialized:",
        "All strings passed to the API must be encoded in UTF-8. When arbitrary byte sequences have to be serialized, bytes alias is to be used.",
        "Further details on basic types"
      ]
    },
    "contacts.Blocked": {
      "name": "contacts.Blocked",
      "description": [
        "Info on users from the current user's black list."
      ]
    },
    "contacts.Contacts": {
      "name": "contacts.Contacts",
      "description": [
        "Info on the current user's contact list."
      ]
    },
    "contacts.Found": {
      "name": "contacts.Found",
      "description": [
        "Object contains info on users found by name substring and auxiliary data."
      ]
    },
    "contacts.ImportedContacts": {
      "name": "contacts.ImportedContacts",
      "description": [
        "Object contains info on succesfully imported contacts."
      ]
    },
    "double": {
      "name": "double",
      "description": [
        "A basic bare type, values of which correspond two-element sequences containing 64-bit real numbers in a standard double format.",
        "More on basic types"
      ]
    },
    "help.AppUpdate": {
      "name": "help.AppUpdate",
      "description": [
        "Contains info on app update availability."
      ]
    },
    "help.CountriesList": {
      "name": "help.CountriesList",
      "description": [
        "Name, ISO code, localized name and phone codes/patterns of all available countries"
      ]
    },
    "help.Country": {
      "name": "help.Country",
      "description": [
        "Name, ISO code, localized name and phone codes/patterns of a specific country"
      ]
    },
    "help.CountryCode": {
      "name": "help.CountryCode",
      "description": [
        "Country code and phone number pattern of a specific country"
      ]
    },
    "help.InviteText": {
      "name": "help.InviteText",
      "description": [
        "Object contains info on the text of a message with an invitation."
      ]
    },
    "help.PromoData": {
      "name": "help.PromoData",
      "description": [
        "Info about pinned MTProxy or Public Service Announcement peers."
      ]
    },
    "help.Support": {
      "name": "help.Support",
      "description": [
        "Info about the support user, relevant to the current user."
      ]
    },
    "help.TermsOfService": {
      "name": "help.TermsOfService",
      "description": [
        "Contains info about the latest telegram Terms Of Service."
      ]
    },
    "int": {
      "name": "int",
      "description": [
        "A basic bare type, the values of which correspond to single-element sequences, i.e. numbers from -2^31 to 2^31-1 which in this case represent themselves.",
        "More on basic types "
      ]
    },
    "long": {
      "name": "long",
      "description": [
        "A basic bare type, elements of which correspond to two-element sequences, representing 64-bit signed numbers (little-endian).",
        "More on basic types "
      ]
    },
    "messages.AffectedHistory": {
      "name": "messages.AffectedHistory",
      "description": [
        "Object contains info on affected part of communication history with the user or in a chat."
      ]
    },
    "messages.BotResults": {
      "name": "messages.BotResults",
      "description": [
        "Result of a query to an inline bot"
      ]
    },
    "messages.ChatFull": {
      "name": "messages.ChatFull",
      "description": [
        "Object contains extended info on chat with auxiliary data."
      ]
    },
    "messages.Chats": {
      "name": "messages.Chats",
      "description": [
        "Object contains list of chats with auxiliary data."
      ]
    },
    "messages.Dialogs": {
      "name": "messages.Dialogs",
      "description": [
        "Object contains a list of chats with messages and auxiliary data."
      ]
    },
    "messages.DiscussionMessage": {
      "name": "messages.DiscussionMessage",
      "description": [
        "Info about a message thread"
      ]
    },
    "messages.InactiveChats": {
      "name": "messages.InactiveChats",
      "description": [
        "Inactive chat list"
      ]
    },
    "messages.MessageViews": {
      "name": "messages.MessageViews",
      "description": [
        "View, forward counter + info about replies"
      ]
    },
    "messages.Messages": {
      "name": "messages.Messages",
      "description": [
        "Object contains infor on list of messages with auxiliary data."
      ]
    },
    "messages.VotesList": {
      "name": "messages.VotesList",
      "description": [
        "How users voted in a poll"
      ]
    },
    "payments.BankCardData": {
      "name": "payments.BankCardData",
      "description": [
        "Credit card info, provided by the card's bank(s)"
      ]
    },
    "photos.Photo": {
      "name": "photos.Photo",
      "description": [
        "Photo with auxiliary data."
      ]
    },
    "photos.Photos": {
      "name": "photos.Photos",
      "description": [
        "Object contains list of photos with auxiliary data."
      ]
    },
    "stats.MegagroupStats": {
      "name": "stats.MegagroupStats",
      "description": [
        "Supergroup statistics"
      ]
    },
    "stats.MessageStats": {
      "name": "stats.MessageStats",
      "description": [
        "Message statistics"
      ]
    },
    "storage.FileType": {
      "name": "storage.FileType",
      "description": [
        "Object describes the file type."
      ]
    },
    "string": {
      "name": "string",
      "description": [
        "A basic bare type. Values of type string look differently depending on the length L of the string being serialized:",
        "All strings passed to the API must be encoded in UTF-8. When arbitrary byte sequences have to be serialized, bytes alias is to be used.",
        "Further details on basic types",
        "Basic bare type. It is an alias of the string type, with the difference that the value may contain arbitrary byte sequences, including invalid UTF-8 sequences.",
        "When computing crc32 for a constructor or method it is necessary to replace all byte types with string types."
      ]
    },
    "updates.ChannelDifference": {
      "name": "updates.ChannelDifference",
      "description": [
        "Contains the difference (new messages) between our local channel state and the remote state"
      ]
    },
    "updates.Difference": {
      "name": "updates.Difference",
      "description": [
        "Occurred changes."
      ]
    },
    "updates.State": {
      "name": "updates.State",
      "description": [
        "Object contains info on state for further updates."
      ]
    },
    "upload.CdnFile": {
      "name": "upload.CdnFile",
      "description": [
        "Represents the download status of a CDN file"
      ]
    },
    "upload.File": {
      "name": "upload.File",
      "description": [
        "Contains info on file."
      ]
    }
  },
  "methods": {
    "account.acceptAuthorization": {
      "name": "account.acceptAuthorization",
      "description": [
        "Sends a Telegram Passport authorization form, effectively sharing data with the service"
      ],
      "parameters": {
        "bot_id": "Bot ID",
        "credentials": "Encrypted values",
        "public_key": "Service's public key",
        "scope": "Telegram Passport element types requested by the service",
        "value_hashes": "Types of values sent and their hashes"
      }
    },
    "account.cancelPasswordEmail": {
      "name": "account.cancelPasswordEmail",
      "description": [
        "Cancel the code that was sent to verify an email to use as 2FA recovery method."
      ]
    },
    "account.changePhone": {
      "name": "account.changePhone",
      "description": [
        "Change the phone number of the current account"
      ],
      "parameters": {
        "phone_code": "Phone code received when calling account.sendChangePhoneCode",
        "phone_code_hash": "Phone code hash received when calling account.sendChangePhoneCode",
        "phone_number": "New phone number"
      },
      "errors": [
        {
          "code": 400,
          "type": "PHONE_CODE_EMPTY",
          "description": "phone_code is missing"
        },
        {
          "code": 400,
          "type": "PHONE_NUMBER_INVALID",
          "description": "The phone number is invalid"
        }
      ]
    },
    "account.checkUsername": {
      "name": "account.checkUsername",
      "description": [
        "Validates a username and checks availability."
      ],
      "parameters": {
        "username": "usernameAccepted characters: A-z (case-insensitive), 0-9 and underscores.Length: 5-32 characters."
      },
      "errors": [
        {
          "code": 400,
          "type": "USERNAME_INVALID",
          "description": "Unacceptable username"
        }
      ]
    },
    "account.confirmPasswordEmail": {
      "name": "account.confirmPasswordEmail",
      "description": [
        "Verify an email to use as 2FA recovery method."
      ],
      "parameters": {
        "code": "The phone code that was received after setting a recovery email"
      },
      "errors": [
        {
          "code": 400,
          "type": "CODE_INVALID",
          "description": "Code invalid"
        },
        {
          "code": 400,
          "type": "EMAIL_HASH_EXPIRED",
          "description": "Email hash expired"
        }
      ]
    },
    "account.confirmPhone": {
      "name": "account.confirmPhone",
      "description": [
        "Confirm a phone number to cancel account deletion, for more info click here "
      ],
      "parameters": {
        "phone_code": "SMS code, for more info click here ",
        "phone_code_hash": "Phone code hash, for more info click here "
      },
      "errors": [
        {
          "code": 400,
          "type": "CODE_HASH_INVALID",
          "description": "Code hash invalid"
        },
        {
          "code": 400,
          "type": "PHONE_CODE_EMPTY",
          "description": "phone_code is missing"
        }
      ]
    },
    "account.createTheme": {
      "name": "account.createTheme",
      "description": [
        "Create a theme"
      ],
      "parameters": {
        "document": "Theme file",
        "flags": "Flags, see TL conditional fields",
        "settings": "Theme settings",
        "slug": "Unique theme ID",
        "title": "Theme name"
      }
    },
    "account.deleteAccount": {
      "name": "account.deleteAccount",
      "description": [
        "Delete the user's account from the telegram servers. Can be used, for example, to delete the account of a user that provided the login code, but forgot the 2FA password and no recovery method is configured."
      ],
      "parameters": {
        "reason": "Why is the account being deleted, can be empty"
      },
      "errors": [
        {
          "code": 420,
          "type": "2FA_CONFIRM_WAIT_X",
          "description": "Since this account is active and protected by a 2FA password, we will delete it in 1 week for security purposes. You can cancel this process at any time, you'll be able to reset your account in X seconds."
        }
      ]
    },
    "account.deleteSecureValue": {
      "name": "account.deleteSecureValue",
      "description": [
        "Delete stored Telegram Passport documents, for more info see the passport docs "
      ],
      "parameters": {
        "types": "Document types to delete"
      }
    },
    "account.finishTakeoutSession": {
      "name": "account.finishTakeoutSession",
      "description": [
        "Finish account takeout session"
      ],
      "parameters": {
        "flags": "Flags, see TL conditional fields",
        "success": "Data exported successfully"
      },
      "errors": [
        {
          "code": 403,
          "type": "TAKEOUT_REQUIRED",
          "description": "A takeout session has to be initialized, first"
        }
      ]
    },
    "account.getAccountTTL": {
      "name": "account.getAccountTTL",
      "description": [
        "Get days to live of account"
      ]
    },
    "account.getAllSecureValues": {
      "name": "account.getAllSecureValues",
      "description": [
        "Get all saved Telegram Passport documents, for more info see the passport docs "
      ]
    },
    "account.getAuthorizationForm": {
      "name": "account.getAuthorizationForm",
      "description": [
        "Returns a Telegram Passport authorization form for sharing data with a service"
      ],
      "parameters": {
        "bot_id": "User identifier of the service's bot",
        "public_key": "Service's public key",
        "scope": "Telegram Passport element types requested by the service"
      }
    },
    "account.getAuthorizations": {
      "name": "account.getAuthorizations",
      "description": [
        "Get logged-in sessions"
      ]
    },
    "account.getAutoDownloadSettings": {
      "name": "account.getAutoDownloadSettings",
      "description": [
        "Get media autodownload settings"
      ]
    },
    "account.getContactSignUpNotification": {
      "name": "account.getContactSignUpNotification",
      "description": [
        "Whether the user will receive notifications when contacts sign up"
      ]
    },
    "account.getContentSettings": {
      "name": "account.getContentSettings",
      "description": [
        "Get sensitive content settings"
      ]
    },
    "account.getGlobalPrivacySettings": {
      "name": "account.getGlobalPrivacySettings",
      "description": [
        "Get global privacy settings"
      ]
    },
    "account.getMultiWallPapers": {
      "name": "account.getMultiWallPapers",
      "description": [
        "Get info about multiple wallpapers"
      ],
      "parameters": {
        "wallpapers": "Wallpapers to fetch info about"
      }
    },
    "account.getNotifyExceptions": {
      "name": "account.getNotifyExceptions",
      "description": [
        "Returns list of chats with non-default notification settings"
      ],
      "parameters": {
        "compare_sound": "If true, chats with non-default sound will also be returned",
        "flags": "Flags, see TL conditional fields",
        "peer": "If specified, only chats of the specified category will be returned"
      }
    },
    "account.getNotifySettings": {
      "name": "account.getNotifySettings",
      "description": [
        "Gets current notification settings for a given user/group, from all users/all groups."
      ],
      "parameters": {
        "peer": "Notification source"
      },
      "errors": [
        {
          "code": 400,
          "type": "PEER_ID_INVALID",
          "description": "The provided peer id is invalid"
        }
      ]
    },
    "account.getPassword": {
      "name": "account.getPassword",
      "description": [
        "Obtain configuration for two-factor authorization with password"
      ]
    },
    "account.getPasswordSettings": {
      "name": "account.getPasswordSettings",
      "description": [
        "Get private info associated to the password info (recovery email, telegram passport info \u0026 so on)"
      ],
      "parameters": {
        "password": "The password (see SRP)"
      },
      "errors": [
        {
          "code": 400,
          "type": "PASSWORD_HASH_INVALID",
          "description": "The provided password hash is invalid"
        }
      ]
    },
    "account.getPrivacy": {
      "name": "account.getPrivacy",
      "description": [
        "Get privacy settings of current account"
      ],
      "parameters": {
        "key": "Peer category whose privacy settings should be fetched"
      },
      "errors": [
        {
          "code": 400,
          "type": "PRIVACY_KEY_INVALID",
          "description": "The privacy key is invalid"
        }
      ]
    },
    "account.getSecureValue": {
      "name": "account.getSecureValue",
      "description": [
        "Get saved Telegram Passport document, for more info see the passport docs "
      ],
      "parameters": {
        "types": "Requested value types"
      }
    },
    "account.getTheme": {
      "name": "account.getTheme",
      "description": [
        "Get theme information"
      ],
      "parameters": {
        "document_id": "Document ID",
        "format": "Theme format, a string that identifies the theming engines supported by the client",
        "theme": "Theme"
      },
      "errors": [
        {
          "code": 400,
          "type": "THEME_FORMAT_INVALID",
          "description": "Invalid theme format provided"
        },
        {
          "code": 400,
          "type": "THEME_INVALID",
          "description": "Invalid theme provided"
        }
      ]
    },
    "account.getThemes": {
      "name": "account.getThemes",
      "description": [
        "Get installed themes"
      ],
      "parameters": {
        "format": "Theme format, a string that identifies the theming engines supported by the client",
        "hash": "Hash for pagination, for more info click here"
      }
    },
    "account.getTmpPassword": {
      "name": "account.getTmpPassword",
      "description": [
        "Get temporary payment password"
      ],
      "parameters": {
        "password": "SRP password parameters",
        "period": "Time during which the temporary password will be valid, in seconds; should be between 60 and 86400"
      },
      "errors": [
        {
          "code": 400,
          "type": "PASSWORD_HASH_INVALID",
          "description": "The provided password hash is invalid"
        },
        {
          "code": 400,
          "type": "TMP_PASSWORD_DISABLED",
          "description": "The temporary password is disabled"
        }
      ]
    },
    "account.getWallPaper": {
      "name": "account.getWallPaper",
      "description": [
        "Get info about a certain wallpaper"
      ],
      "parameters": {
        "wallpaper": "The wallpaper to get info about"
      }
    },
    "account.getWallPapers": {
      "name": "account.getWallPapers",
      "description": [
        "Returns a list of available wallpapers."
      ],
      "parameters": {
        "hash": "Hash for pagination, for more info click here"
      }
    },
    "account.getWebAuthorizations": {
      "name": "account.getWebAuthorizations",
      "description": [
        "Get web login widget authorizations"
      ]
    },
    "account.initTakeoutSession": {
      "name": "account.initTakeoutSession",
      "description": [
        "Intialize account takeout session"
      ],
      "parameters": {
        "contacts": "Whether to export contacts",
        "file_max_size": "Maximum size of files to export",
        "files": "Whether to export files",
        "flags": "Flags, see TL conditional fields",
        "message_channels": "Whether to export messages in channels",
        "message_chats": "Whether to export messages in legacy groups",
        "message_megagroups": "Whether to export messages in supergroups",
        "message_users": "Whether to export messages in private chats"
      },
      "errors": [
        {
          "code": 420,
          "type": "TAKEOUT_INIT_DELAY_X",
          "description": "Wait X seconds before initing takeout"
        }
      ]
    },
    "account.installTheme": {
      "name": "account.installTheme",
      "description": [
        "Install a theme"
      ],
      "parameters": {
        "dark": "Whether to install the dark version",
        "flags": "Flags, see TL conditional fields",
        "format": "Theme format, a string that identifies the theming engines supported by the client",
        "theme": "Theme to install"
      }
    },
    "account.installWallPaper": {
      "name": "account.installWallPaper",
      "description": [
        "Install wallpaper"
      ],
      "parameters": {
        "settings": "Wallpaper settings",
        "wallpaper": "Wallpaper to install"
      }
    },
    "account.registerDevice": {
      "name": "account.registerDevice",
      "description": [
        "Register device to receive PUSH notifications"
      ],
      "parameters": {
        "app_sandbox": "If (boolTrue) is transmitted, a sandbox-certificate will be used during transmission.",
        "flags": "Flags, see TL conditional fields",
        "no_muted": "Avoid receiving (silent and invisible background) notifications. Useful to save battery.",
        "other_uids": "List of user identifiers of other users currently using the client",
        "secret": "For FCM and APNS VoIP, optional encryption key used to encrypt push notifications",
        "token": "Device token",
        "token_type": "Device token type.Possible values:1 - APNS (device token for apple push)2 - FCM (firebase token for google firebase)3 - MPNS (channel URI for microsoft push)4 - Simple push (endpoint for firefox's simple push API)5 - Ubuntu phone (token for ubuntu push)6 - Blackberry (token for blackberry push)7 - Unused8 - WNS (windows push)9 - APNS VoIP (token for apple push VoIP)10 - Web push (web push, see below)11 - MPNS VoIP (token for microsoft push VoIP)12 - Tizen (token for tizen push)For 10 web push, the token must be a JSON-encoded object containing the keys described in PUSH updates"
      },
      "errors": [
        {
          "code": 400,
          "type": "TOKEN_INVALID",
          "description": "The provided token is invalid"
        }
      ]
    },
    "account.reportPeer": {
      "name": "account.reportPeer",
      "description": [
        "Report a peer for violation of telegram's Terms of Service"
      ],
      "parameters": {
        "peer": "The peer to report",
        "reason": "The reason why this peer is being reported"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHANNEL_PRIVATE",
          "description": "You haven't joined this channel/supergroup"
        },
        {
          "code": 400,
          "type": "PEER_ID_INVALID",
          "description": "The provided peer id is invalid"
        }
      ]
    },
    "account.resendPasswordEmail": {
      "name": "account.resendPasswordEmail",
      "description": [
        "Resend the code to verify an email to use as 2FA recovery method."
      ]
    },
    "account.resetAuthorization": {
      "name": "account.resetAuthorization",
      "description": [
        "Log out an active authorized session by its hash"
      ],
      "parameters": {
        "hash": "Session hash"
      },
      "errors": [
        {
          "code": 406,
          "type": "FRESH_RESET_AUTHORISATION_FORBIDDEN",
          "description": "You can't logout other sessions if less than 24 hours have passed since you logged on the current session"
        },
        {
          "code": 400,
          "type": "HASH_INVALID",
          "description": "The provided hash is invalid"
        }
      ]
    },
    "account.resetNotifySettings": {
      "name": "account.resetNotifySettings",
      "description": [
        "Resets all notification settings from users and groups."
      ]
    },
    "account.resetWallPapers": {
      "name": "account.resetWallPapers",
      "description": [
        "Delete installed wallpapers"
      ]
    },
    "account.resetWebAuthorization": {
      "name": "account.resetWebAuthorization",
      "description": [
        "Log out an active web telegram login session"
      ],
      "parameters": {
        "hash": "Session hash"
      }
    },
    "account.resetWebAuthorizations": {
      "name": "account.resetWebAuthorizations",
      "description": [
        "Reset all active web telegram login sessions"
      ]
    },
    "account.saveAutoDownloadSettings": {
      "name": "account.saveAutoDownloadSettings",
      "description": [
        "Change media autodownload settings"
      ],
      "parameters": {
        "flags": "Flags, see TL conditional fields",
        "high": "Whether to save settings in the high data usage preset",
        "low": "Whether to save settings in the low data usage preset",
        "settings": "Media autodownload settings"
      }
    },
    "account.saveSecureValue": {
      "name": "account.saveSecureValue",
      "description": [
        "Securely save Telegram Passport document, for more info see the passport docs "
      ],
      "parameters": {
        "secure_secret_id": "Passport secret hash, for more info see the passport docs ",
        "value": "Secure value, for more info see the passport docs "
      }
    },
    "account.saveTheme": {
      "name": "account.saveTheme",
      "description": [
        "Save a theme"
      ],
      "parameters": {
        "theme": "Theme to save",
        "unsave": "Unsave"
      }
    },
    "account.saveWallPaper": {
      "name": "account.saveWallPaper",
      "description": [
        "Install/uninstall wallpaper"
      ],
      "parameters": {
        "settings": "Wallpaper settings",
        "unsave": "Uninstall wallpaper?",
        "wallpaper": "Wallpaper to save"
      }
    },
    "account.sendChangePhoneCode": {
      "name": "account.sendChangePhoneCode",
      "description": [
        "Verify a new phone number to associate to the current account"
      ],
      "parameters": {
        "phone_number": "New phone number",
        "settings": "Phone code settings"
      },
      "errors": [
        {
          "code": 400,
          "type": "PHONE_NUMBER_INVALID",
          "description": "The phone number is invalid"
        }
      ]
    },
    "account.sendConfirmPhoneCode": {
      "name": "account.sendConfirmPhoneCode",
      "description": [
        "Send confirmation code to cancel account deletion, for more info click here "
      ],
      "parameters": {
        "hash": "The hash from the service notification, for more info click here ",
        "settings": "Phone code settings"
      },
      "errors": [
        {
          "code": 400,
          "type": "HASH_INVALID",
          "description": "The provided hash is invalid"
        }
      ]
    },
    "account.sendVerifyEmailCode": {
      "name": "account.sendVerifyEmailCode",
      "description": [
        "Send the verification email code for telegram passport."
      ],
      "parameters": {
        "email": "The email where to send the code"
      }
    },
    "account.sendVerifyPhoneCode": {
      "name": "account.sendVerifyPhoneCode",
      "description": [
        "Send the verification phone code for telegram passport."
      ],
      "parameters": {
        "phone_number": "The phone number to verify",
        "settings": "Phone code settings"
      }
    },
    "account.setAccountTTL": {
      "name": "account.setAccountTTL",
      "description": [
        "Set account self-destruction period"
      ],
      "parameters": {
        "ttl": "Time to live in days"
      },
      "errors": [
        {
          "code": 400,
          "type": "TTL_DAYS_INVALID",
          "description": "The provided TTL is invalid"
        }
      ]
    },
    "account.setContactSignUpNotification": {
      "name": "account.setContactSignUpNotification",
      "description": [
        "Toggle contact sign up notifications"
      ],
      "parameters": {
        "silent": "Whether to disable contact sign up notifications"
      }
    },
    "account.setContentSettings": {
      "name": "account.setContentSettings",
      "description": [
        "Set sensitive content settings (for viewing or hiding NSFW content)"
      ],
      "parameters": {
        "flags": "Flags, see TL conditional fields",
        "sensitive_enabled": "Enable NSFW content"
      }
    },
    "account.setGlobalPrivacySettings": {
      "name": "account.setGlobalPrivacySettings",
      "description": [
        "Set global privacy settings"
      ],
      "parameters": {
        "settings": "Global privacy settings"
      }
    },
    "account.setPrivacy": {
      "name": "account.setPrivacy",
      "description": [
        "Change privacy settings of current account"
      ],
      "parameters": {
        "key": "Peers to which the privacy rules apply",
        "rules": "New privacy rules"
      },
      "errors": [
        {
          "code": 400,
          "type": "PRIVACY_KEY_INVALID",
          "description": "The privacy key is invalid"
        },
        {
          "code": 400,
          "type": "PRIVACY_VALUE_INVALID",
          "description": "The specified privacy rule combination is invalid"
        }
      ]
    },
    "account.unregisterDevice": {
      "name": "account.unregisterDevice",
      "description": [
        "Deletes a device by its token, stops sending PUSH-notifications to it."
      ],
      "parameters": {
        "other_uids": "List of user identifiers of other users currently using the client",
        "token": "Device token",
        "token_type": "Device token type.Possible values:1 - APNS (device token for apple push)2 - FCM (firebase token for google firebase)3 - MPNS (channel URI for microsoft push)4 - Simple push (endpoint for firefox's simple push API)5 - Ubuntu phone (token for ubuntu push)6 - Blackberry (token for blackberry push)7 - Unused8 - WNS (windows push)9 - APNS VoIP (token for apple push VoIP)10 - Web push (web push, see below)11 - MPNS VoIP (token for microsoft push VoIP)12 - Tizen (token for tizen push)For 10 web push, the token must be a JSON-encoded object containing the keys described in PUSH updates"
      },
      "errors": [
        {
          "code": 400,
          "type": "TOKEN_INVALID",
          "description": "The provided token is invalid"
        }
      ]
    },
    "account.updateDeviceLocked": {
      "name": "account.updateDeviceLocked",
      "description": [
        "When client-side passcode lock feature is enabled, will not show message texts in incoming PUSH notifications."
      ],
      "parameters": {
        "period": "Inactivity period after which to start hiding message texts in PUSH notifications."
      }
    },
    "account.updateNotifySettings": {
      "name": "account.updateNotifySettings",
      "description": [
        "Edits notification settings from a given user/group, from all users/all groups."
      ],
      "parameters": {
        "peer": "Notification source",
        "settings": "Notification settings"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHANNEL_PRIVATE",
          "description": "You haven't joined this channel/supergroup"
        },
        {
          "code": 400,
          "type": "MSG_ID_INVALID",
          "description": "Invalid message ID provided"
        },
        {
          "code": 400,
          "type": "PEER_ID_INVALID",
          "description": "The provided peer id is invalid"
        },
        {
          "code": 400,
          "type": "SETTINGS_INVALID",
          "description": "Invalid settings were provided"
        }
      ]
    },
    "account.updatePasswordSettings": {
      "name": "account.updatePasswordSettings",
      "description": [
        "Set a new 2FA password"
      ],
      "parameters": {
        "new_settings": "The new password (see SRP)",
        "password": "The old password (see SRP)"
      },
      "errors": [
        {
          "code": 400,
          "type": "EMAIL_UNCONFIRMED",
          "description": "Email unconfirmed"
        },
        {
          "code": 400,
          "type": "EMAIL_UNCONFIRMED_X",
          "description": "The provided email isn't confirmed, X is the length of the verification code that was just sent to the email: use account.verifyEmail to enter the received verification code and enable the recovery email."
        },
        {
          "code": 400,
          "type": "NEW_SALT_INVALID",
          "description": "The new salt is invalid"
        },
        {
          "code": 400,
          "type": "NEW_SETTINGS_INVALID",
          "description": "The new password settings are invalid"
        },
        {
          "code": 400,
          "type": "PASSWORD_HASH_INVALID",
          "description": "The old password hash is invalid"
        },
        {
          "code": 400,
          "type": "SRP_ID_INVALID",
          "description": "Invalid SRP ID provided"
        }
      ]
    },
    "account.updateProfile": {
      "name": "account.updateProfile",
      "description": [
        "Updates user profile."
      ],
      "parameters": {
        "about": "New bio",
        "first_name": "New user first name",
        "flags": "Flags, see TL conditional fields",
        "last_name": "New user last name"
      },
      "errors": [
        {
          "code": 400,
          "type": "ABOUT_TOO_LONG",
          "description": "About string too long"
        },
        {
          "code": 400,
          "type": "FIRSTNAME_INVALID",
          "description": "The first name is invalid"
        }
      ]
    },
    "account.updateStatus": {
      "name": "account.updateStatus",
      "description": [
        "Updates online user status."
      ],
      "parameters": {
        "offline": "If (boolTrue) is transmitted, user status will change to (userStatusOffline)."
      }
    },
    "account.updateTheme": {
      "name": "account.updateTheme",
      "description": [
        "Update theme"
      ],
      "parameters": {
        "document": "Theme file",
        "flags": "Flags, see TL conditional fields",
        "format": "Theme format, a string that identifies the theming engines supported by the client",
        "settings": "Theme settings",
        "slug": "Unique theme ID",
        "theme": "Theme to update",
        "title": "Theme name"
      }
    },
    "account.updateUsername": {
      "name": "account.updateUsername",
      "description": [
        "Changes username for the current user."
      ],
      "parameters": {
        "username": "username or empty string if username is to be removedAccepted characters: a-z (case-insensitive), 0-9 and underscores.Length: 5-32 characters."
      },
      "errors": [
        {
          "code": 401,
          "type": "AUTH_KEY_PERM_EMPTY",
          "description": "The temporary auth key must be binded to the permanent auth key to use these methods."
        },
        {
          "code": 400,
          "type": "USERNAME_INVALID",
          "description": "Unacceptable username"
        },
        {
          "code": 400,
          "type": "USERNAME_NOT_MODIFIED",
          "description": "Username is not different from the current username"
        },
        {
          "code": 400,
          "type": "USERNAME_OCCUPIED",
          "description": "Username is taken"
        }
      ]
    },
    "account.uploadTheme": {
      "name": "account.uploadTheme",
      "description": [
        "Upload theme"
      ],
      "parameters": {
        "file": "Theme file uploaded as described in files ",
        "file_name": "File name",
        "flags": "Flags, see TL conditional fields",
        "mime_type": "MIME type, must be application/x-tgtheme-{format}, where format depends on the client",
        "thumb": "Thumbnail"
      },
      "errors": [
        {
          "code": 400,
          "type": "THEME_FILE_INVALID",
          "description": "Invalid theme file provided"
        }
      ]
    },
    "account.uploadWallPaper": {
      "name": "account.uploadWallPaper",
      "description": [
        "Create and upload a new wallpaper"
      ],
      "parameters": {
        "file": "The JPG/PNG wallpaper",
        "mime_type": "MIME type of uploaded wallpaper",
        "settings": "Wallpaper settings"
      }
    },
    "account.verifyEmail": {
      "name": "account.verifyEmail",
      "description": [
        "Verify an email address for telegram passport."
      ],
      "parameters": {
        "code": "The verification code that was received",
        "email": "The email to verify"
      },
      "errors": [
        {
          "code": 400,
          "type": "EMAIL_VERIFY_EXPIRED",
          "description": "The verification email has expired"
        }
      ]
    },
    "account.verifyPhone": {
      "name": "account.verifyPhone",
      "description": [
        "Verify a phone number for telegram passport."
      ],
      "parameters": {
        "phone_code": "Code received after the call to account.sendVerifyPhoneCode",
        "phone_code_hash": "Phone code hash received from the call to account.sendVerifyPhoneCode",
        "phone_number": "Phone number"
      },
      "errors": [
        {
          "code": 400,
          "type": "PHONE_CODE_EXPIRED",
          "description": "The phone code you provided has expired, this may happen if it was sent to any chat on telegram (if the code is sent through a telegram chat (not the official account) to avoid it append or prepend to the code some chars)"
        }
      ]
    },
    "auth.acceptLoginToken": {
      "name": "auth.acceptLoginToken",
      "description": [
        "Accept QR code login token, logging in the app that generated it.",
        "Returns info about the new session.",
        "For more info, see login via QR code."
      ],
      "parameters": {
        "token": "Login token embedded in QR code, for more info, see login via QR code."
      },
      "errors": [
        {
          "code": 400,
          "type": "AUTH_TOKEN_INVALIDX",
          "description": "The specified auth token is invalid"
        }
      ]
    },
    "auth.bindTempAuthKey": {
      "name": "auth.bindTempAuthKey",
      "description": [
        "Binds a temporary authorization key temp_auth_key_id to the permanent authorization key perm_auth_key_id. Each permanent key may only be bound to one temporary key at a time, binding a new temporary key overwrites the previous one.",
        "For more information, see Perfect Forward Secrecy."
      ],
      "parameters": {
        "encrypted_message": "See Generating encrypted_message",
        "expires_at": "Unix timestamp to invalidate temporary key, see Binding message contents",
        "nonce": "Random long from Binding message contents",
        "perm_auth_key_id": "Permanent auth_key_id to bind to"
      },
      "errors": [
        {
          "code": 400,
          "type": "ENCRYPTED_MESSAGE_INVALID",
          "description": "Encrypted message is incorrect"
        },
        {
          "code": 400,
          "type": "INPUT_REQUEST_TOO_LONG",
          "description": "The request is too big"
        },
        {
          "code": 400,
          "type": "TEMP_AUTH_KEY_ALREADY_BOUND",
          "description": "The passed temporary key is already bound to another perm_auth_key_id"
        },
        {
          "code": 400,
          "type": "TEMP_AUTH_KEY_EMPTY",
          "description": "The request was not performed with a temporary authorization key"
        }
      ]
    },
    "auth.cancelCode": {
      "name": "auth.cancelCode",
      "description": [
        "Cancel the login verification code"
      ],
      "parameters": {
        "phone_code_hash": "Phone code hash from auth.sendCode",
        "phone_number": "Phone number"
      },
      "errors": [
        {
          "code": 400,
          "type": "PHONE_CODE_EXPIRED",
          "description": "The phone code you provided has expired, this may happen if it was sent to any chat on telegram (if the code is sent through a telegram chat (not the official account) to avoid it append or prepend to the code some chars)"
        },
        {
          "code": 400,
          "type": "PHONE_NUMBER_INVALID",
          "description": "The phone number is invalid"
        }
      ]
    },
    "auth.checkPassword": {
      "name": "auth.checkPassword",
      "description": [
        "Try logging to an account protected by a 2FA password."
      ],
      "parameters": {
        "password": "The account's password (see SRP)"
      },
      "errors": [
        {
          "code": 400,
          "type": "PASSWORD_HASH_INVALID",
          "description": "The provided password isn't valid"
        },
        {
          "code": 400,
          "type": "SRP_ID_INVALID",
          "description": "Invalid SRP ID provided"
        },
        {
          "code": 400,
          "type": "SRP_PASSWORD_CHANGED",
          "description": "Password has changed"
        }
      ]
    },
    "auth.dropTempAuthKeys": {
      "name": "auth.dropTempAuthKeys",
      "description": [
        "Delete all temporary authorization keys except for the ones specified"
      ],
      "parameters": {
        "except_auth_keys": "The auth keys that shouldn't be dropped."
      }
    },
    "auth.exportAuthorization": {
      "name": "auth.exportAuthorization",
      "description": [
        "Returns data for copying authorization to another data-centre."
      ],
      "parameters": {
        "dc_id": "Number of a target data-centre"
      },
      "errors": [
        {
          "code": 400,
          "type": "DC_ID_INVALID",
          "description": "The provided DC ID is invalid"
        }
      ]
    },
    "auth.exportLoginToken": {
      "name": "auth.exportLoginToken",
      "description": [
        "Generate a login token, for login via QR code.\nThe generated login token should be encoded using base64url, then shown as a tg://login?token=base64encodedtoken URL in the QR code.",
        "For more info, see login via QR code."
      ],
      "parameters": {
        "api_hash": "Application identifier hash (see. App configuration)",
        "api_id": "Application identifier (see. App configuration)",
        "except_ids": "List of already logged-in user IDs, to prevent logging in twice with the same user"
      }
    },
    "auth.importAuthorization": {
      "name": "auth.importAuthorization",
      "description": [
        "Logs in a user using a key transmitted from his native data-centre."
      ],
      "parameters": {
        "bytes": "Authorization key",
        "id": "User ID"
      },
      "errors": [
        {
          "code": 400,
          "type": "AUTH_BYTES_INVALID",
          "description": "The provided authorization is invalid"
        },
        {
          "code": 400,
          "type": "USER_ID_INVALID",
          "description": "The provided user ID is invalid"
        }
      ]
    },
    "auth.importBotAuthorization": {
      "name": "auth.importBotAuthorization",
      "description": [
        "Login as a bot"
      ],
      "parameters": {
        "api_hash": "Application identifier hash (see. App configuration)",
        "api_id": "Application identifier (see. App configuration)",
        "bot_auth_token": "Bot token (see bots)",
        "flags": "Reserved for future use"
      },
      "errors": [
        {
          "code": 400,
          "type": "ACCESS_TOKEN_EXPIRED",
          "description": "Bot token expired"
        },
        {
          "code": 400,
          "type": "ACCESS_TOKEN_INVALID",
          "description": "The provided token is not valid"
        },
        {
          "code": 400,
          "type": "API_ID_INVALID",
          "description": "The api_id/api_hash combination is invalid"
        },
        {
          "code": 401,
          "type": "AUTH_KEY_INVALID",
          "description": "Auth key invalid"
        }
      ]
    },
    "auth.importLoginToken": {
      "name": "auth.importLoginToken",
      "description": [
        "Login using a redirected login token, generated in case of DC mismatch during QR code login.",
        "For more info, see login via QR code."
      ],
      "parameters": {
        "token": "Login token"
      },
      "errors": [
        {
          "code": 400,
          "type": "AUTH_TOKEN_EXPIRED",
          "description": "The authorization token has expired"
        }
      ]
    },
    "auth.logOut": {
      "name": "auth.logOut",
      "description": [
        "Logs out the user."
      ]
    },
    "auth.recoverPassword": {
      "name": "auth.recoverPassword",
      "description": [
        "Reset the 2FA password using the recovery code sent using auth.requestPasswordRecovery."
      ],
      "parameters": {
        "code": "Code received via email"
      },
      "errors": [
        {
          "code": 400,
          "type": "CODE_EMPTY",
          "description": "The provided code is empty"
        }
      ]
    },
    "auth.requestPasswordRecovery": {
      "name": "auth.requestPasswordRecovery",
      "description": [
        "Request recovery code of a 2FA password, only for accounts with a recovery email configured."
      ],
      "parameters": {
        "400": "The provided password is empty"
      },
      "errors": [
        {
          "code": 400,
          "type": "PASSWORD_EMPTY",
          "description": "The provided password is empty"
        }
      ]
    },
    "auth.resendCode": {
      "name": "auth.resendCode",
      "description": [
        "Resend the login code via another medium, the phone code type is determined by the return value of the previous auth.sendCode/auth.resendCode: see login for more info."
      ],
      "parameters": {
        "phone_code_hash": "The phone code hash obtained from auth.sendCode",
        "phone_number": "The phone number"
      },
      "errors": [
        {
          "code": 400,
          "type": "PHONE_CODE_EXPIRED",
          "description": "The phone code you provided has expired, this may happen if it was sent to any chat on telegram (if the code is sent through a telegram chat (not the official account) to avoid it append or prepend to the code some chars)"
        },
        {
          "code": 400,
          "type": "PHONE_CODE_HASH_EMPTY",
          "description": "phone_code_hash is missing"
        },
        {
          "code": 400,
          "type": "PHONE_NUMBER_INVALID",
          "description": "The phone number is invalid"
        }
      ]
    },
    "auth.resetAuthorizations": {
      "name": "auth.resetAuthorizations",
      "description": [
        "Terminates all user's authorized sessions except for the current one.",
        "After calling this method it is necessary to reregister the current device using the method account.registerDevice"
      ],
      "parameters": {
        "406": "You can't logout other sessions if less than 24 hours have passed since you logged on the current session"
      },
      "errors": [
        {
          "code": 406,
          "type": "FRESH_RESET_AUTHORISATION_FORBIDDEN",
          "description": "You can't logout other sessions if less than 24 hours have passed since you logged on the current session"
        }
      ]
    },
    "auth.sendCode": {
      "name": "auth.sendCode",
      "description": [
        "Send the verification code for login"
      ],
      "parameters": {
        "api_hash": "Application secret hash (see App configuration)",
        "api_id": "Application identifier (see App configuration)",
        "phone_number": "Phone number in international format",
        "settings": "Settings for the code type to send"
      },
      "errors": [
        {
          "code": 400,
          "type": "API_ID_INVALID",
          "description": "API ID invalid"
        },
        {
          "code": 400,
          "type": "API_ID_PUBLISHED_FLOOD",
          "description": "This API id was published somewhere, you can't use it now"
        },
        {
          "code": 401,
          "type": "AUTH_KEY_PERM_EMPTY",
          "description": "The temporary auth key must be binded to the permanent auth key to use these methods."
        },
        {
          "code": 400,
          "type": "INPUT_REQUEST_TOO_LONG",
          "description": "The request is too big"
        },
        {
          "code": 303,
          "type": "NETWORK_MIGRATE_X",
          "description": "Repeat the query to data-center X"
        },
        {
          "code": 303,
          "type": "PHONE_MIGRATE_X",
          "description": "Repeat the query to data-center X"
        },
        {
          "code": 400,
          "type": "PHONE_NUMBER_APP_SIGNUP_FORBIDDEN",
          "description": "You can't sign up using this app"
        },
        {
          "code": 400,
          "type": "PHONE_NUMBER_BANNED",
          "description": "The provided phone number is banned from telegram"
        },
        {
          "code": 400,
          "type": "PHONE_NUMBER_FLOOD",
          "description": "You asked for the code too many times."
        },
        {
          "code": 400,
          "type": "PHONE_NUMBER_INVALID",
          "description": "Invalid phone number"
        },
        {
          "code": 406,
          "type": "PHONE_PASSWORD_FLOOD",
          "description": "You have tried logging in too many times"
        },
        {
          "code": 400,
          "type": "PHONE_PASSWORD_PROTECTED",
          "description": "This phone is password protected"
        },
        {
          "code": 400,
          "type": "SMS_CODE_CREATE_FAILED",
          "description": "An error occurred while creating the SMS code"
        }
      ]
    },
    "auth.signIn": {
      "name": "auth.signIn",
      "description": [
        "Signs in a user with a validated phone number."
      ],
      "parameters": {
        "phone_code": "Valid numerical code from the SMS-message",
        "phone_code_hash": "SMS-message ID, obtained from auth.sendCode",
        "phone_number": "Phone number in the international format"
      },
      "errors": [
        {
          "code": 400,
          "type": "PHONE_CODE_EMPTY",
          "description": "phone_code from the SMS is empty"
        },
        {
          "code": 400,
          "type": "PHONE_CODE_EXPIRED",
          "description": "SMS expired"
        },
        {
          "code": 400,
          "type": "PHONE_CODE_INVALID",
          "description": "Invalid SMS code was sent"
        },
        {
          "code": 400,
          "type": "PHONE_NUMBER_INVALID",
          "description": "Invalid phone number"
        },
        {
          "code": 400,
          "type": "PHONE_NUMBER_UNOCCUPIED",
          "description": "The code is valid but no user with the given number is registered"
        }
      ]
    },
    "auth.signUp": {
      "name": "auth.signUp",
      "description": [
        "Registers a validated phone number in the system."
      ],
      "parameters": {
        "first_name": "New user first name",
        "last_name": "New user last name",
        "phone_code_hash": "SMS-message ID",
        "phone_number": "Phone number in the international format"
      },
      "errors": [
        {
          "code": 400,
          "type": "FIRSTNAME_INVALID",
          "description": "Invalid first name"
        },
        {
          "code": 400,
          "type": "INPUT_REQUEST_TOO_LONG",
          "description": "The request is too big"
        },
        {
          "code": 400,
          "type": "LASTNAME_INVALID",
          "description": "Invalid last name"
        },
        {
          "code": 400,
          "type": "PHONE_CODE_EMPTY",
          "description": "phone_code from a SMS is empty"
        },
        {
          "code": 400,
          "type": "PHONE_CODE_EXPIRED",
          "description": "SMS expired"
        },
        {
          "code": 400,
          "type": "PHONE_CODE_INVALID",
          "description": "Invalid SMS code was sent"
        },
        {
          "code": 400,
          "type": "PHONE_NUMBER_FLOOD",
          "description": "You asked for the code too many times."
        },
        {
          "code": 400,
          "type": "PHONE_NUMBER_INVALID",
          "description": "Invalid phone number"
        },
        {
          "code": 400,
          "type": "PHONE_NUMBER_OCCUPIED",
          "description": "The phone number is already in use"
        }
      ]
    },
    "bots.answerWebhookJSONQuery": {
      "name": "bots.answerWebhookJSONQuery",
      "description": [
        "Answers a custom query; for bots only"
      ],
      "parameters": {
        "data": "JSON-serialized answer to the query",
        "query_id": "Identifier of a custom query"
      },
      "errors": [
        {
          "code": 400,
          "type": "QUERY_ID_INVALID",
          "description": "The query ID is invalid"
        },
        {
          "code": 400,
          "type": "USER_BOT_INVALID",
          "description": "This method can only be called by a bot"
        }
      ]
    },
    "bots.sendCustomRequest": {
      "name": "bots.sendCustomRequest",
      "description": [
        "Sends a custom request; for bots only"
      ],
      "parameters": {
        "custom_method": "The method name",
        "params": "JSON-serialized method parameters"
      },
      "errors": [
        {
          "code": 400,
          "type": "METHOD_INVALID",
          "description": "The specified method is invalid"
        },
        {
          "code": 400,
          "type": "USER_BOT_INVALID",
          "description": "This method can only be called by a bot"
        }
      ]
    },
    "bots.setBotCommands": {
      "name": "bots.setBotCommands",
      "description": [
        "Set bot command list"
      ],
      "parameters": {
        "commands": "Bot commands"
      }
    },
    "channels.checkUsername": {
      "name": "channels.checkUsername",
      "description": [
        "Check if a username is free and can be assigned to a channel/supergroup"
      ],
      "parameters": {
        "channel": "The channel/supergroup that will assigned the specified username",
        "username": "The username to check"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHANNELS_ADMIN_PUBLIC_TOO_MUCH",
          "description": "You're admin of too many public channels, make some channels private to change the username of this channel"
        },
        {
          "code": 400,
          "type": "CHANNEL_INVALID",
          "description": "The provided channel is invalid"
        },
        {
          "code": 400,
          "type": "CHAT_ID_INVALID",
          "description": "The provided chat id is invalid"
        },
        {
          "code": 400,
          "type": "USERNAME_INVALID",
          "description": "The provided username is not valid"
        }
      ]
    },
    "channels.createChannel": {
      "name": "channels.createChannel",
      "description": [
        "Create a supergroup/channel."
      ],
      "parameters": {
        "about": "Channel description",
        "address": "Geogroup address",
        "broadcast": "Whether to create a channel",
        "flags": "Flags, see TL conditional fields",
        "geo_point": "Geogroup location",
        "megagroup": "Whether to create a supergroup",
        "title": "Channel title"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHANNELS_TOO_MUCH",
          "description": "You have joined too many channels/supergroups"
        },
        {
          "code": 400,
          "type": "CHAT_ABOUT_TOO_LONG",
          "description": "Chat about too long"
        },
        {
          "code": 400,
          "type": "CHAT_TITLE_EMPTY",
          "description": "No chat title provided"
        },
        {
          "code": 403,
          "type": "USER_RESTRICTED",
          "description": "You're spamreported, you can't create channels or chats."
        }
      ]
    },
    "channels.deleteChannel": {
      "name": "channels.deleteChannel",
      "description": [
        "Delete a channel/supergroup"
      ],
      "parameters": {
        "channel": "Channel/supergroup to delete"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHANNEL_INVALID",
          "description": "The provided channel is invalid"
        },
        {
          "code": 400,
          "type": "CHANNEL_PRIVATE",
          "description": "You haven't joined this channel/supergroup"
        },
        {
          "code": 400,
          "type": "CHANNEL_TOO_LARGE",
          "description": "Channel is too large to be deleted; this error is issued when trying to delete channels with more than 1000 members (subject to change)"
        },
        {
          "code": 400,
          "type": "CHAT_ADMIN_REQUIRED",
          "description": "You must be an admin in this chat to do this"
        },
        {
          "code": 403,
          "type": "CHAT_WRITE_FORBIDDEN",
          "description": "You can't write in this chat"
        }
      ]
    },
    "channels.deleteHistory": {
      "name": "channels.deleteHistory",
      "description": [
        "Delete the history of a supergroup"
      ],
      "parameters": {
        "channel": "Supergroup whose history must be deleted",
        "max_id": "ID of message up to which the history must be deleted"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHANNEL_INVALID",
          "description": "The provided channel is invalid"
        },
        {
          "code": 400,
          "type": "CHANNEL_PRIVATE",
          "description": "You haven't joined this channel/supergroup"
        }
      ]
    },
    "channels.deleteMessages": {
      "name": "channels.deleteMessages",
      "description": [
        "Delete messages in a channel/supergroup"
      ],
      "parameters": {
        "channel": "Channel/supergroup",
        "id": "IDs of messages to delete"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHANNEL_INVALID",
          "description": "The provided channel is invalid"
        },
        {
          "code": 400,
          "type": "CHANNEL_PRIVATE",
          "description": "You haven't joined this channel/supergroup"
        },
        {
          "code": 403,
          "type": "MESSAGE_DELETE_FORBIDDEN",
          "description": "You can't delete one of the messages you tried to delete, most likely because it is a service message."
        },
        {
          "code": 400,
          "type": "MSG_ID_INVALID",
          "description": "Invalid message ID provided"
        }
      ]
    },
    "channels.deleteUserHistory": {
      "name": "channels.deleteUserHistory",
      "description": [
        "Delete all messages sent by a certain user in a supergroup"
      ],
      "parameters": {
        "channel": "Supergroup",
        "user_id": "User whose messages should be deleted"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHANNEL_INVALID",
          "description": "The provided channel is invalid"
        },
        {
          "code": 400,
          "type": "CHANNEL_PRIVATE",
          "description": "You haven't joined this channel/supergroup"
        },
        {
          "code": 400,
          "type": "CHAT_ADMIN_REQUIRED",
          "description": "You must be an admin in this chat to do this"
        },
        {
          "code": 403,
          "type": "CHAT_WRITE_FORBIDDEN",
          "description": "You can't write in this chat"
        },
        {
          "code": 400,
          "type": "MSG_ID_INVALID",
          "description": "Invalid message ID provided"
        },
        {
          "code": 400,
          "type": "USER_ID_INVALID",
          "description": "The provided user ID is invalid"
        }
      ]
    },
    "channels.editAdmin": {
      "name": "channels.editAdmin",
      "description": [
        "Modify the admin rights of a user in a supergroup/channel."
      ],
      "parameters": {
        "admin_rights": "The admin rights",
        "channel": "The supergroup/channel.",
        "rank": "Indicates the role (rank) of the admin in the group: just an arbitrary string",
        "user_id": "The ID of the user whose admin rights should be modified"
      },
      "errors": [
        {
          "code": 400,
          "type": "ADMINS_TOO_MUCH",
          "description": "There are too many admins"
        },
        {
          "code": 400,
          "type": "BOTS_TOO_MUCH",
          "description": "There are too many bots in this chat/channel"
        },
        {
          "code": 400,
          "type": "BOT_CHANNELS_NA",
          "description": "Bots can't edit admin privileges"
        },
        {
          "code": 400,
          "type": "BOT_GROUPS_BLOCKED",
          "description": "This bot can't be added to groups"
        },
        {
          "code": 400,
          "type": "CHANNEL_INVALID",
          "description": "The provided channel is invalid"
        },
        {
          "code": 400,
          "type": "CHANNEL_PRIVATE",
          "description": "You haven't joined this channel/supergroup"
        },
        {
          "code": 403,
          "type": "CHAT_ADMIN_INVITE_REQUIRED",
          "description": "You do not have the rights to do this"
        },
        {
          "code": 400,
          "type": "CHAT_ADMIN_REQUIRED",
          "description": "You must be an admin in this chat to do this"
        },
        {
          "code": 403,
          "type": "CHAT_WRITE_FORBIDDEN",
          "description": "You can't write in this chat"
        },
        {
          "code": 406,
          "type": "FRESH_CHANGE_ADMINS_FORBIDDEN",
          "description": "You were just elected admin, you can't add or modify other admins yet"
        },
        {
          "code": 400,
          "type": "INPUT_USER_DEACTIVATED",
          "description": "The specified user was deleted"
        },
        {
          "code": 400,
          "type": "PEER_ID_INVALID",
          "description": "The provided peer id is invalid"
        },
        {
          "code": 403,
          "type": "RIGHT_FORBIDDEN",
          "description": "Your admin rights do not allow you to do this"
        },
        {
          "code": 400,
          "type": "USERS_TOO_MUCH",
          "description": "The maximum number of users has been exceeded (to create a chat, for example)"
        },
        {
          "code": 400,
          "type": "USER_BLOCKED",
          "description": "User blocked"
        },
        {
          "code": 403,
          "type": "USER_CHANNELS_TOO_MUCH",
          "description": "One of the users you tried to add is already in too many channels/supergroups"
        },
        {
          "code": 400,
          "type": "USER_CREATOR",
          "description": "You can't leave this channel, because you're its creator"
        },
        {
          "code": 400,
          "type": "USER_ID_INVALID",
          "description": "The provided user ID is invalid"
        },
        {
          "code": 400,
          "type": "USER_NOT_MUTUAL_CONTACT",
          "description": "The provided user is not a mutual contact"
        },
        {
          "code": 403,
          "type": "USER_PRIVACY_RESTRICTED",
          "description": "The user's privacy settings do not allow you to do this"
        },
        {
          "code": 403,
          "type": "USER_RESTRICTED",
          "description": "You're spamreported, you can't create channels or chats."
        }
      ]
    },
    "channels.editBanned": {
      "name": "channels.editBanned",
      "description": [
        "Ban/unban/kick a user in a supergroup/channel."
      ],
      "parameters": {
        "banned_rights": "The banned rights",
        "channel": "The supergroup/channel.",
        "user_id": "The ID of the user whose banned rights should be modified"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHANNEL_INVALID",
          "description": "The provided channel is invalid"
        },
        {
          "code": 400,
          "type": "CHANNEL_PRIVATE",
          "description": "You haven't joined this channel/supergroup"
        },
        {
          "code": 400,
          "type": "CHAT_ADMIN_REQUIRED",
          "description": "You must be an admin in this chat to do this"
        },
        {
          "code": 403,
          "type": "CHAT_WRITE_FORBIDDEN",
          "description": "You can't write in this chat"
        },
        {
          "code": 400,
          "type": "MSG_ID_INVALID",
          "description": "Invalid message ID provided"
        },
        {
          "code": 400,
          "type": "PINNED_DIALOGS_TOO_MUCH",
          "description": "Too many pinned dialogs"
        },
        {
          "code": 400,
          "type": "USER_ADMIN_INVALID",
          "description": "You're not an admin"
        },
        {
          "code": 400,
          "type": "USER_ID_INVALID",
          "description": "The provided user ID is invalid"
        }
      ]
    },
    "channels.editCreator": {
      "name": "channels.editCreator",
      "description": [
        "Transfer channel ownership"
      ],
      "parameters": {
        "channel": "Channel",
        "password": "2FA password of account",
        "user_id": "New channel owner"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHANNEL_PRIVATE",
          "description": "You haven't joined this channel/supergroup"
        },
        {
          "code": 400,
          "type": "CHAT_ADMIN_REQUIRED",
          "description": "You must be an admin in this chat to do this"
        },
        {
          "code": 400,
          "type": "PASSWORD_HASH_INVALID",
          "description": "The provided password hash is invalid"
        },
        {
          "code": 400,
          "type": "PASSWORD_MISSING",
          "description": "You must enable 2FA in order to transfer ownership of a channel"
        },
        {
          "code": 400,
          "type": "PASSWORD_TOO_FRESH_X",
          "description": "The password was modified less than 24 hours ago, try again in X seconds"
        },
        {
          "code": 400,
          "type": "SESSION_TOO_FRESH_X",
          "description": "This session was created less than 24 hours ago, try again in X seconds"
        },
        {
          "code": 400,
          "type": "USER_ID_INVALID",
          "description": "The provided user ID is invalid"
        }
      ]
    },
    "channels.editLocation": {
      "name": "channels.editLocation",
      "description": [
        "Edit location of geogroup"
      ],
      "parameters": {
        "address": "Address string",
        "channel": "Geogroup",
        "geo_point": "New geolocation"
      },
      "errors": [
        {
          "code": 400,
          "type": "MEGAGROUP_REQUIRED",
          "description": "You can only use this method on a supergroup"
        }
      ]
    },
    "channels.editPhoto": {
      "name": "channels.editPhoto",
      "description": [
        "Change the photo of a channel/supergroup"
      ],
      "parameters": {
        "channel": "Channel/supergroup whose photo should be edited",
        "photo": "New photo"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHANNEL_INVALID",
          "description": "The provided channel is invalid"
        },
        {
          "code": 400,
          "type": "CHAT_ADMIN_REQUIRED",
          "description": "You must be an admin in this chat to do this"
        },
        {
          "code": 400,
          "type": "CHAT_NOT_MODIFIED",
          "description": "The pinned message wasn't modified"
        },
        {
          "code": 403,
          "type": "CHAT_WRITE_FORBIDDEN",
          "description": "You can't write in this chat"
        },
        {
          "code": 400,
          "type": "PHOTO_CROP_SIZE_SMALL",
          "description": "Photo is too small"
        },
        {
          "code": 400,
          "type": "PHOTO_EXT_INVALID",
          "description": "The extension of the photo is invalid"
        },
        {
          "code": 400,
          "type": "PHOTO_INVALID",
          "description": "Photo invalid"
        }
      ]
    },
    "channels.editTitle": {
      "name": "channels.editTitle",
      "description": [
        "Edit the name of a channel/supergroup"
      ],
      "parameters": {
        "channel": "Channel/supergroup",
        "title": "New name"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHANNEL_INVALID",
          "description": "The provided channel is invalid"
        },
        {
          "code": 400,
          "type": "CHAT_ADMIN_REQUIRED",
          "description": "You must be an admin in this chat to do this"
        },
        {
          "code": 400,
          "type": "CHAT_NOT_MODIFIED",
          "description": "The pinned message wasn't modified"
        },
        {
          "code": 400,
          "type": "CHAT_TITLE_EMPTY",
          "description": "No chat title provided"
        },
        {
          "code": 403,
          "type": "CHAT_WRITE_FORBIDDEN",
          "description": "You can't write in this chat"
        }
      ]
    },
    "channels.exportMessageLink": {
      "name": "channels.exportMessageLink",
      "description": [
        "Get link and embed info of a message in a channel/supergroup"
      ],
      "parameters": {
        "channel": "Channel",
        "flags": "Flags, see TL conditional fields",
        "grouped": "Whether to include other grouped media (for albums)",
        "id": "Message ID",
        "thread": "Whether to also include a thread ID, if available, inside of the link"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHANNEL_INVALID",
          "description": "The provided channel is invalid"
        },
        {
          "code": 400,
          "type": "CHANNEL_PRIVATE",
          "description": "You haven't joined this channel/supergroup"
        },
        {
          "code": 400,
          "type": "MESSAGE_ID_INVALID",
          "description": "The provided message id is invalid"
        },
        {
          "code": 400,
          "type": "MSG_ID_INVALID",
          "description": "Invalid message ID provided"
        }
      ]
    },
    "channels.getAdminLog": {
      "name": "channels.getAdminLog",
      "description": [
        "Get the admin log of a channel/supergroup"
      ],
      "parameters": {
        "admins": "Only show events from these admins",
        "channel": "Channel",
        "events_filter": "Event filter",
        "flags": "Flags, see TL conditional fields",
        "limit": "Maximum number of results to return, see pagination",
        "max_id": "Maximum ID of message to return (see pagination)",
        "min_id": "Minimum ID of message to return (see pagination)",
        "q": "Search query, can be empty"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHANNEL_INVALID",
          "description": "The provided channel is invalid"
        },
        {
          "code": 400,
          "type": "CHANNEL_PRIVATE",
          "description": "You haven't joined this channel/supergroup"
        },
        {
          "code": 400,
          "type": "CHAT_ADMIN_REQUIRED",
          "description": "You must be an admin in this chat to do this"
        },
        {
          "code": 403,
          "type": "CHAT_WRITE_FORBIDDEN",
          "description": "You can't write in this chat"
        },
        {
          "code": 400,
          "type": "MSG_ID_INVALID",
          "description": "Invalid message ID provided"
        }
      ]
    },
    "channels.getAdminedPublicChannels": {
      "name": "channels.getAdminedPublicChannels",
      "description": [
        "Get channels/supergroups/geogroups we're admin in. Usually called when the user exceeds the limit for owned public channels/supergroups/geogroups, and the user is given the choice to remove one of his channels/supergroups/geogroups."
      ],
      "parameters": {
        "by_location": "Get geogroups",
        "check_limit": "If set and the user has reached the limit of owned public channels/supergroups/geogroups, instead of returning the channel list one of the specified errors will be returned.Useful to check if a new public channel can indeed be created, even before asking the user to enter a channel username to use in channels.checkUsername/channels.updateUsername.",
        "flags": "Flags, see TL conditional fields"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHANNELS_ADMIN_LOCATED_TOO_MUCH",
          "description": "Returned if both the check_limit and the by_location flags are set and the user has reached the limit of public geogroups"
        },
        {
          "code": 400,
          "type": "CHANNELS_ADMIN_PUBLIC_TOO_MUCH",
          "description": "Returned if the check_limit flag is set and the user has reached the limit of public channels/supergroups"
        }
      ]
    },
    "channels.getChannels": {
      "name": "channels.getChannels",
      "description": [
        "Get info about channels/supergroups"
      ],
      "parameters": {
        "id": "IDs of channels/supergroups to get info about"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHANNEL_INVALID",
          "description": "The provided channel is invalid"
        },
        {
          "code": 400,
          "type": "CHANNEL_PRIVATE",
          "description": "You haven't joined this channel/supergroup"
        },
        {
          "code": 400,
          "type": "MSG_ID_INVALID",
          "description": "Invalid message ID provided"
        }
      ]
    },
    "channels.getFullChannel": {
      "name": "channels.getFullChannel",
      "description": [
        "Get full info about a channel"
      ],
      "parameters": {
        "channel": "The channel to get info about"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHANNEL_INVALID",
          "description": "The provided channel is invalid"
        },
        {
          "code": 400,
          "type": "CHANNEL_PRIVATE",
          "description": "You haven't joined this channel/supergroup"
        },
        {
          "code": 403,
          "type": "CHANNEL_PUBLIC_GROUP_NA",
          "description": "channel/supergroup not available"
        },
        {
          "code": 400,
          "type": "MSG_ID_INVALID",
          "description": "Invalid message ID provided"
        }
      ]
    },
    "channels.getGroupsForDiscussion": {
      "name": "channels.getGroupsForDiscussion",
      "description": [
        "Get all groups that can be used as discussion groups.",
        "Returned legacy group chats must be first upgraded to supergroups before they can be set as a discussion group.\nTo set a returned supergroup as a discussion group, access to its old messages must be enabled using channels.togglePreHistoryHidden, first."
      ]
    },
    "channels.getInactiveChannels": {
      "name": "channels.getInactiveChannels",
      "description": [
        "Get inactive channels and supergroups"
      ]
    },
    "channels.getLeftChannels": {
      "name": "channels.getLeftChannels",
      "description": [
        "Get a list of channels/supergroups we left"
      ],
      "parameters": {
        "offset": "Offset for pagination"
      },
      "errors": [
        {
          "code": 403,
          "type": "TAKEOUT_REQUIRED",
          "description": "A takeout session has to be initialized, first"
        }
      ]
    },
    "channels.getMessages": {
      "name": "channels.getMessages",
      "description": [
        "Get channel/supergroup messages"
      ],
      "parameters": {
        "channel": "Channel/supergroup",
        "id": "IDs of messages to get"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHANNEL_INVALID",
          "description": "The provided channel is invalid"
        },
        {
          "code": 400,
          "type": "CHANNEL_PRIVATE",
          "description": "You haven't joined this channel/supergroup"
        },
        {
          "code": 400,
          "type": "MESSAGE_IDS_EMPTY",
          "description": "No message ids were provided"
        },
        {
          "code": 400,
          "type": "MSG_ID_INVALID",
          "description": "Invalid message ID provided"
        }
      ]
    },
    "channels.getParticipant": {
      "name": "channels.getParticipant",
      "description": [
        "Get info about a channel/supergroup participant"
      ],
      "parameters": {
        "channel": "Channel/supergroup",
        "user_id": "ID of participant to get info about"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHANNEL_INVALID",
          "description": "The provided channel is invalid"
        },
        {
          "code": 400,
          "type": "CHANNEL_PRIVATE",
          "description": "You haven't joined this channel/supergroup"
        },
        {
          "code": 400,
          "type": "CHAT_ADMIN_REQUIRED",
          "description": "You must be an admin in this chat to do this"
        },
        {
          "code": 400,
          "type": "MSG_ID_INVALID",
          "description": "Invalid message ID provided"
        },
        {
          "code": 400,
          "type": "USER_ID_INVALID",
          "description": "The provided user ID is invalid"
        },
        {
          "code": 400,
          "type": "USER_NOT_PARTICIPANT",
          "description": "You're not a member of this supergroup/channel"
        }
      ]
    },
    "channels.getParticipants": {
      "name": "channels.getParticipants",
      "description": [
        "Get the participants of a supergroup/channel"
      ],
      "parameters": {
        "channel": "Channel",
        "filter": "Which participant types to fetch",
        "hash": "Hash",
        "limit": "Limit",
        "offset": "Offset"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHANNEL_INVALID",
          "description": "The provided channel is invalid"
        },
        {
          "code": 400,
          "type": "CHANNEL_PRIVATE",
          "description": "You haven't joined this channel/supergroup"
        },
        {
          "code": 400,
          "type": "CHAT_ADMIN_REQUIRED",
          "description": "You must be an admin in this chat to do this"
        },
        {
          "code": 400,
          "type": "INPUT_CONSTRUCTOR_INVALID",
          "description": "The provided constructor is invalid"
        }
      ]
    },
    "channels.inviteToChannel": {
      "name": "channels.inviteToChannel",
      "description": [
        "Invite users to a channel/supergroup"
      ],
      "parameters": {
        "channel": "Channel/supergroup",
        "users": "Users to invite"
      },
      "errors": [
        {
          "code": 400,
          "type": "BOTS_TOO_MUCH",
          "description": "There are too many bots in this chat/channel"
        },
        {
          "code": 400,
          "type": "BOT_GROUPS_BLOCKED",
          "description": "This bot can't be added to groups"
        },
        {
          "code": 400,
          "type": "CHANNEL_INVALID",
          "description": "The provided channel is invalid"
        },
        {
          "code": 400,
          "type": "CHANNEL_PRIVATE",
          "description": "You haven't joined this channel/supergroup"
        },
        {
          "code": 400,
          "type": "CHAT_ADMIN_REQUIRED",
          "description": "You must be an admin in this chat to do this"
        },
        {
          "code": 400,
          "type": "CHAT_INVALID",
          "description": "Invalid chat"
        },
        {
          "code": 403,
          "type": "CHAT_WRITE_FORBIDDEN",
          "description": "You can't write in this chat"
        },
        {
          "code": 400,
          "type": "INPUT_USER_DEACTIVATED",
          "description": "The specified user was deleted"
        },
        {
          "code": 400,
          "type": "MSG_ID_INVALID",
          "description": "Invalid message ID provided"
        },
        {
          "code": 400,
          "type": "USERS_TOO_MUCH",
          "description": "The maximum number of users has been exceeded (to create a chat, for example)"
        },
        {
          "code": 400,
          "type": "USER_BANNED_IN_CHANNEL",
          "description": "You're banned from sending messages in supergroups/channels"
        },
        {
          "code": 400,
          "type": "USER_BLOCKED",
          "description": "User blocked"
        },
        {
          "code": 400,
          "type": "USER_BOT",
          "description": "Bots can only be admins in channels."
        },
        {
          "code": 403,
          "type": "USER_CHANNELS_TOO_MUCH",
          "description": "One of the users you tried to add is already in too many channels/supergroups"
        },
        {
          "code": 400,
          "type": "USER_ID_INVALID",
          "description": "The provided user ID is invalid"
        },
        {
          "code": 400,
          "type": "USER_KICKED",
          "description": "This user was kicked from this supergroup/channel"
        },
        {
          "code": 400,
          "type": "USER_NOT_MUTUAL_CONTACT",
          "description": "The provided user is not a mutual contact"
        },
        {
          "code": 403,
          "type": "USER_PRIVACY_RESTRICTED",
          "description": "The user's privacy settings do not allow you to do this"
        }
      ]
    },
    "channels.joinChannel": {
      "name": "channels.joinChannel",
      "description": [
        "Join a channel/supergroup"
      ],
      "parameters": {
        "channel": "Channel/supergroup to join"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHANNELS_TOO_MUCH",
          "description": "You have joined too many channels/supergroups"
        },
        {
          "code": 400,
          "type": "CHANNEL_INVALID",
          "description": "The provided channel is invalid"
        },
        {
          "code": 400,
          "type": "CHANNEL_PRIVATE",
          "description": "You haven't joined this channel/supergroup"
        },
        {
          "code": 400,
          "type": "INVITE_HASH_EMPTY",
          "description": "The invite hash is empty"
        },
        {
          "code": 400,
          "type": "INVITE_HASH_EXPIRED",
          "description": "The invite link has expired"
        },
        {
          "code": 400,
          "type": "INVITE_HASH_INVALID",
          "description": "The invite hash is invalid"
        },
        {
          "code": 400,
          "type": "MSG_ID_INVALID",
          "description": "Invalid message ID provided"
        },
        {
          "code": 400,
          "type": "PEER_ID_INVALID",
          "description": "The provided peer id is invalid"
        },
        {
          "code": 400,
          "type": "USERS_TOO_MUCH",
          "description": "The maximum number of users has been exceeded (to create a chat, for example)"
        },
        {
          "code": 400,
          "type": "USER_ALREADY_PARTICIPANT",
          "description": "The user is already in the group"
        },
        {
          "code": 400,
          "type": "USER_CHANNELS_TOO_MUCH",
          "description": "One of the users you tried to add is already in too many channels/supergroups"
        }
      ]
    },
    "channels.leaveChannel": {
      "name": "channels.leaveChannel",
      "description": [
        "Leave a channel/supergroup"
      ],
      "parameters": {
        "channel": "Channel/supergroup to leave"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHANNEL_INVALID",
          "description": "The provided channel is invalid"
        },
        {
          "code": 400,
          "type": "CHANNEL_PRIVATE",
          "description": "You haven't joined this channel/supergroup"
        },
        {
          "code": 403,
          "type": "CHANNEL_PUBLIC_GROUP_NA",
          "description": "channel/supergroup not available"
        },
        {
          "code": 400,
          "type": "MSG_ID_INVALID",
          "description": "Invalid message ID provided"
        },
        {
          "code": 400,
          "type": "USER_CREATOR",
          "description": "You can't leave this channel, because you're its creator"
        },
        {
          "code": 400,
          "type": "USER_NOT_PARTICIPANT",
          "description": "You're not a member of this supergroup/channel"
        }
      ]
    },
    "channels.readHistory": {
      "name": "channels.readHistory",
      "description": [
        "Mark channel/supergroup history as read"
      ],
      "parameters": {
        "channel": "Channel/supergroup",
        "max_id": "ID of message up to which messages should be marked as read"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHANNEL_INVALID",
          "description": "The provided channel is invalid"
        },
        {
          "code": 400,
          "type": "CHANNEL_PRIVATE",
          "description": "You haven't joined this channel/supergroup"
        },
        {
          "code": 400,
          "type": "MSG_ID_INVALID",
          "description": "Invalid message ID provided"
        }
      ]
    },
    "channels.readMessageContents": {
      "name": "channels.readMessageContents",
      "description": [
        "Mark channel/supergroup message contents as read"
      ],
      "parameters": {
        "channel": "Channel/supergroup",
        "id": "IDs of messages whose contents should be marked as read"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHANNEL_INVALID",
          "description": "The provided channel is invalid"
        },
        {
          "code": 400,
          "type": "CHANNEL_PRIVATE",
          "description": "You haven't joined this channel/supergroup"
        },
        {
          "code": 400,
          "type": "MSG_ID_INVALID",
          "description": "Invalid message ID provided"
        }
      ]
    },
    "channels.reportSpam": {
      "name": "channels.reportSpam",
      "description": [
        "Reports some messages from a user in a supergroup as spam; requires administrator rights in the supergroup"
      ],
      "parameters": {
        "channel": "Supergroup",
        "id": "IDs of spam messages",
        "user_id": "ID of the user that sent the spam messages"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHANNEL_INVALID",
          "description": "The provided channel is invalid"
        },
        {
          "code": 400,
          "type": "CHAT_ADMIN_REQUIRED",
          "description": "You must be an admin in this chat to do this"
        },
        {
          "code": 400,
          "type": "INPUT_USER_DEACTIVATED",
          "description": "The specified user was deleted"
        },
        {
          "code": 400,
          "type": "USER_ID_INVALID",
          "description": "The provided user ID is invalid"
        }
      ]
    },
    "channels.setDiscussionGroup": {
      "name": "channels.setDiscussionGroup",
      "description": [
        "Associate a group to a channel as discussion group for that channel"
      ],
      "parameters": {
        "broadcast": "Channel",
        "group": "Discussion group to associate to the channel"
      },
      "errors": [
        {
          "code": 400,
          "type": "BROADCAST_ID_INVALID",
          "description": "Broadcast ID invalid"
        },
        {
          "code": 400,
          "type": "LINK_NOT_MODIFIED",
          "description": "Discussion link not modified"
        },
        {
          "code": 400,
          "type": "MEGAGROUP_ID_INVALID",
          "description": "Invalid supergroup ID"
        }
      ]
    },
    "channels.setStickers": {
      "name": "channels.setStickers",
      "description": [
        "Associate a stickerset to the supergroup"
      ],
      "parameters": {
        "channel": "Supergroup",
        "stickerset": "The stickerset to associate"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHANNEL_INVALID",
          "description": "The provided channel is invalid"
        },
        {
          "code": 400,
          "type": "PARTICIPANTS_TOO_FEW",
          "description": "Not enough participants"
        }
      ]
    },
    "channels.togglePreHistoryHidden": {
      "name": "channels.togglePreHistoryHidden",
      "description": [
        "Hide/unhide message history for new channel/supergroup users"
      ],
      "parameters": {
        "channel": "Channel/supergroup",
        "enabled": "Hide/unhide"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHANNEL_INVALID",
          "description": "The provided channel is invalid"
        },
        {
          "code": 400,
          "type": "CHANNEL_PRIVATE",
          "description": "You haven't joined this channel/supergroup"
        },
        {
          "code": 400,
          "type": "CHAT_ADMIN_REQUIRED",
          "description": "You must be an admin in this chat to do this"
        },
        {
          "code": 400,
          "type": "CHAT_ID_INVALID",
          "description": "The provided chat id is invalid"
        },
        {
          "code": 400,
          "type": "CHAT_LINK_EXISTS",
          "description": "The chat is public, you can't hide the history to new users"
        },
        {
          "code": 400,
          "type": "CHAT_NOT_MODIFIED",
          "description": "The pinned message wasn't modified"
        }
      ]
    },
    "channels.toggleSignatures": {
      "name": "channels.toggleSignatures",
      "description": [
        "Enable/disable message signatures in channels"
      ],
      "parameters": {
        "channel": "Channel",
        "enabled": "Value"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHANNEL_INVALID",
          "description": "The provided channel is invalid"
        },
        {
          "code": 400,
          "type": "CHAT_ID_INVALID",
          "description": "The provided chat id is invalid"
        }
      ]
    },
    "channels.toggleSlowMode": {
      "name": "channels.toggleSlowMode",
      "description": [
        "Toggle supergroup slow mode: if enabled, users will only be able to send one message every seconds seconds"
      ],
      "parameters": {
        "channel": "The supergroup",
        "seconds": "Users will only be able to send one message every seconds seconds, 0 to disable the limitation"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHAT_ADMIN_REQUIRED",
          "description": "You must be an admin in this chat to do this"
        },
        {
          "code": 400,
          "type": "CHAT_NOT_MODIFIED",
          "description": "The pinned message wasn't modified"
        },
        {
          "code": 400,
          "type": "INPUT_METHOD_INVALID_1192227_X",
          "description": "Invalid method"
        },
        {
          "code": 400,
          "type": "INPUT_METHOD_INVALID_1604042050_X",
          "description": "Invalid method"
        },
        {
          "code": 400,
          "type": "SECONDS_INVALID",
          "description": "Invalid duration provided"
        }
      ]
    },
    "channels.updateUsername": {
      "name": "channels.updateUsername",
      "description": [
        "Change the username of a supergroup/channel"
      ],
      "parameters": {
        "channel": "Channel",
        "username": "New username"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHANNELS_ADMIN_PUBLIC_TOO_MUCH",
          "description": "You're admin of too many public channels, make some channels private to change the username of this channel"
        },
        {
          "code": 400,
          "type": "CHANNEL_INVALID",
          "description": "The provided channel is invalid"
        },
        {
          "code": 400,
          "type": "CHANNEL_PRIVATE",
          "description": "You haven't joined this channel/supergroup"
        },
        {
          "code": 400,
          "type": "CHAT_ADMIN_REQUIRED",
          "description": "You must be an admin in this chat to do this"
        },
        {
          "code": 400,
          "type": "CHAT_NOT_MODIFIED",
          "description": "The pinned message wasn't modified"
        },
        {
          "code": 403,
          "type": "CHAT_WRITE_FORBIDDEN",
          "description": "You can't write in this chat"
        },
        {
          "code": 400,
          "type": "USERNAME_INVALID",
          "description": "The provided username is not valid"
        },
        {
          "code": 400,
          "type": "USERNAME_NOT_MODIFIED",
          "description": "The username was not modified"
        },
        {
          "code": 400,
          "type": "USERNAME_OCCUPIED",
          "description": "The provided username is already occupied"
        }
      ]
    },
    "contacts.acceptContact": {
      "name": "contacts.acceptContact",
      "description": [
        "If the peer settings of a new user allow us to add him as contact, add that user as contact"
      ],
      "parameters": {
        "id": "The user to add as contact"
      },
      "errors": [
        {
          "code": 400,
          "type": "CONTACT_ADD_MISSING",
          "description": "Contact to add is missing"
        },
        {
          "code": 400,
          "type": "CONTACT_ID_INVALID",
          "description": "The provided contact ID is invalid"
        },
        {
          "code": 400,
          "type": "CONTACT_REQ_MISSING",
          "description": "Missing contact request"
        }
      ]
    },
    "contacts.addContact": {
      "name": "contacts.addContact",
      "description": [
        "Add an existing telegram user as contact.",
        "Use contacts.importContacts to add contacts by phone number, without knowing their Telegram ID."
      ],
      "parameters": {
        "add_phone_privacy_exception": "Allow the other user to see our phone number?",
        "first_name": "First name",
        "flags": "Flags, see TL conditional fields",
        "id": "Telegram ID of the other user",
        "last_name": "Last name",
        "phone": "User's phone number"
      },
      "errors": [
        {
          "code": 400,
          "type": "CONTACT_ID_INVALID",
          "description": "The provided contact ID is invalid"
        },
        {
          "code": 400,
          "type": "CONTACT_NAME_EMPTY",
          "description": "Contact name empty"
        },
        {
          "code": 400,
          "type": "MSG_ID_INVALID",
          "description": "Invalid message ID provided"
        }
      ]
    },
    "contacts.block": {
      "name": "contacts.block",
      "description": [
        "Adds the user to the blacklist."
      ],
      "parameters": {
        "id": "User ID"
      },
      "errors": [
        {
          "code": 400,
          "type": "CONTACT_ID_INVALID",
          "description": "The provided contact ID is invalid"
        },
        {
          "code": 400,
          "type": "INPUT_USER_DEACTIVATED",
          "description": "The specified user was deleted"
        },
        {
          "code": 400,
          "type": "MSG_ID_INVALID",
          "description": "Invalid message ID provided"
        },
        {
          "code": 400,
          "type": "PEER_ID_INVALID",
          "description": "The provided peer id is invalid"
        }
      ]
    },
    "contacts.blockFromReplies": {
      "name": "contacts.blockFromReplies",
      "description": [
        "Stop getting notifications about thread replies of a certain user in @replies"
      ],
      "parameters": {
        "delete_history": "Whether to delete all @replies messages from this user as well",
        "delete_message": "Whether to delete the specified message as well",
        "flags": "Flags, see TL conditional fields",
        "msg_id": "ID of the message in the @replies chat",
        "report_spam": "Whether to also report this user for spam"
      }
    },
    "contacts.deleteByPhones": {
      "name": "contacts.deleteByPhones",
      "description": [
        "Delete contacts by phone number"
      ],
      "parameters": {
        "phones": "Phone numbers"
      }
    },
    "contacts.deleteContacts": {
      "name": "contacts.deleteContacts",
      "description": [
        "Deletes several contacts from the list."
      ],
      "parameters": {
        "id": "User ID list"
      }
    },
    "contacts.getBlocked": {
      "name": "contacts.getBlocked",
      "description": [
        "Returns the list of blocked users."
      ],
      "parameters": {
        "limit": "The number of list elements to be returned",
        "offset": "The number of list elements to be skipped"
      }
    },
    "contacts.getContactIDs": {
      "name": "contacts.getContactIDs",
      "description": [
        "Get contact by telegram IDs"
      ],
      "parameters": {
        "hash": "Hash for pagination, for more info click here"
      }
    },
    "contacts.getContacts": {
      "name": "contacts.getContacts",
      "description": [
        "Returns the current user's contact list."
      ],
      "parameters": {
        "hash": "If there already is a full contact list on the client, a hash of a the list of contact IDs in ascending order may be passed in this parameter. If the contact set was not changed, (contacts.contactsNotModified) will be returned."
      }
    },
    "contacts.getLocated": {
      "name": "contacts.getLocated",
      "description": [
        "Get contacts near you"
      ],
      "parameters": {
        "background": "While the geolocation of the current user is public, clients should update it in the background every half-an-hour or so, while setting this flag. Do this only if the new location is more than 1 KM away from the previous one, or if the previous location is unknown.",
        "flags": "Flags, see TL conditional fields",
        "geo_point": "Geolocation",
        "self_expires": "If set, the geolocation of the current user will be public for the specified number of seconds; pass 0x7fffffff to disable expiry, 0 to make the current geolocation private; if the flag isn't set, no changes will be applied."
      },
      "errors": [
        {
          "code": 400,
          "type": "GEO_POINT_INVALID",
          "description": "Invalid geoposition provided"
        },
        {
          "code": 406,
          "type": "USERPIC_UPLOAD_REQUIRED",
          "description": "You must have a profile picture to publish your geolocation"
        }
      ]
    },
    "contacts.getSaved": {
      "name": "contacts.getSaved",
      "description": [
        "Get all contacts"
      ],
      "parameters": {
        "403": "A takeout session has to be initialized, first"
      },
      "errors": [
        {
          "code": 403,
          "type": "TAKEOUT_REQUIRED",
          "description": "A takeout session has to be initialized, first"
        }
      ]
    },
    "contacts.getStatuses": {
      "name": "contacts.getStatuses",
      "description": [
        "Returns the list of contact statuses."
      ]
    },
    "contacts.getTopPeers": {
      "name": "contacts.getTopPeers",
      "description": [
        "Get most used peers"
      ],
      "parameters": {
        "bots_inline": "Most used inline bots",
        "bots_pm": "Most used bots",
        "channels": "Most frequently visited channels",
        "correspondents": "Users we've chatted most frequently with",
        "flags": "Flags, see TL conditional fields",
        "forward_chats": "Chats to which the users often forwards messages to",
        "forward_users": "Users to which the users often forwards messages to",
        "groups": "Often-opened groups and supergroups",
        "hash": "Hash for pagination, for more info click here",
        "limit": "Maximum number of results to return, see pagination",
        "offset": "Offset for pagination",
        "phone_calls": "Most frequently called users"
      },
      "errors": [
        {
          "code": 400,
          "type": "TYPES_EMPTY",
          "description": "No top peer type was provided"
        }
      ]
    },
    "contacts.importContacts": {
      "name": "contacts.importContacts",
      "description": [
        "Imports contacts: saves a full list on the server, adds already registered contacts to the contact list, returns added contacts and their info.",
        "Use contacts.addContact to add Telegram contacts without actually using their phone number."
      ],
      "parameters": {
        "contacts": "List of contacts to import"
      }
    },
    "contacts.resetSaved": {
      "name": "contacts.resetSaved",
      "description": [
        "Delete saved contacts"
      ]
    },
    "contacts.resetTopPeerRating": {
      "name": "contacts.resetTopPeerRating",
      "description": [
        "Reset rating of top peer"
      ],
      "parameters": {
        "category": "Top peer category",
        "peer": "Peer whose rating should be reset"
      },
      "errors": [
        {
          "code": 400,
          "type": "PEER_ID_INVALID",
          "description": "The provided peer id is invalid"
        }
      ]
    },
    "contacts.resolveUsername": {
      "name": "contacts.resolveUsername",
      "description": [
        "Resolve a @username to get peer info"
      ],
      "parameters": {
        "username": "@username to resolve"
      },
      "errors": [
        {
          "code": 401,
          "type": "AUTH_KEY_PERM_EMPTY",
          "description": "The temporary auth key must be binded to the permanent auth key to use these methods."
        },
        {
          "code": 400,
          "type": "CONNECTION_DEVICE_MODEL_EMPTY",
          "description": "Device model empty"
        },
        {
          "code": 400,
          "type": "CONNECTION_LAYER_INVALID",
          "description": "Layer invalid"
        },
        {
          "code": 400,
          "type": "USERNAME_INVALID",
          "description": "The provided username is not valid"
        },
        {
          "code": 400,
          "type": "USERNAME_NOT_OCCUPIED",
          "description": "The provided username is not occupied"
        }
      ]
    },
    "contacts.search": {
      "name": "contacts.search",
      "description": [
        "Returns users found by username substring."
      ],
      "parameters": {
        "limit": "Maximum number of users to be returned",
        "q": "Target substring"
      },
      "errors": [
        {
          "code": 400,
          "type": "QUERY_TOO_SHORT",
          "description": "The query string is too short"
        },
        {
          "code": 400,
          "type": "SEARCH_QUERY_EMPTY",
          "description": "The search query is empty"
        }
      ]
    },
    "contacts.toggleTopPeers": {
      "name": "contacts.toggleTopPeers",
      "description": [
        "Enable/disable top peers"
      ],
      "parameters": {
        "enabled": "Enable/disable"
      }
    },
    "contacts.unblock": {
      "name": "contacts.unblock",
      "description": [
        "Deletes the user from the blacklist."
      ],
      "parameters": {
        "id": "User ID"
      },
      "errors": [
        {
          "code": 400,
          "type": "CONTACT_ID_INVALID",
          "description": "The provided contact ID is invalid"
        }
      ]
    },
    "folders.deleteFolder": {
      "name": "folders.deleteFolder",
      "description": [
        "Delete a peer folder"
      ],
      "parameters": {
        "folder_id": "Peer folder ID, for more info click here"
      }
    },
    "folders.editPeerFolders": {
      "name": "folders.editPeerFolders",
      "description": [
        "Edit peers in peer folder"
      ],
      "parameters": {
        "folder_peers": "New peer list"
      },
      "errors": [
        {
          "code": 400,
          "type": "FOLDER_ID_INVALID",
          "description": "Invalid folder ID"
        }
      ]
    },
    "help.acceptTermsOfService": {
      "name": "help.acceptTermsOfService",
      "description": [
        "Accept the new terms of service"
      ],
      "parameters": {
        "id": "ID of terms of service"
      }
    },
    "help.dismissSuggestion": {
      "name": "help.dismissSuggestion",
      "description": [
        "Dismiss a suggestion"
      ],
      "parameters": {
        "suggestion": "Suggestion"
      }
    },
    "help.editUserInfo": {
      "name": "help.editUserInfo",
      "description": [
        "Internal use"
      ],
      "parameters": {
        "entities": "Message entities for styled text",
        "message": "Message",
        "user_id": "User"
      }
    },
    "help.getAppChangelog": {
      "name": "help.getAppChangelog",
      "description": [
        "Get changelog of current app.\nTypically, an updates constructor will be returned, containing one or more updateServiceNotification updates with app-specific changelogs."
      ],
      "parameters": {
        "prev_app_version": "Previous app version"
      }
    },
    "help.getAppConfig": {
      "name": "help.getAppConfig",
      "description": [
        "Get app-specific configuration, see client configuration for more info on the result."
      ]
    },
    "help.getAppUpdate": {
      "name": "help.getAppUpdate",
      "description": [
        "Returns information on update availability for the current application."
      ],
      "parameters": {
        "source": "Source"
      }
    },
    "help.getCdnConfig": {
      "name": "help.getCdnConfig",
      "description": [
        "Get configuration for CDN file downloads."
      ],
      "parameters": {
        "401": "The temporary auth key must be binded to the permanent auth key to use these methods."
      },
      "errors": [
        {
          "code": 401,
          "type": "AUTH_KEY_PERM_EMPTY",
          "description": "The temporary auth key must be binded to the permanent auth key to use these methods."
        }
      ]
    },
    "help.getConfig": {
      "name": "help.getConfig",
      "description": [
        "Returns current configuration, including data center configuration."
      ],
      "parameters": {
        "400": "Invalid message ID provided"
      },
      "errors": [
        {
          "code": 400,
          "type": "CONNECTION_API_ID_INVALID",
          "description": "The provided API id is invalid"
        },
        {
          "code": 400,
          "type": "CONNECTION_APP_VERSION_EMPTY",
          "description": "App version is empty"
        },
        {
          "code": 400,
          "type": "CONNECTION_DEVICE_MODEL_EMPTY",
          "description": "Device model empty"
        },
        {
          "code": 400,
          "type": "CONNECTION_LANG_PACK_INVALID",
          "description": "Language pack invalid"
        },
        {
          "code": 400,
          "type": "CONNECTION_LAYER_INVALID",
          "description": "Layer invalid"
        },
        {
          "code": 400,
          "type": "CONNECTION_NOT_INITED",
          "description": "Connection not initialized"
        },
        {
          "code": 400,
          "type": "CONNECTION_SYSTEM_EMPTY",
          "description": "Connection system empty"
        },
        {
          "code": 400,
          "type": "CONNECTION_SYSTEM_LANG_CODE_EMPTY",
          "description": "The system_lang_code field is empty"
        },
        {
          "code": 400,
          "type": "DATA_INVALID",
          "description": "Encrypted data invalid"
        },
        {
          "code": 400,
          "type": "INPUT_LAYER_INVALID",
          "description": "The provided layer is invalid"
        },
        {
          "code": 400,
          "type": "MSG_ID_INVALID",
          "description": "Invalid message ID provided"
        }
      ]
    },
    "help.getCountriesList": {
      "name": "help.getCountriesList",
      "description": [
        "Get name, ISO code, localized name and phone codes/patterns of all available countries"
      ],
      "parameters": {
        "hash": "Hash for pagination, for more info click here",
        "lang_code": "Language code of the current user"
      }
    },
    "help.getDeepLinkInfo": {
      "name": "help.getDeepLinkInfo",
      "description": [
        "Get info about a t.me link"
      ],
      "parameters": {
        "path": "Path in t.me/path"
      }
    },
    "help.getInviteText": {
      "name": "help.getInviteText",
      "description": [
        "Returns localized text of a text message with an invitation."
      ]
    },
    "help.getNearestDc": {
      "name": "help.getNearestDc",
      "description": [
        "Returns info on data centre nearest to the user."
      ]
    },
    "help.getPassportConfig": {
      "name": "help.getPassportConfig",
      "description": [
        "Get passport configuration"
      ],
      "parameters": {
        "hash": "Hash for pagination, for more info click here"
      }
    },
    "help.getPromoData": {
      "name": "help.getPromoData",
      "description": [
        "Get MTProxy/Public Service Announcement information"
      ]
    },
    "help.getRecentMeUrls": {
      "name": "help.getRecentMeUrls",
      "description": [
        "Get recently used t.me links"
      ],
      "parameters": {
        "referer": "Referer"
      }
    },
    "help.getSupport": {
      "name": "help.getSupport",
      "description": [
        "Returns the support user for the 'ask a question' feature."
      ]
    },
    "help.getSupportName": {
      "name": "help.getSupportName",
      "description": [
        "Get localized name of the telegram support user"
      ],
      "parameters": {
        "403": "Invalid user provided"
      },
      "errors": [
        {
          "code": 403,
          "type": "USER_INVALID",
          "description": "Invalid user provided"
        }
      ]
    },
    "help.getTermsOfServiceUpdate": {
      "name": "help.getTermsOfServiceUpdate",
      "description": [
        "Look for updates of telegram's terms of service"
      ]
    },
    "help.getUserInfo": {
      "name": "help.getUserInfo",
      "description": [
        "Internal use"
      ],
      "parameters": {
        "user_id": "User ID"
      },
      "errors": [
        {
          "code": 403,
          "type": "USER_INVALID",
          "description": "Invalid user provided"
        }
      ]
    },
    "help.hidePromoData": {
      "name": "help.hidePromoData",
      "description": [
        "Hide MTProxy/Public Service Announcement information"
      ],
      "parameters": {
        "peer": "Peer to hide"
      }
    },
    "help.saveAppLog": {
      "name": "help.saveAppLog",
      "description": [
        "Saves logs of application on the server."
      ],
      "parameters": {
        "events": "List of input events"
      }
    },
    "help.setBotUpdatesStatus": {
      "name": "help.setBotUpdatesStatus",
      "description": [
        "Informs the server about the number of pending bot updates if they haven't been processed for a long time; for bots only"
      ],
      "parameters": {
        "message": "Error message, if present",
        "pending_updates_count": "Number of pending updates"
      }
    },
    "initConnection": {
      "name": "initConnection",
      "description": [
        "Initialize connection"
      ],
      "parameters": {
        "api_id": "Application identifier (see. App configuration)",
        "app_version": "Application version",
        "device_model": "Device model",
        "flags": "Flags, see TL conditional fields",
        "lang_code": "Code for the language used on the client, ISO 639-1 standard",
        "lang_pack": "Language pack to use",
        "params": "Additional initConnection parameters. For now, only the tz_offset field is supported, for specifying timezone offset in seconds.",
        "proxy": "Info about an MTProto proxy",
        "query": "The query itself",
        "system_lang_code": "Code for the language used on the device's OS, ISO 639-1 standard",
        "system_version": "Operation system version"
      },
      "errors": [
        {
          "code": 400,
          "type": "CONNECTION_LAYER_INVALID",
          "description": "Layer invalid"
        }
      ]
    },
    "invokeAfterMsg": {
      "name": "invokeAfterMsg",
      "description": [
        "Invokes a query after successfull completion of one of the previous queries."
      ],
      "parameters": {
        "msg_id": "Message identifier on which a current query depends",
        "query": "The query itself"
      }
    },
    "invokeAfterMsgs": {
      "name": "invokeAfterMsgs",
      "description": [
        "Invokes a query after a successfull completion of previous queries"
      ],
      "parameters": {
        "msg_ids": "List of messages on which a current query depends",
        "query": "The query itself"
      }
    },
    "invokeWithLayer": {
      "name": "invokeWithLayer",
      "description": [
        "Invoke the specified query using the specified API layer"
      ],
      "parameters": {
        "layer": "The layer to use",
        "query": "The query"
      },
      "errors": [
        {
          "code": 400,
          "type": "AUTH_BYTES_INVALID",
          "description": "The provided authorization is invalid"
        },
        {
          "code": 400,
          "type": "CDN_METHOD_INVALID",
          "description": "You can't call this method in a CDN DC"
        },
        {
          "code": 403,
          "type": "CHAT_WRITE_FORBIDDEN",
          "description": "You can't write in this chat"
        },
        {
          "code": 400,
          "type": "CONNECTION_API_ID_INVALID",
          "description": "The provided API id is invalid"
        },
        {
          "code": 400,
          "type": "CONNECTION_DEVICE_MODEL_EMPTY",
          "description": "Device model empty"
        },
        {
          "code": 400,
          "type": "CONNECTION_LANG_PACK_INVALID",
          "description": "Language pack invalid"
        },
        {
          "code": 400,
          "type": "CONNECTION_NOT_INITED",
          "description": "Connection not initialized"
        },
        {
          "code": 400,
          "type": "CONNECTION_SYSTEM_EMPTY",
          "description": "Connection system empty"
        },
        {
          "code": 400,
          "type": "INPUT_LAYER_INVALID",
          "description": "The provided layer is invalid"
        },
        {
          "code": 400,
          "type": "INVITE_HASH_EXPIRED",
          "description": "The invite link has expired"
        }
      ]
    },
    "invokeWithMessagesRange": {
      "name": "invokeWithMessagesRange",
      "description": [
        "Invoke with the given message range"
      ],
      "parameters": {
        "query": "Query",
        "range": "Message range"
      }
    },
    "invokeWithTakeout": {
      "name": "invokeWithTakeout",
      "description": [
        "Invoke a method within a takeout session"
      ],
      "parameters": {
        "query": "Query",
        "takeout_id": "Takeout session ID"
      },
      "errors": [
        {
          "code": 400,
          "type": "INPUT_METHOD_INVALID_1400137063_X",
          "description": "Invalid method"
        }
      ]
    },
    "invokeWithoutUpdates": {
      "name": "invokeWithoutUpdates",
      "description": [
        "Invoke a request without subscribing the used connection for updates (this is enabled by default for file queries)."
      ],
      "parameters": {
        "query": "The query"
      }
    },
    "langpack.getDifference": {
      "name": "langpack.getDifference",
      "description": [
        "Get new strings in languagepack"
      ],
      "parameters": {
        "from_version": "Previous localization pack version",
        "lang_code": "Language code",
        "lang_pack": "Language pack"
      },
      "errors": [
        {
          "code": 400,
          "type": "LANG_PACK_INVALID",
          "description": "The provided language pack is invalid"
        }
      ]
    },
    "langpack.getLangPack": {
      "name": "langpack.getLangPack",
      "description": [
        "Get localization pack strings"
      ],
      "parameters": {
        "lang_code": "Language code",
        "lang_pack": "Language pack name"
      },
      "errors": [
        {
          "code": 400,
          "type": "LANG_PACK_INVALID",
          "description": "The provided language pack is invalid"
        }
      ]
    },
    "langpack.getLanguage": {
      "name": "langpack.getLanguage",
      "description": [
        "Get information about a language in a localization pack"
      ],
      "parameters": {
        "lang_code": "Language code",
        "lang_pack": "Language pack name"
      }
    },
    "langpack.getLanguages": {
      "name": "langpack.getLanguages",
      "description": [
        "Get information about all languages in a localization pack"
      ],
      "parameters": {
        "lang_pack": "Language pack"
      },
      "errors": [
        {
          "code": 400,
          "type": "LANG_PACK_INVALID",
          "description": "The provided language pack is invalid"
        }
      ]
    },
    "langpack.getStrings": {
      "name": "langpack.getStrings",
      "description": [
        "Get strings from a language pack"
      ],
      "parameters": {
        "keys": "Strings to get",
        "lang_code": "Language code",
        "lang_pack": "Language pack name"
      },
      "errors": [
        {
          "code": 400,
          "type": "LANG_PACK_INVALID",
          "description": "The provided language pack is invalid"
        }
      ]
    },
    "messages.acceptEncryption": {
      "name": "messages.acceptEncryption",
      "description": [
        "Confirms creation of a secret chat"
      ],
      "parameters": {
        "g_b": "B = g ^ b mod p, see Wikipedia",
        "key_fingerprint": "64-bit fingerprint of the received key",
        "peer": "Secret chat ID"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHAT_ID_INVALID",
          "description": "The provided chat id is invalid"
        },
        {
          "code": 400,
          "type": "ENCRYPTION_ALREADY_ACCEPTED",
          "description": "Secret chat already accepted"
        },
        {
          "code": 400,
          "type": "ENCRYPTION_ALREADY_DECLINED",
          "description": "The secret chat was already declined"
        }
      ]
    },
    "messages.acceptUrlAuth": {
      "name": "messages.acceptUrlAuth",
      "description": [
        "Use this to accept a Seamless Telegram Login authorization request, for more info click here "
      ],
      "parameters": {
        "button_id": "ID of the login button",
        "flags": "Flags, see TL conditional fields",
        "msg_id": "Message ID of the message with the login button",
        "peer": "The location of the message",
        "write_allowed": "Set this flag to allow the bot to send messages to you (if requested)"
      }
    },
    "messages.addChatUser": {
      "name": "messages.addChatUser",
      "description": [
        "Adds a user to a chat and sends a service message on it."
      ],
      "parameters": {
        "chat_id": "Chat ID",
        "fwd_limit": "Number of last messages to be forwarded",
        "user_id": "User ID to be added"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHAT_ADMIN_REQUIRED",
          "description": "You must be an admin in this chat to do this"
        },
        {
          "code": 400,
          "type": "CHAT_ID_INVALID",
          "description": "The provided chat id is invalid"
        },
        {
          "code": 403,
          "type": "CHAT_WRITE_FORBIDDEN",
          "description": "You can't write in this chat"
        },
        {
          "code": 400,
          "type": "INPUT_USER_DEACTIVATED",
          "description": "The specified user was deleted"
        },
        {
          "code": 400,
          "type": "PEER_ID_INVALID",
          "description": "The provided peer id is invalid"
        },
        {
          "code": 400,
          "type": "USERS_TOO_MUCH",
          "description": "The maximum number of users has been exceeded (to create a chat, for example)"
        },
        {
          "code": 400,
          "type": "USER_ALREADY_PARTICIPANT",
          "description": "The user is already in the group"
        },
        {
          "code": 400,
          "type": "USER_ID_INVALID",
          "description": "The provided user ID is invalid"
        },
        {
          "code": 403,
          "type": "USER_NOT_MUTUAL_CONTACT",
          "description": "The provided user is not a mutual contact"
        },
        {
          "code": 403,
          "type": "USER_PRIVACY_RESTRICTED",
          "description": "The user's privacy settings do not allow you to do this"
        }
      ]
    },
    "messages.checkChatInvite": {
      "name": "messages.checkChatInvite",
      "description": [
        "Check the validity of a chat invite link and get basic info about it"
      ],
      "parameters": {
        "hash": "Invite hash in t.me/joinchat/hash"
      },
      "errors": [
        {
          "code": 400,
          "type": "INVITE_HASH_EMPTY",
          "description": "The invite hash is empty"
        },
        {
          "code": 400,
          "type": "INVITE_HASH_EXPIRED",
          "description": "The invite link has expired"
        },
        {
          "code": 400,
          "type": "INVITE_HASH_INVALID",
          "description": "The invite hash is invalid"
        }
      ]
    },
    "messages.clearAllDrafts": {
      "name": "messages.clearAllDrafts",
      "description": [
        "Clear all drafts."
      ]
    },
    "messages.clearRecentStickers": {
      "name": "messages.clearRecentStickers",
      "description": [
        "Clear recent stickers"
      ],
      "parameters": {
        "attached": "Set this flag to clear the list of stickers recently attached to photo or video files",
        "flags": "Flags, see TL conditional fields"
      }
    },
    "messages.createChat": {
      "name": "messages.createChat",
      "description": [
        "Creates a new chat."
      ],
      "parameters": {
        "title": "Chat name",
        "users": "List of user IDs to be invited"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHAT_INVALID",
          "description": "Invalid chat"
        },
        {
          "code": 400,
          "type": "CHAT_TITLE_EMPTY",
          "description": "No chat title provided"
        },
        {
          "code": 400,
          "type": "INPUT_USER_DEACTIVATED",
          "description": "The specified user was deleted"
        },
        {
          "code": 400,
          "type": "USERS_TOO_FEW",
          "description": "Not enough users (to create a chat, for example)"
        },
        {
          "code": 403,
          "type": "USER_RESTRICTED",
          "description": "You're spamreported, you can't create channels or chats."
        }
      ]
    },
    "messages.deleteChatUser": {
      "name": "messages.deleteChatUser",
      "description": [
        "Deletes a user from a chat and sends a service message on it."
      ],
      "parameters": {
        "chat_id": "Chat ID",
        "user_id": "User ID to be deleted"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHAT_ADMIN_REQUIRED",
          "description": "You must be an admin in this chat to do this"
        },
        {
          "code": 400,
          "type": "CHAT_ID_INVALID",
          "description": "The provided chat id is invalid"
        },
        {
          "code": 400,
          "type": "PEER_ID_INVALID",
          "description": "The provided peer id is invalid"
        },
        {
          "code": 400,
          "type": "USER_ID_INVALID",
          "description": "The provided user ID is invalid"
        },
        {
          "code": 400,
          "type": "USER_NOT_PARTICIPANT",
          "description": "You're not a member of this supergroup/channel"
        }
      ]
    },
    "messages.deleteHistory": {
      "name": "messages.deleteHistory",
      "description": [
        "Deletes communication history."
      ],
      "parameters": {
        "flags": "Flags, see TL conditional fields",
        "just_clear": "Just clear history for the current user, without actually removing messages for every chat user",
        "max_id": "Maximum ID of message to delete",
        "peer": "User or chat, communication history of which will be deleted",
        "revoke": "Whether to delete the message history for all chat participants"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHAT_ID_INVALID",
          "description": "The provided chat id is invalid"
        },
        {
          "code": 400,
          "type": "MESSAGE_ID_INVALID",
          "description": "The provided message id is invalid"
        },
        {
          "code": 400,
          "type": "MSG_ID_INVALID",
          "description": "Invalid message ID provided"
        },
        {
          "code": 400,
          "type": "PEER_ID_INVALID",
          "description": "The provided peer id is invalid"
        }
      ]
    },
    "messages.deleteMessages": {
      "name": "messages.deleteMessages",
      "description": [
        "Deletes messages by their identifiers."
      ],
      "parameters": {
        "flags": "Flags, see TL conditional fields",
        "id": "Message ID list",
        "revoke": "Whether to delete messages for all participants of the chat"
      },
      "errors": [
        {
          "code": 403,
          "type": "MESSAGE_DELETE_FORBIDDEN",
          "description": "You can't delete one of the messages you tried to delete, most likely because it is a service message."
        }
      ]
    },
    "messages.deleteScheduledMessages": {
      "name": "messages.deleteScheduledMessages",
      "description": [
        "Delete scheduled messages"
      ],
      "parameters": {
        "id": "Scheduled message IDs",
        "peer": "Peer"
      }
    },
    "messages.discardEncryption": {
      "name": "messages.discardEncryption",
      "description": [
        "Cancels a request for creation and/or delete info on secret chat."
      ],
      "parameters": {
        "chat_id": "Secret chat ID"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHAT_ID_EMPTY",
          "description": "The provided chat ID is empty"
        },
        {
          "code": 400,
          "type": "ENCRYPTION_ALREADY_DECLINED",
          "description": "The secret chat was already declined"
        },
        {
          "code": 400,
          "type": "ENCRYPTION_ID_INVALID",
          "description": "The provided secret chat ID is invalid"
        }
      ]
    },
    "messages.editChatAbout": {
      "name": "messages.editChatAbout",
      "description": [
        "Edit the description of a group/supergroup/channel."
      ],
      "parameters": {
        "about": "The new description",
        "peer": "The group/supergroup/channel."
      },
      "errors": [
        {
          "code": 400,
          "type": "CHANNEL_INVALID",
          "description": "The provided channel is invalid"
        },
        {
          "code": 400,
          "type": "CHANNEL_PRIVATE",
          "description": "You haven't joined this channel/supergroup"
        },
        {
          "code": 400,
          "type": "CHAT_ABOUT_NOT_MODIFIED",
          "description": "About text has not changed"
        },
        {
          "code": 400,
          "type": "CHAT_ABOUT_TOO_LONG",
          "description": "Chat about too long"
        },
        {
          "code": 400,
          "type": "CHAT_ADMIN_REQUIRED",
          "description": "You must be an admin in this chat to do this"
        },
        {
          "code": 400,
          "type": "CHAT_NOT_MODIFIED",
          "description": "The pinned message wasn't modified"
        },
        {
          "code": 403,
          "type": "CHAT_WRITE_FORBIDDEN",
          "description": "You can't write in this chat"
        },
        {
          "code": 400,
          "type": "PEER_ID_INVALID",
          "description": "The provided peer id is invalid"
        }
      ]
    },
    "messages.editChatAdmin": {
      "name": "messages.editChatAdmin",
      "description": [
        "Make a user admin in a legacy group."
      ],
      "parameters": {
        "chat_id": "The ID of the group",
        "is_admin": "Whether to make him admin",
        "user_id": "The user to make admin"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHAT_ID_INVALID",
          "description": "The provided chat id is invalid"
        },
        {
          "code": 400,
          "type": "PEER_ID_INVALID",
          "description": "The provided peer id is invalid"
        },
        {
          "code": 400,
          "type": "USER_ID_INVALID",
          "description": "The provided user ID is invalid"
        },
        {
          "code": 400,
          "type": "USER_NOT_PARTICIPANT",
          "description": "You're not a member of this supergroup/channel"
        }
      ]
    },
    "messages.editChatDefaultBannedRights": {
      "name": "messages.editChatDefaultBannedRights",
      "description": [
        "Edit the default banned rights of a channel/supergroup/group."
      ],
      "parameters": {
        "banned_rights": "The new global rights",
        "peer": "The peer"
      },
      "errors": [
        {
          "code": 400,
          "type": "BANNED_RIGHTS_INVALID",
          "description": "You provided some invalid flags in the banned rights"
        },
        {
          "code": 400,
          "type": "CHAT_ADMIN_REQUIRED",
          "description": "You must be an admin in this chat to do this"
        },
        {
          "code": 400,
          "type": "CHAT_NOT_MODIFIED",
          "description": "The pinned message wasn't modified"
        },
        {
          "code": 400,
          "type": "PEER_ID_INVALID",
          "description": "The provided peer id is invalid"
        },
        {
          "code": 400,
          "type": "UNTIL_DATE_INVALID",
          "description": "Invalid until date provided"
        }
      ]
    },
    "messages.editChatPhoto": {
      "name": "messages.editChatPhoto",
      "description": [
        "Changes chat photo and sends a service message on it"
      ],
      "parameters": {
        "chat_id": "Chat ID",
        "photo": "Photo to be set"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHAT_ID_INVALID",
          "description": "The provided chat id is invalid"
        },
        {
          "code": 400,
          "type": "CHAT_NOT_MODIFIED",
          "description": "The pinned message wasn't modified"
        },
        {
          "code": 400,
          "type": "INPUT_CONSTRUCTOR_INVALID",
          "description": "The provided constructor is invalid"
        },
        {
          "code": 400,
          "type": "PEER_ID_INVALID",
          "description": "The provided peer id is invalid"
        },
        {
          "code": 400,
          "type": "PHOTO_CROP_SIZE_SMALL",
          "description": "Photo is too small"
        },
        {
          "code": 400,
          "type": "PHOTO_EXT_INVALID",
          "description": "The extension of the photo is invalid"
        },
        {
          "code": 400,
          "type": "PHOTO_INVALID",
          "description": "Photo invalid"
        }
      ]
    },
    "messages.editChatTitle": {
      "name": "messages.editChatTitle",
      "description": [
        "Chanages chat name and sends a service message on it."
      ],
      "parameters": {
        "chat_id": "Chat ID",
        "title": "New chat name, different from the old one"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHAT_ID_INVALID",
          "description": "The provided chat id is invalid"
        },
        {
          "code": 400,
          "type": "CHAT_NOT_MODIFIED",
          "description": "The pinned message wasn't modified"
        },
        {
          "code": 400,
          "type": "CHAT_TITLE_EMPTY",
          "description": "No chat title provided"
        },
        {
          "code": 400,
          "type": "PEER_ID_INVALID",
          "description": "The provided peer id is invalid"
        }
      ]
    },
    "messages.editInlineBotMessage": {
      "name": "messages.editInlineBotMessage",
      "description": [
        "Edit an inline bot message"
      ],
      "parameters": {
        "entities": "Message entities for styled text",
        "flags": "Flags, see TL conditional fields",
        "id": "Sent inline message ID",
        "media": "Media",
        "message": "Message",
        "no_webpage": "Disable webpage preview",
        "reply_markup": "Reply markup for inline keyboards"
      },
      "errors": [
        {
          "code": 400,
          "type": "MESSAGE_ID_INVALID",
          "description": "The provided message id is invalid"
        },
        {
          "code": 400,
          "type": "MESSAGE_NOT_MODIFIED",
          "description": "The message text has not changed"
        }
      ]
    },
    "messages.editMessage": {
      "name": "messages.editMessage",
      "description": [
        "Edit message"
      ],
      "parameters": {
        "entities": "Message entities for styled text",
        "flags": "Flags, see TL conditional fields",
        "id": "ID of the message to edit",
        "media": "New attached media",
        "message": "New message",
        "no_webpage": "Disable webpage preview",
        "peer": "Where was the message sent",
        "reply_markup": "Reply markup for inline keyboards",
        "schedule_date": "Scheduled message date for scheduled messages"
      },
      "errors": [
        {
          "code": 400,
          "type": "BUTTON_DATA_INVALID",
          "description": "The data of one or more of the buttons you provided is invalid"
        },
        {
          "code": 400,
          "type": "BUTTON_TYPE_INVALID",
          "description": "The type of one or more of the buttons you provided is invalid"
        },
        {
          "code": 400,
          "type": "BUTTON_URL_INVALID",
          "description": "Button URL invalid"
        },
        {
          "code": 400,
          "type": "CHANNEL_INVALID",
          "description": "The provided channel is invalid"
        },
        {
          "code": 400,
          "type": "CHANNEL_PRIVATE",
          "description": "You haven't joined this channel/supergroup"
        },
        {
          "code": 400,
          "type": "CHAT_ADMIN_REQUIRED",
          "description": "You must be an admin in this chat to do this"
        },
        {
          "code": 403,
          "type": "CHAT_WRITE_FORBIDDEN",
          "description": "You can't write in this chat"
        },
        {
          "code": 403,
          "type": "INLINE_BOT_REQUIRED",
          "description": "Only the inline bot can edit message"
        },
        {
          "code": 400,
          "type": "INPUT_USER_DEACTIVATED",
          "description": "The specified user was deleted"
        },
        {
          "code": 400,
          "type": "MEDIA_CAPTION_TOO_LONG",
          "description": "The caption is too long"
        },
        {
          "code": 400,
          "type": "MEDIA_PREV_INVALID",
          "description": "Previous media invalid"
        },
        {
          "code": 403,
          "type": "MESSAGE_AUTHOR_REQUIRED",
          "description": "Message author required"
        },
        {
          "code": 400,
          "type": "MESSAGE_EDIT_TIME_EXPIRED",
          "description": "You can't edit this message anymore, too much time has passed since its creation."
        },
        {
          "code": 400,
          "type": "MESSAGE_EMPTY",
          "description": "The provided message is empty"
        },
        {
          "code": 400,
          "type": "MESSAGE_ID_INVALID",
          "description": "The provided message id is invalid"
        },
        {
          "code": 400,
          "type": "MESSAGE_NOT_MODIFIED",
          "description": "The message text has not changed"
        },
        {
          "code": 400,
          "type": "MESSAGE_TOO_LONG",
          "description": "The provided message is too long"
        },
        {
          "code": 400,
          "type": "MSG_ID_INVALID",
          "description": "Invalid message ID provided"
        },
        {
          "code": 400,
          "type": "PEER_ID_INVALID",
          "description": "The provided peer id is invalid"
        },
        {
          "code": 400,
          "type": "REPLY_MARKUP_INVALID",
          "description": "The provided reply markup is invalid"
        },
        {
          "code": 400,
          "type": "SCHEDULE_DATE_INVALID",
          "description": "Invalid schedule date provided"
        },
        {
          "code": 400,
          "type": "USER_BANNED_IN_CHANNEL",
          "description": "You're banned from sending messages in supergroups/channels"
        }
      ]
    },
    "messages.exportChatInvite": {
      "name": "messages.exportChatInvite",
      "description": [
        "Export an invite link for a chat"
      ],
      "parameters": {
        "peer": "Chat"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHANNEL_PRIVATE",
          "description": "You haven't joined this channel/supergroup"
        },
        {
          "code": 400,
          "type": "CHAT_ADMIN_REQUIRED",
          "description": "You must be an admin in this chat to do this"
        },
        {
          "code": 400,
          "type": "CHAT_ID_INVALID",
          "description": "The provided chat id is invalid"
        },
        {
          "code": 403,
          "type": "CHAT_WRITE_FORBIDDEN",
          "description": "You can't write in this chat"
        },
        {
          "code": 400,
          "type": "PEER_ID_INVALID",
          "description": "The provided peer id is invalid"
        }
      ]
    },
    "messages.faveSticker": {
      "name": "messages.faveSticker",
      "description": [
        "Mark a sticker as favorite"
      ],
      "parameters": {
        "id": "Sticker to mark as favorite",
        "unfave": "Unfavorite"
      },
      "errors": [
        {
          "code": 400,
          "type": "STICKER_ID_INVALID",
          "description": "The provided sticker ID is invalid"
        }
      ]
    },
    "messages.forwardMessages": {
      "name": "messages.forwardMessages",
      "description": [
        "Forwards messages by their IDs."
      ],
      "parameters": {
        "background": "Whether to send the message in background",
        "flags": "Flags, see TL conditional fields",
        "from_peer": "Source of messages",
        "id": "IDs of messages",
        "random_id": "Random ID to prevent resending of messages",
        "schedule_date": "Scheduled message date for scheduled messages",
        "silent": "Whether to send messages silently (no notification will be triggered on the destination clients)",
        "to_peer": "Destination peer",
        "with_my_score": "When forwarding games, whether to include your score in the game"
      },
      "errors": [
        {
          "code": 400,
          "type": "BROADCAST_PUBLIC_VOTERS_FORBIDDEN",
          "description": "You can't forward polls with public voters"
        },
        {
          "code": 400,
          "type": "CHANNEL_INVALID",
          "description": "The provided channel is invalid"
        },
        {
          "code": 400,
          "type": "CHANNEL_PRIVATE",
          "description": "You haven't joined this channel/supergroup"
        },
        {
          "code": 400,
          "type": "CHAT_ADMIN_REQUIRED",
          "description": "You must be an admin in this chat to do this"
        },
        {
          "code": 400,
          "type": "CHAT_ID_INVALID",
          "description": "The provided chat id is invalid"
        },
        {
          "code": 400,
          "type": "CHAT_RESTRICTED",
          "description": "You can't send messages in this chat, you were restricted"
        },
        {
          "code": 403,
          "type": "CHAT_SEND_GIFS_FORBIDDEN",
          "description": "You can't send gifs in this chat"
        },
        {
          "code": 403,
          "type": "CHAT_SEND_MEDIA_FORBIDDEN",
          "description": "You can't send media in this chat"
        },
        {
          "code": 403,
          "type": "CHAT_SEND_POLL_FORBIDDEN",
          "description": "You can't send polls in this chat"
        },
        {
          "code": 403,
          "type": "CHAT_SEND_STICKERS_FORBIDDEN",
          "description": "You can't send stickers in this chat."
        },
        {
          "code": 403,
          "type": "CHAT_WRITE_FORBIDDEN",
          "description": "You can't write in this chat"
        },
        {
          "code": 400,
          "type": "GROUPED_MEDIA_INVALID",
          "description": "Invalid grouped media"
        },
        {
          "code": 400,
          "type": "INPUT_USER_DEACTIVATED",
          "description": "The specified user was deleted"
        },
        {
          "code": 400,
          "type": "MEDIA_EMPTY",
          "description": "The provided media object is invalid"
        },
        {
          "code": 400,
          "type": "MESSAGE_IDS_EMPTY",
          "description": "No message ids were provided"
        },
        {
          "code": 400,
          "type": "MESSAGE_ID_INVALID",
          "description": "The provided message id is invalid"
        },
        {
          "code": 400,
          "type": "MSG_ID_INVALID",
          "description": "Invalid message ID provided"
        },
        {
          "code": 420,
          "type": "P0NY_FLOODWAIT",
          "description": ""
        },
        {
          "code": 400,
          "type": "PEER_ID_INVALID",
          "description": "The provided peer id is invalid"
        },
        {
          "code": 400,
          "type": "RANDOM_ID_INVALID",
          "description": "A provided random ID is invalid"
        },
        {
          "code": 400,
          "type": "SCHEDULE_TOO_MUCH",
          "description": "There are too many scheduled messages"
        },
        {
          "code": 400,
          "type": "SLOWMODE_MULTI_MSGS_DISABLED",
          "description": "Slowmode is enabled, you cannot forward multiple messages to this group."
        },
        {
          "code": 420,
          "type": "SLOWMODE_WAIT_X",
          "description": "Slowmode is enabled in this chat: you must wait for the specified number of seconds before sending another message to the chat."
        },
        {
          "code": 400,
          "type": "USER_BANNED_IN_CHANNEL",
          "description": "You're banned from sending messages in supergroups/channels"
        },
        {
          "code": 400,
          "type": "USER_IS_BLOCKED",
          "description": "You were blocked by this user"
        },
        {
          "code": 400,
          "type": "USER_IS_BOT",
          "description": "Bots can't send messages to other bots"
        },
        {
          "code": 400,
          "type": "YOU_BLOCKED_USER",
          "description": "You blocked this user"
        }
      ]
    },
    "messages.getAllChats": {
      "name": "messages.getAllChats",
      "description": [
        "Get all chats, channels and supergroups"
      ],
      "parameters": {
        "except_ids": "Except these chats/channels/supergroups"
      }
    },
    "messages.getAllDrafts": {
      "name": "messages.getAllDrafts",
      "description": [
        "Save get all message drafts."
      ]
    },
    "messages.getAllStickers": {
      "name": "messages.getAllStickers",
      "description": [
        "Get all installed stickers"
      ],
      "parameters": {
        "hash": "Hash for pagination, for more info click here"
      }
    },
    "messages.getArchivedStickers": {
      "name": "messages.getArchivedStickers",
      "description": [
        "Get all archived stickers"
      ],
      "parameters": {
        "flags": "Flags, see TL conditional fields",
        "limit": "Maximum number of results to return, see pagination",
        "masks": "Get mask stickers",
        "offset_id": "Offsets for pagination, for more info click here"
      }
    },
    "messages.getAttachedStickers": {
      "name": "messages.getAttachedStickers",
      "description": [
        "Get stickers attached to a photo or video"
      ],
      "parameters": {
        "media": "Stickered media"
      }
    },
    "messages.getBotCallbackAnswer": {
      "name": "messages.getBotCallbackAnswer",
      "description": [
        "Press an inline callback button and get a callback answer from the bot"
      ],
      "parameters": {
        "data": "Callback data",
        "flags": "Flags, see TL conditional fields",
        "game": "Whether this is a \"play game\" button",
        "msg_id": "ID of the Message with the inline keyboard",
        "password": "For buttons requiring you to verify your identity with your 2FA password, the SRP payload generated using SRP.",
        "peer": "Where was the inline keyboard sent"
      },
      "errors": [
        {
          "code": 400,
          "type": "BOT_RESPONSE_TIMEOUT",
          "description": "A timeout occurred while fetching data from the bot"
        },
        {
          "code": 400,
          "type": "CHANNEL_INVALID",
          "description": "The provided channel is invalid"
        },
        {
          "code": 400,
          "type": "CHANNEL_PRIVATE",
          "description": "You haven't joined this channel/supergroup"
        },
        {
          "code": 400,
          "type": "DATA_INVALID",
          "description": "Encrypted data invalid"
        },
        {
          "code": 400,
          "type": "MESSAGE_ID_INVALID",
          "description": "The provided message id is invalid"
        },
        {
          "code": 400,
          "type": "PEER_ID_INVALID",
          "description": "The provided peer id is invalid"
        },
        {
          "code": -503,
          "type": "Timeout",
          "description": "Timeout while fetching data"
        }
      ]
    },
    "messages.getChats": {
      "name": "messages.getChats",
      "description": [
        "Returns chat basic info on their IDs."
      ],
      "parameters": {
        "id": "List of chat IDs"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHAT_ID_INVALID",
          "description": "The provided chat id is invalid"
        },
        {
          "code": 400,
          "type": "PEER_ID_INVALID",
          "description": "The provided peer id is invalid"
        }
      ]
    },
    "messages.getCommonChats": {
      "name": "messages.getCommonChats",
      "description": [
        "Get chats in common with a user"
      ],
      "parameters": {
        "limit": "Maximum number of results to return, see pagination",
        "max_id": "Maximum ID of chat to return (see pagination)",
        "user_id": "User ID"
      },
      "errors": [
        {
          "code": 400,
          "type": "MSG_ID_INVALID",
          "description": "Invalid message ID provided"
        },
        {
          "code": 400,
          "type": "USER_ID_INVALID",
          "description": "The provided user ID is invalid"
        }
      ]
    },
    "messages.getDhConfig": {
      "name": "messages.getDhConfig",
      "description": [
        "Returns configuration parameters for Diffie-Hellman key generation. Can also return a random sequence of bytes of required length."
      ],
      "parameters": {
        "random_length": "Length of the required random sequence",
        "version": "Value of the version parameter from messages.dhConfig, avialable at the client"
      },
      "errors": [
        {
          "code": 400,
          "type": "RANDOM_LENGTH_INVALID",
          "description": "Random length invalid"
        }
      ]
    },
    "messages.getDialogFilters": {
      "name": "messages.getDialogFilters",
      "description": [
        "Get folders"
      ]
    },
    "messages.getDialogUnreadMarks": {
      "name": "messages.getDialogUnreadMarks",
      "description": [
        "Get dialogs manually marked as unread"
      ]
    },
    "messages.getDialogs": {
      "name": "messages.getDialogs",
      "description": [
        "Returns the current user dialog list."
      ],
      "parameters": {
        "exclude_pinned": "Exclude pinned dialogs",
        "flags": "Flags, see TL conditional fields",
        "folder_id": "Peer folder ID, for more info click here",
        "hash": "Hash for pagination, for more info click here",
        "limit": "Number of list elements to be returned",
        "offset_date": "Offsets for pagination, for more info click here",
        "offset_id": "Offsets for pagination, for more info click here",
        "offset_peer": "Offset peer for pagination"
      },
      "errors": [
        {
          "code": 400,
          "type": "FOLDER_ID_INVALID",
          "description": "Invalid folder ID"
        },
        {
          "code": 400,
          "type": "INPUT_CONSTRUCTOR_INVALID",
          "description": "The provided constructor is invalid"
        },
        {
          "code": 400,
          "type": "OFFSET_PEER_ID_INVALID",
          "description": "The provided offset peer is invalid"
        }
      ]
    },
    "messages.getDiscussionMessage": {
      "name": "messages.getDiscussionMessage",
      "description": [
        "Get discussion message from the associated discussion group of a channel to show it on top of the comment section, without actually joining the group"
      ],
      "parameters": {
        "msg_id": "Message ID",
        "peer": "Channel ID"
      }
    },
    "messages.getDocumentByHash": {
      "name": "messages.getDocumentByHash",
      "description": [
        "Get a document by its SHA256 hash, mainly used for gifs"
      ],
      "parameters": {
        "mime_type": "Mime type",
        "sha256": "SHA256 of file",
        "size": "Size of the file in bytes"
      },
      "errors": [
        {
          "code": 400,
          "type": "SHA256_HASH_INVALID",
          "description": "The provided SHA256 hash is invalid"
        }
      ]
    },
    "messages.getEmojiKeywords": {
      "name": "messages.getEmojiKeywords",
      "description": [
        "Get localized emoji keywords"
      ],
      "parameters": {
        "lang_code": "Language code"
      }
    },
    "messages.getEmojiKeywordsDifference": {
      "name": "messages.getEmojiKeywordsDifference",
      "description": [
        "Get changed emoji keywords"
      ],
      "parameters": {
        "from_version": "Previous emoji keyword localization version",
        "lang_code": "Language code"
      }
    },
    "messages.getEmojiKeywordsLanguages": {
      "name": "messages.getEmojiKeywordsLanguages",
      "description": [
        "Get info about an emoji keyword localization"
      ],
      "parameters": {
        "lang_codes": "Language codes"
      }
    },
    "messages.getEmojiURL": {
      "name": "messages.getEmojiURL",
      "description": [
        "Returns an HTTP URL which can be used to automatically log in into translation platform and suggest new emoji replacements. The URL will be valid for 30 seconds after generation"
      ],
      "parameters": {
        "lang_code": "Language code for which the emoji replacements will be suggested"
      }
    },
    "messages.getFavedStickers": {
      "name": "messages.getFavedStickers",
      "description": [
        "Get faved stickers"
      ],
      "parameters": {
        "hash": "Hash for pagination, for more info click here"
      }
    },
    "messages.getFeaturedStickers": {
      "name": "messages.getFeaturedStickers",
      "description": [
        "Get featured stickers"
      ],
      "parameters": {
        "hash": "Hash for pagination, for more info click here"
      }
    },
    "messages.getFullChat": {
      "name": "messages.getFullChat",
      "description": [
        "Returns full chat info according to its ID."
      ],
      "parameters": {
        "chat_id": "Chat ID"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHAT_ID_INVALID",
          "description": "The provided chat id is invalid"
        },
        {
          "code": 400,
          "type": "PEER_ID_INVALID",
          "description": "The provided peer id is invalid"
        }
      ]
    },
    "messages.getGameHighScores": {
      "name": "messages.getGameHighScores",
      "description": [
        "Get highscores of a game"
      ],
      "parameters": {
        "id": "ID of message with game media attachment",
        "peer": "Where was the game sent",
        "user_id": "Get high scores made by a certain user"
      },
      "errors": [
        {
          "code": 400,
          "type": "MESSAGE_ID_INVALID",
          "description": "The provided message id is invalid"
        },
        {
          "code": 400,
          "type": "PEER_ID_INVALID",
          "description": "The provided peer id is invalid"
        },
        {
          "code": 400,
          "type": "USER_BOT_REQUIRED",
          "description": "This method can only be called by a bot"
        }
      ]
    },
    "messages.getHistory": {
      "name": "messages.getHistory",
      "description": [
        "Gets back the conversation history with one interlocutor / within a chat"
      ],
      "parameters": {
        "add_offset": "Number of list elements to be skipped, negative values are also accepted.",
        "hash": "Result hash",
        "limit": "Number of results to return",
        "max_id": "If a positive value was transferred, the method will return only messages with IDs less than max_id",
        "min_id": "If a positive value was transferred, the method will return only messages with IDs more than min_id",
        "offset_date": "Only return messages sent before the specified date",
        "offset_id": "Only return messages starting from the specified message ID",
        "peer": "Target peer"
      },
      "errors": [
        {
          "code": 401,
          "type": "AUTH_KEY_PERM_EMPTY",
          "description": "The temporary auth key must be binded to the permanent auth key to use these methods."
        },
        {
          "code": 400,
          "type": "CHANNEL_INVALID",
          "description": "The provided channel is invalid"
        },
        {
          "code": 400,
          "type": "CHANNEL_PRIVATE",
          "description": "You haven't joined this channel/supergroup"
        },
        {
          "code": 400,
          "type": "CHAT_ID_INVALID",
          "description": "The provided chat id is invalid"
        },
        {
          "code": 400,
          "type": "CONNECTION_DEVICE_MODEL_EMPTY",
          "description": "Device model empty"
        },
        {
          "code": 400,
          "type": "MSG_ID_INVALID",
          "description": "Invalid message ID provided"
        },
        {
          "code": 400,
          "type": "PEER_ID_INVALID",
          "description": "The provided peer id is invalid"
        }
      ]
    },
    "messages.getInlineBotResults": {
      "name": "messages.getInlineBotResults",
      "description": [
        "Query an inline bot"
      ],
      "parameters": {
        "bot": "The bot to query",
        "flags": "Flags, see TL conditional fields",
        "geo_point": "The geolocation, if requested",
        "offset": "The offset within the results, will be passed directly as-is to the bot.",
        "peer": "The currently opened chat",
        "query": "The query"
      },
      "errors": [
        {
          "code": 400,
          "type": "BOT_INLINE_DISABLED",
          "description": "This bot can't be used in inline mode"
        },
        {
          "code": 400,
          "type": "BOT_INVALID",
          "description": "This is not a valid bot"
        },
        {
          "code": 400,
          "type": "BOT_RESPONSE_TIMEOUT",
          "description": "A timeout occurred while fetching data from the bot"
        },
        {
          "code": 400,
          "type": "CHANNEL_PRIVATE",
          "description": "You haven't joined this channel/supergroup"
        },
        {
          "code": 400,
          "type": "INPUT_USER_DEACTIVATED",
          "description": "The specified user was deleted"
        },
        {
          "code": 400,
          "type": "MSG_ID_INVALID",
          "description": "Invalid message ID provided"
        },
        {
          "code": -503,
          "type": "Timeout",
          "description": "Timeout while fetching data"
        }
      ]
    },
    "messages.getInlineGameHighScores": {
      "name": "messages.getInlineGameHighScores",
      "description": [
        "Get highscores of a game sent using an inline bot"
      ],
      "parameters": {
        "id": "ID of inline message",
        "user_id": "Get high scores of a certain user"
      },
      "errors": [
        {
          "code": 400,
          "type": "MESSAGE_ID_INVALID",
          "description": "The provided message id is invalid"
        },
        {
          "code": 400,
          "type": "USER_BOT_REQUIRED",
          "description": "This method can only be called by a bot"
        }
      ]
    },
    "messages.getMaskStickers": {
      "name": "messages.getMaskStickers",
      "description": [
        "Get installed mask stickers"
      ],
      "parameters": {
        "hash": "Hash for pagination, for more info click here"
      }
    },
    "messages.getMessageEditData": {
      "name": "messages.getMessageEditData",
      "description": [
        "Find out if a media message's caption can be edited"
      ],
      "parameters": {
        "id": "ID of message",
        "peer": "Peer where the media was sent"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHAT_ADMIN_REQUIRED",
          "description": "You must be an admin in this chat to do this"
        },
        {
          "code": 403,
          "type": "MESSAGE_AUTHOR_REQUIRED",
          "description": "Message author required"
        },
        {
          "code": 400,
          "type": "MESSAGE_ID_INVALID",
          "description": "The provided message id is invalid"
        },
        {
          "code": 400,
          "type": "PEER_ID_INVALID",
          "description": "The provided peer id is invalid"
        }
      ]
    },
    "messages.getMessages": {
      "name": "messages.getMessages",
      "description": [
        "Returns the list of messages by their IDs."
      ],
      "parameters": {
        "id": "Message ID list"
      }
    },
    "messages.getMessagesViews": {
      "name": "messages.getMessagesViews",
      "description": [
        "Get and increase the view counter of a message sent or forwarded from a channel"
      ],
      "parameters": {
        "id": "ID of message",
        "increment": "Whether to mark the message as viewed and increment the view counter",
        "peer": "Peer where the message was found"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHANNEL_INVALID",
          "description": "The provided channel is invalid"
        },
        {
          "code": 400,
          "type": "CHANNEL_PRIVATE",
          "description": "You haven't joined this channel/supergroup"
        },
        {
          "code": 400,
          "type": "CHAT_ID_INVALID",
          "description": "The provided chat id is invalid"
        },
        {
          "code": 400,
          "type": "MSG_ID_INVALID",
          "description": "Invalid message ID provided"
        },
        {
          "code": 400,
          "type": "PEER_ID_INVALID",
          "description": "The provided peer id is invalid"
        }
      ]
    },
    "messages.getOldFeaturedStickers": {
      "name": "messages.getOldFeaturedStickers",
      "description": [
        "Method for fetching previously featured stickers"
      ],
      "parameters": {
        "hash": "Hash for pagination, for more info click here",
        "limit": "Maximum number of results to return, see pagination",
        "offset": "Offset"
      }
    },
    "messages.getOnlines": {
      "name": "messages.getOnlines",
      "description": [
        "Get count of online users in a chat"
      ],
      "parameters": {
        "peer": "The chat"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHANNEL_PRIVATE",
          "description": "You haven't joined this channel/supergroup"
        },
        {
          "code": 400,
          "type": "PEER_ID_INVALID",
          "description": "The provided peer id is invalid"
        }
      ]
    },
    "messages.getPeerDialogs": {
      "name": "messages.getPeerDialogs",
      "description": [
        "Get dialog info of specified peers"
      ],
      "parameters": {
        "peers": "Peers"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHANNEL_INVALID",
          "description": "The provided channel is invalid"
        },
        {
          "code": 400,
          "type": "CHANNEL_PRIVATE",
          "description": "You haven't joined this channel/supergroup"
        },
        {
          "code": 400,
          "type": "CONNECTION_DEVICE_MODEL_EMPTY",
          "description": "Device model empty"
        },
        {
          "code": 400,
          "type": "MSG_ID_INVALID",
          "description": "Invalid message ID provided"
        },
        {
          "code": 400,
          "type": "PEER_ID_INVALID",
          "description": "The provided peer id is invalid"
        }
      ]
    },
    "messages.getPeerSettings": {
      "name": "messages.getPeerSettings",
      "description": [
        "Get peer settings"
      ],
      "parameters": {
        "peer": "The peer"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHANNEL_INVALID",
          "description": "The provided channel is invalid"
        },
        {
          "code": 400,
          "type": "PEER_ID_INVALID",
          "description": "The provided peer id is invalid"
        }
      ]
    },
    "messages.getPinnedDialogs": {
      "name": "messages.getPinnedDialogs",
      "description": [
        "Get pinned dialogs"
      ],
      "parameters": {
        "folder_id": "Peer folder ID, for more info click here"
      },
      "errors": [
        {
          "code": 400,
          "type": "FOLDER_ID_INVALID",
          "description": "Invalid folder ID"
        }
      ]
    },
    "messages.getPollResults": {
      "name": "messages.getPollResults",
      "description": [
        "Get poll results"
      ],
      "parameters": {
        "msg_id": "Message ID of poll message",
        "peer": "Peer where the poll was found"
      },
      "errors": [
        {
          "code": 400,
          "type": "MESSAGE_ID_INVALID",
          "description": "The provided message id is invalid"
        }
      ]
    },
    "messages.getPollVotes": {
      "name": "messages.getPollVotes",
      "description": [
        "Get poll results for non-anonymous polls"
      ],
      "parameters": {
        "flags": "Flags, see TL conditional fields",
        "id": "Message ID",
        "limit": "Number of results to return",
        "offset": "Offset for results, taken from the next_offset field of messages.votesList, initially an empty string. Note: if no more results are available, the method call will return an empty next_offset; thus, avoid providing the next_offset returned in messages.votesList if it is empty, to avoid an infinite loop.",
        "option": "Get only results for the specified poll option",
        "peer": "Chat where the poll was sent"
      },
      "errors": [
        {
          "code": 403,
          "type": "BROADCAST_FORBIDDEN",
          "description": ""
        },
        {
          "code": 400,
          "type": "MSG_ID_INVALID",
          "description": "Invalid message ID provided"
        },
        {
          "code": 403,
          "type": "POLL_VOTE_REQUIRED",
          "description": "Cast a vote in the poll before calling this method"
        }
      ]
    },
    "messages.getRecentLocations": {
      "name": "messages.getRecentLocations",
      "description": [
        "Get live location history of a certain user"
      ],
      "parameters": {
        "hash": "Hash for pagination, for more info click here",
        "limit": "Maximum number of results to return, see pagination",
        "peer": "User"
      }
    },
    "messages.getRecentStickers": {
      "name": "messages.getRecentStickers",
      "description": [
        "Get recent stickers"
      ],
      "parameters": {
        "attached": "Get stickers recently attached to photo or video files",
        "flags": "Flags, see TL conditional fields",
        "hash": "Hash for pagination, for more info click here"
      }
    },
    "messages.getReplies": {
      "name": "messages.getReplies",
      "description": [
        "Get messages in a reply thread"
      ],
      "parameters": {
        "add_offset": "Offsets for pagination, for more info click here",
        "hash": "Hash for pagination, for more info click here",
        "limit": "Maximum number of results to return, see pagination",
        "max_id": "If a positive value was transferred, the method will return only messages with ID smaller than max_id",
        "min_id": "If a positive value was transferred, the method will return only messages with ID bigger than min_id",
        "msg_id": "Message ID",
        "offset_date": "Offsets for pagination, for more info click here",
        "offset_id": "Offsets for pagination, for more info click here",
        "peer": "Peer"
      }
    },
    "messages.getSavedGifs": {
      "name": "messages.getSavedGifs",
      "description": [
        "Get saved GIFs"
      ],
      "parameters": {
        "hash": "Hash for pagination, for more info click here"
      }
    },
    "messages.getScheduledHistory": {
      "name": "messages.getScheduledHistory",
      "description": [
        "Get scheduled messages"
      ],
      "parameters": {
        "hash": "Hash for pagination, for more info click here",
        "peer": "Peer"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHAT_ADMIN_REQUIRED",
          "description": "You must be an admin in this chat to do this"
        },
        {
          "code": 400,
          "type": "PEER_ID_INVALID",
          "description": "The provided peer id is invalid"
        }
      ]
    },
    "messages.getScheduledMessages": {
      "name": "messages.getScheduledMessages",
      "description": [
        "Get scheduled messages"
      ],
      "parameters": {
        "id": "IDs of scheduled messages",
        "peer": "Peer"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHAT_ADMIN_REQUIRED",
          "description": "You must be an admin in this chat to do this"
        },
        {
          "code": 400,
          "type": "PEER_ID_INVALID",
          "description": "The provided peer id is invalid"
        }
      ]
    },
    "messages.getSearchCounters": {
      "name": "messages.getSearchCounters",
      "description": [
        "Get the number of results that would be found by a messages.search call with the same parameters"
      ],
      "parameters": {
        "filters": "Search filters",
        "peer": "Peer where to search"
      }
    },
    "messages.getSplitRanges": {
      "name": "messages.getSplitRanges",
      "description": [
        "Get message ranges for saving the user's chat history"
      ]
    },
    "messages.getStatsURL": {
      "name": "messages.getStatsURL",
      "description": [
        "Returns URL with the chat statistics. Currently this method can be used only for channels"
      ],
      "parameters": {
        "dark": "Pass true if a URL with the dark theme must be returned",
        "flags": "Flags, see TL conditional fields",
        "params": "Parameters from tg://statsrefresh?params=****** link",
        "peer": "Chat identifier"
      },
      "errors": [
        {
          "code": 400,
          "type": "PEER_ID_INVALID",
          "description": "The provided peer id is invalid"
        }
      ]
    },
    "messages.getStickerSet": {
      "name": "messages.getStickerSet",
      "description": [
        "Get info about a stickerset"
      ],
      "parameters": {
        "stickerset": "Stickerset"
      },
      "errors": [
        {
          "code": 400,
          "type": "STICKERSET_INVALID",
          "description": "The provided sticker set is invalid"
        }
      ]
    },
    "messages.getStickers": {
      "name": "messages.getStickers",
      "description": [
        "Get stickers by emoji"
      ],
      "parameters": {
        "emoticon": "The emoji",
        "hash": "Hash for pagination, for more info click here"
      }
    },
    "messages.getSuggestedDialogFilters": {
      "name": "messages.getSuggestedDialogFilters",
      "description": [
        "Get suggested folders"
      ]
    },
    "messages.getUnreadMentions": {
      "name": "messages.getUnreadMentions",
      "description": [
        "Get unread messages where we were mentioned"
      ],
      "parameters": {
        "add_offset": "Offsets for pagination, for more info click here",
        "limit": "Maximum number of results to return, see pagination",
        "max_id": "Maximum message ID to return, see pagination",
        "min_id": "Minimum message ID to return, see pagination",
        "offset_id": "Offsets for pagination, for more info click here",
        "peer": "Peer where to look for mentions"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHANNEL_INVALID",
          "description": "The provided channel is invalid"
        },
        {
          "code": 400,
          "type": "CHANNEL_PRIVATE",
          "description": "You haven't joined this channel/supergroup"
        },
        {
          "code": 400,
          "type": "PEER_ID_INVALID",
          "description": "The provided peer id is invalid"
        }
      ]
    },
    "messages.getWebPage": {
      "name": "messages.getWebPage",
      "description": [
        "Get instant view page"
      ],
      "parameters": {
        "hash": "Hash for pagination, for more info click here",
        "url": "URL of IV page to fetch"
      },
      "errors": [
        {
          "code": 400,
          "type": "WC_CONVERT_URL_INVALID",
          "description": "WC convert URL invalid"
        }
      ]
    },
    "messages.getWebPagePreview": {
      "name": "messages.getWebPagePreview",
      "description": [
        "Get preview of webpage"
      ],
      "parameters": {
        "entities": "Message entities for styled text",
        "flags": "Flags, see TL conditional fields",
        "message": "Message from which to extract the preview"
      },
      "errors": [
        {
          "code": 400,
          "type": "MESSAGE_EMPTY",
          "description": "The provided message is empty"
        }
      ]
    },
    "messages.hidePeerSettingsBar": {
      "name": "messages.hidePeerSettingsBar",
      "description": [
        "Should be called after the user hides the report spam/add as contact bar of a new chat, effectively prevents the user from executing the actions specified in the peer's settings."
      ],
      "parameters": {
        "peer": "Peer"
      }
    },
    "messages.importChatInvite": {
      "name": "messages.importChatInvite",
      "description": [
        "Import a chat invite and join a private chat/supergroup/channel"
      ],
      "parameters": {
        "hash": "hash from t.me/joinchat/hash"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHANNELS_TOO_MUCH",
          "description": "You have joined too many channels/supergroups"
        },
        {
          "code": 400,
          "type": "CHANNEL_INVALID",
          "description": "The provided channel is invalid"
        },
        {
          "code": 400,
          "type": "CHANNEL_PRIVATE",
          "description": "You haven't joined this channel/supergroup"
        },
        {
          "code": 400,
          "type": "INVITE_HASH_EMPTY",
          "description": "The invite hash is empty"
        },
        {
          "code": 400,
          "type": "INVITE_HASH_EXPIRED",
          "description": "The invite link has expired"
        },
        {
          "code": 400,
          "type": "INVITE_HASH_INVALID",
          "description": "The invite hash is invalid"
        },
        {
          "code": 400,
          "type": "MSG_ID_INVALID",
          "description": "Invalid message ID provided"
        },
        {
          "code": 400,
          "type": "PEER_ID_INVALID",
          "description": "The provided peer id is invalid"
        },
        {
          "code": 400,
          "type": "USERS_TOO_MUCH",
          "description": "The maximum number of users has been exceeded (to create a chat, for example)"
        },
        {
          "code": 400,
          "type": "USER_ALREADY_PARTICIPANT",
          "description": "The user is already in the group"
        },
        {
          "code": 400,
          "type": "USER_CHANNELS_TOO_MUCH",
          "description": "One of the users you tried to add is already in too many channels/supergroups"
        }
      ]
    },
    "messages.installStickerSet": {
      "name": "messages.installStickerSet",
      "description": [
        "Install a stickerset"
      ],
      "parameters": {
        "archived": "Whether to archive stickerset",
        "stickerset": "Stickerset to install"
      },
      "errors": [
        {
          "code": 400,
          "type": "STICKERSET_INVALID",
          "description": "The provided sticker set is invalid"
        }
      ]
    },
    "messages.markDialogUnread": {
      "name": "messages.markDialogUnread",
      "description": [
        "Manually mark dialog as unread"
      ],
      "parameters": {
        "flags": "Flags, see TL conditional fields",
        "peer": "Dialog",
        "unread": "Mark as unread/read"
      }
    },
    "messages.migrateChat": {
      "name": "messages.migrateChat",
      "description": [
        "Turn a legacy group into a supergroup"
      ],
      "parameters": {
        "chat_id": "Legacy group to migrate"
      },
      "errors": [
        {
          "code": 403,
          "type": "CHAT_ADMIN_REQUIRED",
          "description": "You must be an admin in this chat to do this"
        },
        {
          "code": 400,
          "type": "CHAT_ID_INVALID",
          "description": "The provided chat id is invalid"
        },
        {
          "code": 400,
          "type": "PEER_ID_INVALID",
          "description": "The provided peer id is invalid"
        }
      ]
    },
    "messages.readDiscussion": {
      "name": "messages.readDiscussion",
      "description": [
        "Mark a thread as read"
      ],
      "parameters": {
        "msg_id": "ID of message that started the thread",
        "peer": "Group ID",
        "read_max_id": "ID up to which thread messages were read"
      }
    },
    "messages.readEncryptedHistory": {
      "name": "messages.readEncryptedHistory",
      "description": [
        "Marks message history within a secret chat as read."
      ],
      "parameters": {
        "max_date": "Maximum date value for received messages in history",
        "peer": "Secret chat ID"
      },
      "errors": [
        {
          "code": 400,
          "type": "MSG_WAIT_FAILED",
          "description": "A waiting call returned an error"
        }
      ]
    },
    "messages.readFeaturedStickers": {
      "name": "messages.readFeaturedStickers",
      "description": [
        "Mark new featured stickers as read"
      ],
      "parameters": {
        "id": "IDs of stickersets to mark as read"
      }
    },
    "messages.readHistory": {
      "name": "messages.readHistory",
      "description": [
        "Marks message history as read."
      ],
      "parameters": {
        "max_id": "If a positive value is passed, only messages with identifiers less or equal than the given one will be read",
        "peer": "Target user or group"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHAT_ID_INVALID",
          "description": "The provided chat id is invalid"
        },
        {
          "code": 400,
          "type": "MSG_ID_INVALID",
          "description": "Invalid message ID provided"
        },
        {
          "code": 400,
          "type": "PEER_ID_INVALID",
          "description": "The provided peer id is invalid"
        }
      ]
    },
    "messages.readMentions": {
      "name": "messages.readMentions",
      "description": [
        "Mark mentions as read"
      ],
      "parameters": {
        "peer": "Dialog"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHANNEL_INVALID",
          "description": "The provided channel is invalid"
        },
        {
          "code": 400,
          "type": "CHANNEL_PRIVATE",
          "description": "You haven't joined this channel/supergroup"
        },
        {
          "code": 400,
          "type": "MSG_ID_INVALID",
          "description": "Invalid message ID provided"
        },
        {
          "code": 400,
          "type": "PEER_ID_INVALID",
          "description": "The provided peer id is invalid"
        }
      ]
    },
    "messages.readMessageContents": {
      "name": "messages.readMessageContents",
      "description": [
        "Notifies the sender about the recipient having listened a voice message or watched a video."
      ],
      "parameters": {
        "id": "Message ID list"
      }
    },
    "messages.receivedMessages": {
      "name": "messages.receivedMessages",
      "description": [
        "Confirms receipt of messages by a client, cancels PUSH-notification sending."
      ],
      "parameters": {
        "max_id": "Maximum message ID available in a client."
      }
    },
    "messages.receivedQueue": {
      "name": "messages.receivedQueue",
      "description": [
        "Confirms receipt of messages in a secret chat by client, cancels push notifications."
      ],
      "parameters": {
        "max_qts": "Maximum qts value available at the client"
      },
      "errors": [
        {
          "code": 400,
          "type": "MSG_WAIT_FAILED",
          "description": "A waiting call returned an error"
        }
      ]
    },
    "messages.reorderPinnedDialogs": {
      "name": "messages.reorderPinnedDialogs",
      "description": [
        "Reorder pinned dialogs"
      ],
      "parameters": {
        "flags": "Flags, see TL conditional fields",
        "folder_id": "Peer folder ID, for more info click here",
        "force": "If set, dialogs pinned server-side but not present in the order field will be unpinned.",
        "order": "New dialog order"
      },
      "errors": [
        {
          "code": 400,
          "type": "PEER_ID_INVALID",
          "description": "The provided peer id is invalid"
        }
      ]
    },
    "messages.reorderStickerSets": {
      "name": "messages.reorderStickerSets",
      "description": [
        "Reorder installed stickersets"
      ],
      "parameters": {
        "flags": "Flags, see TL conditional fields",
        "masks": "Reorder mask stickersets",
        "order": "New stickerset order by stickerset IDs"
      }
    },
    "messages.report": {
      "name": "messages.report",
      "description": [
        "Report a message in a chat for violation of telegram's Terms of Service"
      ],
      "parameters": {
        "id": "IDs of messages to report",
        "peer": "Peer",
        "reason": "Why are these messages being reported"
      },
      "errors": [
        {
          "code": 400,
          "type": "PEER_ID_INVALID",
          "description": "The provided peer id is invalid"
        }
      ]
    },
    "messages.reportEncryptedSpam": {
      "name": "messages.reportEncryptedSpam",
      "description": [
        "Report a secret chat for spam"
      ],
      "parameters": {
        "peer": "The secret chat to report"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHAT_ID_INVALID",
          "description": "The provided chat id is invalid"
        }
      ]
    },
    "messages.reportSpam": {
      "name": "messages.reportSpam",
      "description": [
        "Report a new incoming chat for spam, if the peer settings of the chat allow us to do that"
      ],
      "parameters": {
        "peer": "Peer to report"
      },
      "errors": [
        {
          "code": 400,
          "type": "MSG_ID_INVALID",
          "description": "Invalid message ID provided"
        },
        {
          "code": 400,
          "type": "PEER_ID_INVALID",
          "description": "The provided peer id is invalid"
        }
      ]
    },
    "messages.requestEncryption": {
      "name": "messages.requestEncryption",
      "description": [
        "Sends a request to start a secret chat to the user."
      ],
      "parameters": {
        "g_a": "A = g ^ a mod p, see Wikipedia",
        "random_id": "Unique client request ID required to prevent resending. This also doubles as the chat ID.",
        "user_id": "User ID"
      },
      "errors": [
        {
          "code": 400,
          "type": "DH_G_A_INVALID",
          "description": "g_a invalid"
        },
        {
          "code": 400,
          "type": "USER_ID_INVALID",
          "description": "The provided user ID is invalid"
        }
      ]
    },
    "messages.requestUrlAuth": {
      "name": "messages.requestUrlAuth",
      "description": [
        "Get more info about a Seamless Telegram Login authorization request, for more info click here "
      ],
      "parameters": {
        "button_id": "The ID of the button with the authorization request",
        "msg_id": "The message",
        "peer": "Peer where the message is located"
      }
    },
    "messages.saveDraft": {
      "name": "messages.saveDraft",
      "description": [
        "Save a message draft associated to a chat."
      ],
      "parameters": {
        "entities": "Message entities for styled text",
        "flags": "Flags, see TL conditional fields",
        "message": "The draft",
        "no_webpage": "Disable generation of the webpage preview",
        "peer": "Destination of the message that should be sent",
        "reply_to_msg_id": "Message ID the message should reply to"
      },
      "errors": [
        {
          "code": 400,
          "type": "PEER_ID_INVALID",
          "description": "The provided peer id is invalid"
        }
      ]
    },
    "messages.saveGif": {
      "name": "messages.saveGif",
      "description": [
        "Add GIF to saved gifs list"
      ],
      "parameters": {
        "id": "GIF to save",
        "unsave": "Whether to remove GIF from saved gifs list"
      },
      "errors": [
        {
          "code": 400,
          "type": "GIF_ID_INVALID",
          "description": "The provided GIF ID is invalid"
        }
      ]
    },
    "messages.saveRecentSticker": {
      "name": "messages.saveRecentSticker",
      "description": [
        "Add/remove sticker from recent stickers list"
      ],
      "parameters": {
        "attached": "Whether to add/remove stickers recently attached to photo or video files",
        "flags": "Flags, see TL conditional fields",
        "id": "Sticker",
        "unsave": "Whether to save or unsave the sticker"
      },
      "errors": [
        {
          "code": 400,
          "type": "STICKER_ID_INVALID",
          "description": "The provided sticker ID is invalid"
        }
      ]
    },
    "messages.search": {
      "name": "messages.search",
      "description": [
        "Gets back found messages"
      ],
      "parameters": {
        "add_offset": "Additional offset",
        "filter": "Filter to return only specified message types",
        "flags": "Flags, see TL conditional fields",
        "from_id": "Only return messages sent by the specified user ID",
        "hash": "Hash",
        "limit": "Number of results to return",
        "max_date": "If a positive value was transferred, only messages with a sending date smaller than the transferred one will be returned",
        "max_id": "Maximum message ID to return",
        "min_date": "If a positive value was transferred, only messages with a sending date bigger than the transferred one will be returned",
        "min_id": "Minimum message ID to return",
        "offset_id": "Only return messages starting from the specified message ID",
        "peer": "User or chat, histories with which are searched, or (inputPeerEmpty) constructor for global search",
        "q": "Text search request",
        "top_msg_id": "Thread ID"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHANNEL_INVALID",
          "description": "The provided channel is invalid"
        },
        {
          "code": 400,
          "type": "CHANNEL_PRIVATE",
          "description": "You haven't joined this channel/supergroup"
        },
        {
          "code": 400,
          "type": "CHAT_ADMIN_REQUIRED",
          "description": "You must be an admin in this chat to do this"
        },
        {
          "code": 400,
          "type": "INPUT_CONSTRUCTOR_INVALID",
          "description": "The provided constructor is invalid"
        },
        {
          "code": 400,
          "type": "INPUT_USER_DEACTIVATED",
          "description": "The specified user was deleted"
        },
        {
          "code": 400,
          "type": "MSG_ID_INVALID",
          "description": "Invalid message ID provided"
        },
        {
          "code": 400,
          "type": "PEER_ID_INVALID",
          "description": "The provided peer id is invalid"
        },
        {
          "code": 400,
          "type": "PEER_ID_NOT_SUPPORTED",
          "description": "The provided peer ID is not supported"
        },
        {
          "code": 400,
          "type": "SEARCH_QUERY_EMPTY",
          "description": "The search query is empty"
        },
        {
          "code": 400,
          "type": "USER_ID_INVALID",
          "description": "The provided user ID is invalid"
        }
      ]
    },
    "messages.searchGlobal": {
      "name": "messages.searchGlobal",
      "description": [
        "Search for messages and peers globally"
      ],
      "parameters": {
        "filter": "Global search filter",
        "flags": "Flags, see TL conditional fields",
        "folder_id": "Peer folder ID, for more info click here",
        "limit": "Offsets for pagination, for more info click here",
        "max_date": "If a positive value was transferred, the method will return only messages with date smaller than max_date",
        "min_date": "If a positive value was specified, the method will return only messages with date bigger than min_date",
        "offset_id": "Offsets for pagination, for more info click here",
        "offset_peer": "Offsets for pagination, for more info click here",
        "offset_rate": "Initially 0, then set to the next_rate parameter of messages.messagesSlice",
        "q": "Query"
      },
      "errors": [
        {
          "code": 400,
          "type": "FOLDER_ID_INVALID",
          "description": "Invalid folder ID"
        },
        {
          "code": 400,
          "type": "SEARCH_QUERY_EMPTY",
          "description": "The search query is empty"
        }
      ]
    },
    "messages.searchStickerSets": {
      "name": "messages.searchStickerSets",
      "description": [
        "Search for stickersets"
      ],
      "parameters": {
        "exclude_featured": "Exclude featured stickersets from results",
        "flags": "Flags, see TL conditional fields",
        "hash": "Hash for pagination, for more info click here",
        "q": "Query string"
      }
    },
    "messages.sendEncrypted": {
      "name": "messages.sendEncrypted",
      "description": [
        "Sends a text message to a secret chat."
      ],
      "parameters": {
        "data": "TL-serialization of DecryptedMessage type, encrypted with a key that was created during chat initialization",
        "flags": "Flags, see TL conditional fields",
        "peer": "Secret chat ID",
        "random_id": "Unique client message ID, necessary to avoid message resending",
        "silent": "Send encrypted message without a notification"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHAT_ID_INVALID",
          "description": "The provided chat id is invalid"
        },
        {
          "code": 400,
          "type": "DATA_INVALID",
          "description": "Encrypted data invalid"
        },
        {
          "code": 400,
          "type": "ENCRYPTION_DECLINED",
          "description": "The secret chat was declined"
        },
        {
          "code": 400,
          "type": "MSG_WAIT_FAILED",
          "description": "A waiting call returned an error"
        }
      ]
    },
    "messages.sendEncryptedFile": {
      "name": "messages.sendEncryptedFile",
      "description": [
        "Sends a message with a file attachment to a secret chat"
      ],
      "parameters": {
        "data": "TL-serialization of DecryptedMessage type, encrypted with a key generated during chat initialization",
        "file": "File attachment for the secret chat",
        "flags": "Flags, see TL conditional fields",
        "peer": "Secret chat ID",
        "random_id": "Unique client message ID necessary to prevent message resending",
        "silent": "Whether to send the file without triggering a notification"
      },
      "errors": [
        {
          "code": 400,
          "type": "DATA_TOO_LONG",
          "description": "Data too long"
        },
        {
          "code": 400,
          "type": "ENCRYPTION_DECLINED",
          "description": "The secret chat was declined"
        },
        {
          "code": 400,
          "type": "MD5_CHECKSUM_INVALID",
          "description": "The MD5 checksums do not match"
        },
        {
          "code": 400,
          "type": "MSG_WAIT_FAILED",
          "description": "A waiting call returned an error"
        }
      ]
    },
    "messages.sendEncryptedService": {
      "name": "messages.sendEncryptedService",
      "description": [
        "Sends a service message to a secret chat."
      ],
      "parameters": {
        "data": "TL-serialization of  DecryptedMessage type, encrypted with a key generated during chat initialization",
        "peer": "Secret chat ID",
        "random_id": "Unique client message ID required to prevent message resending"
      },
      "errors": [
        {
          "code": 400,
          "type": "DATA_INVALID",
          "description": "Encrypted data invalid"
        },
        {
          "code": 400,
          "type": "ENCRYPTION_DECLINED",
          "description": "The secret chat was declined"
        },
        {
          "code": 400,
          "type": "ENCRYPTION_ID_INVALID",
          "description": "The provided secret chat ID is invalid"
        },
        {
          "code": 400,
          "type": "MSG_WAIT_FAILED",
          "description": "A waiting call returned an error"
        },
        {
          "code": 403,
          "type": "USER_IS_BLOCKED",
          "description": "You were blocked by this user"
        }
      ]
    },
    "messages.sendInlineBotResult": {
      "name": "messages.sendInlineBotResult",
      "description": [
        "Send a result obtained using messages.getInlineBotResults."
      ],
      "parameters": {
        "background": "Whether to send the message in background",
        "clear_draft": "Whether to clear the draft",
        "flags": "Flags, see TL conditional fields",
        "hide_via": "Whether to hide the via @botname in the resulting message (only for bot usernames encountered in the config)",
        "id": "Result ID from messages.getInlineBotResults",
        "peer": "Destination",
        "query_id": "Query ID from messages.getInlineBotResults",
        "random_id": "Random ID to avoid resending the same query",
        "reply_to_msg_id": "ID of the message this message should reply to",
        "schedule_date": "Scheduled message date for scheduled messages",
        "silent": "Whether to send the message silently (no notification will be triggered on the other client)"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHANNEL_INVALID",
          "description": "The provided channel is invalid"
        },
        {
          "code": 400,
          "type": "CHANNEL_PRIVATE",
          "description": "You haven't joined this channel/supergroup"
        },
        {
          "code": 400,
          "type": "CHAT_ADMIN_REQUIRED",
          "description": "You must be an admin in this chat to do this"
        },
        {
          "code": 400,
          "type": "CHAT_RESTRICTED",
          "description": "You can't send messages in this chat, you were restricted"
        },
        {
          "code": 403,
          "type": "CHAT_SEND_GIFS_FORBIDDEN",
          "description": "You can't send gifs in this chat"
        },
        {
          "code": 403,
          "type": "CHAT_SEND_INLINE_FORBIDDEN",
          "description": "You can't send inline messages in this group"
        },
        {
          "code": 403,
          "type": "CHAT_SEND_MEDIA_FORBIDDEN",
          "description": "You can't send media in this chat"
        },
        {
          "code": 403,
          "type": "CHAT_SEND_STICKERS_FORBIDDEN",
          "description": "You can't send stickers in this chat."
        },
        {
          "code": 403,
          "type": "CHAT_WRITE_FORBIDDEN",
          "description": "You can't write in this chat"
        },
        {
          "code": 400,
          "type": "INLINE_RESULT_EXPIRED",
          "description": "The inline query expired"
        },
        {
          "code": 400,
          "type": "INPUT_USER_DEACTIVATED",
          "description": "The specified user was deleted"
        },
        {
          "code": 400,
          "type": "MEDIA_EMPTY",
          "description": "The provided media object is invalid"
        },
        {
          "code": 400,
          "type": "MSG_ID_INVALID",
          "description": "Invalid message ID provided"
        },
        {
          "code": 400,
          "type": "PEER_ID_INVALID",
          "description": "The provided peer id is invalid"
        },
        {
          "code": 400,
          "type": "QUERY_ID_EMPTY",
          "description": "The query ID is empty"
        },
        {
          "code": 400,
          "type": "RESULT_ID_EMPTY",
          "description": "Result ID empty"
        },
        {
          "code": 420,
          "type": "SLOWMODE_WAIT_X",
          "description": "Slowmode is enabled in this chat: you must wait for the specified number of seconds before sending another message to the chat."
        },
        {
          "code": 400,
          "type": "USER_BANNED_IN_CHANNEL",
          "description": "You're banned from sending messages in supergroups/channels"
        },
        {
          "code": 400,
          "type": "WEBPAGE_CURL_FAILED",
          "description": "Failure while fetching the webpage with cURL"
        },
        {
          "code": 400,
          "type": "WEBPAGE_MEDIA_EMPTY",
          "description": "Webpage media empty"
        },
        {
          "code": 400,
          "type": "YOU_BLOCKED_USER",
          "description": "You blocked this user"
        }
      ]
    },
    "messages.sendMedia": {
      "name": "messages.sendMedia",
      "description": [
        "Send a media"
      ],
      "parameters": {
        "background": "Send message in background",
        "clear_draft": "Clear the draft",
        "entities": "Message entities for styled text",
        "flags": "Flags, see TL conditional fields",
        "media": "Attached media",
        "message": "Caption",
        "peer": "Destination",
        "random_id": "Random ID to avoid resending the same message",
        "reply_markup": "Reply markup for bot keyboards",
        "reply_to_msg_id": "Message ID to which this message should reply to",
        "schedule_date": "Scheduled message date for scheduled messages",
        "silent": "Send message silently (no notification should be triggered)"
      },
      "errors": [
        {
          "code": 400,
          "type": "BROADCAST_PUBLIC_VOTERS_FORBIDDEN",
          "description": "You can't forward polls with public voters"
        },
        {
          "code": 400,
          "type": "BUTTON_DATA_INVALID",
          "description": "The data of one or more of the buttons you provided is invalid"
        },
        {
          "code": 400,
          "type": "BUTTON_TYPE_INVALID",
          "description": "The type of one or more of the buttons you provided is invalid"
        },
        {
          "code": 400,
          "type": "BUTTON_URL_INVALID",
          "description": "Button URL invalid"
        },
        {
          "code": 400,
          "type": "CHANNEL_INVALID",
          "description": "The provided channel is invalid"
        },
        {
          "code": 400,
          "type": "CHANNEL_PRIVATE",
          "description": "You haven't joined this channel/supergroup"
        },
        {
          "code": 400,
          "type": "CHAT_ADMIN_REQUIRED",
          "description": "You must be an admin in this chat to do this"
        },
        {
          "code": 400,
          "type": "CHAT_RESTRICTED",
          "description": "You can't send messages in this chat, you were restricted"
        },
        {
          "code": 403,
          "type": "CHAT_SEND_GIFS_FORBIDDEN",
          "description": "You can't send gifs in this chat"
        },
        {
          "code": 403,
          "type": "CHAT_SEND_MEDIA_FORBIDDEN",
          "description": "You can't send media in this chat"
        },
        {
          "code": 403,
          "type": "CHAT_SEND_STICKERS_FORBIDDEN",
          "description": "You can't send stickers in this chat."
        },
        {
          "code": 403,
          "type": "CHAT_WRITE_FORBIDDEN",
          "description": "You can't write in this chat"
        },
        {
          "code": 400,
          "type": "EXTERNAL_URL_INVALID",
          "description": "External URL invalid"
        },
        {
          "code": 400,
          "type": "FILE_PARTS_INVALID",
          "description": "The number of file parts is invalid"
        },
        {
          "code": 400,
          "type": "FILE_PART_LENGTH_INVALID",
          "description": "The length of a file part is invalid"
        },
        {
          "code": 400,
          "type": "IMAGE_PROCESS_FAILED",
          "description": "Failure while processing image"
        },
        {
          "code": 400,
          "type": "INPUT_USER_DEACTIVATED",
          "description": "The specified user was deleted"
        },
        {
          "code": 400,
          "type": "MD5_CHECKSUM_INVALID",
          "description": "The MD5 checksums do not match"
        },
        {
          "code": 400,
          "type": "MEDIA_CAPTION_TOO_LONG",
          "description": "The caption is too long"
        },
        {
          "code": 400,
          "type": "MEDIA_EMPTY",
          "description": "The provided media object is invalid"
        },
        {
          "code": 400,
          "type": "MEDIA_INVALID",
          "description": "Media invalid"
        },
        {
          "code": 400,
          "type": "MSG_ID_INVALID",
          "description": "Invalid message ID provided"
        },
        {
          "code": 400,
          "type": "PEER_ID_INVALID",
          "description": "The provided peer id is invalid"
        },
        {
          "code": 400,
          "type": "PHOTO_EXT_INVALID",
          "description": "The extension of the photo is invalid"
        },
        {
          "code": 400,
          "type": "PHOTO_INVALID_DIMENSIONS",
          "description": "The photo dimensions are invalid"
        },
        {
          "code": 400,
          "type": "PHOTO_SAVE_FILE_INVALID",
          "description": "Internal issues, try again later"
        },
        {
          "code": 400,
          "type": "POLL_ANSWERS_INVALID",
          "description": "Invalid poll answers were provided"
        },
        {
          "code": 400,
          "type": "POLL_OPTION_DUPLICATE",
          "description": "Duplicate poll options provided"
        },
        {
          "code": 400,
          "type": "POLL_OPTION_INVALID",
          "description": "Invalid poll option provided"
        },
        {
          "code": 400,
          "type": "QUIZ_CORRECT_ANSWERS_EMPTY",
          "description": "No correct quiz answer was specified"
        },
        {
          "code": 400,
          "type": "QUIZ_CORRECT_ANSWER_INVALID",
          "description": "An invalid value was provided to the correct_answers field"
        },
        {
          "code": 400,
          "type": "REPLY_MARKUP_BUY_EMPTY",
          "description": "Reply markup for buy button empty"
        },
        {
          "code": 400,
          "type": "REPLY_MARKUP_INVALID",
          "description": "The provided reply markup is invalid"
        },
        {
          "code": 400,
          "type": "SCHEDULE_TOO_MUCH",
          "description": "There are too many scheduled messages"
        },
        {
          "code": 420,
          "type": "SLOWMODE_WAIT_X",
          "description": "Slowmode is enabled in this chat: you must wait for the specified number of seconds before sending another message to the chat."
        },
        {
          "code": 400,
          "type": "TTL_MEDIA_INVALID",
          "description": "Invalid media Time To Live was provided"
        },
        {
          "code": 400,
          "type": "USER_BANNED_IN_CHANNEL",
          "description": "You're banned from sending messages in supergroups/channels"
        },
        {
          "code": 400,
          "type": "USER_IS_BLOCKED",
          "description": "You were blocked by this user"
        },
        {
          "code": 400,
          "type": "USER_IS_BOT",
          "description": "Bots can't send messages to other bots"
        },
        {
          "code": 400,
          "type": "WEBPAGE_CURL_FAILED",
          "description": "Failure while fetching the webpage with cURL"
        },
        {
          "code": 400,
          "type": "WEBPAGE_MEDIA_EMPTY",
          "description": "Webpage media empty"
        },
        {
          "code": 400,
          "type": "YOU_BLOCKED_USER",
          "description": "You blocked this user"
        }
      ]
    },
    "messages.sendMessage": {
      "name": "messages.sendMessage",
      "description": [
        "Sends a message to a chat"
      ],
      "parameters": {
        "background": "Send this message as background message",
        "clear_draft": "Clear the draft field",
        "entities": "Message entities for sending styled text",
        "flags": "Flags, see TL conditional fields",
        "message": "The message",
        "no_webpage": "Set this flag to disable generation of the webpage preview",
        "peer": "The destination where the message will be sent",
        "random_id": "Unique client message ID required to prevent message resending",
        "reply_markup": "Reply markup for sending bot buttons",
        "reply_to_msg_id": "The message ID to which this message will reply to",
        "schedule_date": "Scheduled message date for scheduled messages",
        "silent": "Send this message silently (no notifications for the receivers)"
      },
      "errors": [
        {
          "code": 401,
          "type": "AUTH_KEY_PERM_EMPTY",
          "description": "The temporary auth key must be binded to the permanent auth key to use these methods."
        },
        {
          "code": 400,
          "type": "BOT_DOMAIN_INVALID",
          "description": "Bot domain invalid"
        },
        {
          "code": 400,
          "type": "BOT_INVALID",
          "description": "This is not a valid bot"
        },
        {
          "code": 400,
          "type": "BUTTON_DATA_INVALID",
          "description": "The data of one or more of the buttons you provided is invalid"
        },
        {
          "code": 400,
          "type": "BUTTON_TYPE_INVALID",
          "description": "The type of one or more of the buttons you provided is invalid"
        },
        {
          "code": 400,
          "type": "BUTTON_URL_INVALID",
          "description": "Button URL invalid"
        },
        {
          "code": 400,
          "type": "CHANNEL_INVALID",
          "description": "The provided channel is invalid"
        },
        {
          "code": 400,
          "type": "CHANNEL_PRIVATE",
          "description": "You haven't joined this channel/supergroup"
        },
        {
          "code": 400,
          "type": "CHAT_ADMIN_REQUIRED",
          "description": "You must be an admin in this chat to do this"
        },
        {
          "code": 400,
          "type": "CHAT_ID_INVALID",
          "description": "The provided chat id is invalid"
        },
        {
          "code": 400,
          "type": "CHAT_RESTRICTED",
          "description": "You can't send messages in this chat, you were restricted"
        },
        {
          "code": 403,
          "type": "CHAT_WRITE_FORBIDDEN",
          "description": "You can't write in this chat"
        },
        {
          "code": 400,
          "type": "ENCRYPTION_DECLINED",
          "description": "The secret chat was declined"
        },
        {
          "code": 400,
          "type": "ENTITY_MENTION_USER_INVALID",
          "description": "You mentioned an invalid user"
        },
        {
          "code": 400,
          "type": "FROM_MESSAGE_BOT_DISABLED",
          "description": "Bots can't use fromMessage min constructors"
        },
        {
          "code": 400,
          "type": "INPUT_USER_DEACTIVATED",
          "description": "The specified user was deleted"
        },
        {
          "code": 400,
          "type": "MESSAGE_EMPTY",
          "description": "The provided message is empty"
        },
        {
          "code": 400,
          "type": "MESSAGE_TOO_LONG",
          "description": "The provided message is too long"
        },
        {
          "code": 400,
          "type": "MSG_ID_INVALID",
          "description": "Provided reply_to_msg_id is invalid"
        },
        {
          "code": 400,
          "type": "PEER_ID_INVALID",
          "description": "The provided peer id is invalid"
        },
        {
          "code": 400,
          "type": "PINNED_DIALOGS_TOO_MUCH",
          "description": "Too many pinned dialogs"
        },
        {
          "code": 400,
          "type": "REPLY_MARKUP_INVALID",
          "description": "The provided reply markup is invalid"
        },
        {
          "code": 400,
          "type": "SCHEDULE_BOT_NOT_ALLOWED",
          "description": "Bots cannot schedule messages"
        },
        {
          "code": 400,
          "type": "SCHEDULE_DATE_TOO_LATE",
          "description": "You can't schedule a message this far in the future"
        },
        {
          "code": 400,
          "type": "SCHEDULE_TOO_MUCH",
          "description": "There are too many scheduled messages"
        },
        {
          "code": 420,
          "type": "SLOWMODE_WAIT_X",
          "description": "Slowmode is enabled in this chat: you must wait for the specified number of seconds before sending another message to the chat."
        },
        {
          "code": 400,
          "type": "USER_BANNED_IN_CHANNEL",
          "description": "You're banned from sending messages in supergroups/channels"
        },
        {
          "code": 400,
          "type": "USER_IS_BLOCKED",
          "description": "You were blocked by this user"
        },
        {
          "code": 400,
          "type": "USER_IS_BOT",
          "description": "Bots can't send messages to other bots"
        },
        {
          "code": 400,
          "type": "YOU_BLOCKED_USER",
          "description": "You blocked this user"
        }
      ]
    },
    "messages.sendMultiMedia": {
      "name": "messages.sendMultiMedia",
      "description": [
        "Send an album or grouped media"
      ],
      "parameters": {
        "background": "Send in background?",
        "clear_draft": "Whether to clear drafts",
        "flags": "Flags, see TL conditional fields",
        "multi_media": "The medias to send",
        "peer": "The destination chat",
        "reply_to_msg_id": "The message to reply to",
        "schedule_date": "Scheduled message date for scheduled messages",
        "silent": "Whether to send the album silently (no notification triggered)"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHAT_ADMIN_REQUIRED",
          "description": "You must be an admin in this chat to do this"
        },
        {
          "code": 400,
          "type": "MEDIA_EMPTY",
          "description": "The provided media object is invalid"
        },
        {
          "code": 400,
          "type": "MEDIA_INVALID",
          "description": "Media invalid"
        },
        {
          "code": 400,
          "type": "MULTI_MEDIA_TOO_LONG",
          "description": "Too many media files for album"
        },
        {
          "code": 400,
          "type": "PEER_ID_INVALID",
          "description": "The provided peer id is invalid"
        },
        {
          "code": 400,
          "type": "RANDOM_ID_EMPTY",
          "description": "Random ID empty"
        }
      ]
    },
    "messages.sendScheduledMessages": {
      "name": "messages.sendScheduledMessages",
      "description": [
        "Send scheduled messages right away"
      ],
      "parameters": {
        "id": "Scheduled message IDs",
        "peer": "Peer"
      },
      "errors": [
        {
          "code": 400,
          "type": "MESSAGE_ID_INVALID",
          "description": "The provided message id is invalid"
        }
      ]
    },
    "messages.sendScreenshotNotification": {
      "name": "messages.sendScreenshotNotification",
      "description": [
        "Notify the other user in a private chat that a screenshot of the chat was taken"
      ],
      "parameters": {
        "peer": "Other user",
        "random_id": "Random ID to avoid message resending",
        "reply_to_msg_id": "ID of message that was screenshotted, can be 0"
      },
      "errors": [
        {
          "code": 400,
          "type": "PEER_ID_INVALID",
          "description": "The provided peer id is invalid"
        }
      ]
    },
    "messages.sendVote": {
      "name": "messages.sendVote",
      "description": [
        "Vote in a poll"
      ],
      "parameters": {
        "msg_id": "The message ID of the poll",
        "options": "The options that were chosen",
        "peer": "The chat where the poll was sent"
      },
      "errors": [
        {
          "code": 400,
          "type": "MESSAGE_ID_INVALID",
          "description": "The provided message id is invalid"
        },
        {
          "code": 400,
          "type": "MESSAGE_POLL_CLOSED",
          "description": "Poll closed"
        },
        {
          "code": 400,
          "type": "OPTIONS_TOO_MUCH",
          "description": "Too many options provided"
        },
        {
          "code": 400,
          "type": "OPTION_INVALID",
          "description": "Invalid option selected"
        },
        {
          "code": 400,
          "type": "REVOTE_NOT_ALLOWED",
          "description": "You cannot change your vote"
        }
      ]
    },
    "messages.setBotCallbackAnswer": {
      "name": "messages.setBotCallbackAnswer",
      "description": [
        "Set the callback answer to a user button press (bots only)"
      ],
      "parameters": {
        "alert": "Whether to show the message as a popup instead of a toast notification",
        "cache_time": "Cache validity",
        "flags": "Flags, see TL conditional fields",
        "message": "Popup to show",
        "query_id": "Query ID",
        "url": "URL to open"
      },
      "errors": [
        {
          "code": 400,
          "type": "QUERY_ID_INVALID",
          "description": "The query ID is invalid"
        },
        {
          "code": 400,
          "type": "URL_INVALID",
          "description": "Invalid URL provided"
        }
      ]
    },
    "messages.setBotPrecheckoutResults": {
      "name": "messages.setBotPrecheckoutResults",
      "description": [
        "Once the user has confirmed their payment and shipping details, the bot receives an updateBotPrecheckoutQuery update.\nUse this method to respond to such pre-checkout queries.\nNote: Telegram must receive an answer within 10 seconds after the pre-checkout query was sent."
      ],
      "parameters": {
        "error": "Required if the success isn't set. Error message in human readable form that explains the reason for failure to proceed with the checkout (e.g. \"Sorry, somebody just bought the last of our amazing black T-shirts while you were busy filling out your payment details. Please choose a different color or garment!\"). Telegram will display this message to the user.",
        "flags": "Flags, see TL conditional fields",
        "query_id": "Unique identifier for the query to be answered",
        "success": "Set this flag if everything is alright (goods are available, etc.) and the bot is ready to proceed with the order, otherwise do not set it, and set the error field, instead"
      },
      "errors": [
        {
          "code": 400,
          "type": "ERROR_TEXT_EMPTY",
          "description": "The provided error message is empty"
        }
      ]
    },
    "messages.setBotShippingResults": {
      "name": "messages.setBotShippingResults",
      "description": [
        "If you sent an invoice requesting a shipping address and the parameter is_flexible was specified, the bot will receive an updateBotShippingQuery update. Use this method to reply to shipping queries."
      ],
      "parameters": {
        "error": "Error message in human readable form that explains why it is impossible to complete the order (e.g. \"Sorry, delivery to your desired address is unavailable'). Telegram will display this message to the user.",
        "flags": "Flags, see TL conditional fields",
        "query_id": "Unique identifier for the query to be answered",
        "shipping_options": "A vector of available shipping options."
      },
      "errors": [
        {
          "code": 400,
          "type": "QUERY_ID_INVALID",
          "description": "The query ID is invalid"
        }
      ]
    },
    "messages.setEncryptedTyping": {
      "name": "messages.setEncryptedTyping",
      "description": [
        "Send typing event by the current user to a secret chat."
      ],
      "parameters": {
        "peer": "Secret chat ID",
        "typing": "Typing.Possible values:(boolTrue), if the user started typing and more than 5 seconds have passed since the last request(boolFalse), if the user stopped typing"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHAT_ID_INVALID",
          "description": "The provided chat id is invalid"
        }
      ]
    },
    "messages.setGameScore": {
      "name": "messages.setGameScore",
      "description": [
        "Use this method to set the score of the specified user in a game sent as a normal message (bots only)."
      ],
      "parameters": {
        "edit_message": "Set this flag if the game message should be automatically edited to include the current scoreboard",
        "flags": "Flags, see TL conditional fields",
        "force": "Set this flag if the high score is allowed to decrease. This can be useful when fixing mistakes or banning cheaters",
        "id": "Identifier of the sent message",
        "peer": "Unique identifier of target chat",
        "score": "New score",
        "user_id": "User identifier"
      },
      "errors": [
        {
          "code": 400,
          "type": "MESSAGE_ID_INVALID",
          "description": "The provided message id is invalid"
        },
        {
          "code": 400,
          "type": "PEER_ID_INVALID",
          "description": "The provided peer id is invalid"
        },
        {
          "code": 400,
          "type": "USER_BOT_REQUIRED",
          "description": "This method can only be called by a bot"
        }
      ]
    },
    "messages.setInlineBotResults": {
      "name": "messages.setInlineBotResults",
      "description": [
        "Answer an inline query, for bots only"
      ],
      "parameters": {
        "cache_time": "The maximum amount of time in seconds that the result of the inline query may be cached on the server. Defaults to 300.",
        "flags": "Flags, see TL conditional fields",
        "gallery": "Set this flag if the results are composed of media files",
        "next_offset": "Pass the offset that a client should send in the next query with the same text to receive more results. Pass an empty string if there are no more results or if you dont support pagination. Offset length cant exceed 64 bytes.",
        "private": "Set this flag if results may be cached on the server side only for the user that sent the query. By default, results may be returned to any user who sends the same query",
        "query_id": "Unique identifier for the answered query",
        "results": "Vector of results for the inline query",
        "switch_pm": "If passed, clients will display a button with specified text that switches the user to a private chat with the bot and sends the bot a start message with a certain parameter."
      },
      "errors": [
        {
          "code": 400,
          "type": "ARTICLE_TITLE_EMPTY",
          "description": "The title of the article is empty"
        },
        {
          "code": 400,
          "type": "BUTTON_DATA_INVALID",
          "description": "The data of one or more of the buttons you provided is invalid"
        },
        {
          "code": 400,
          "type": "BUTTON_TYPE_INVALID",
          "description": "The type of one or more of the buttons you provided is invalid"
        },
        {
          "code": 400,
          "type": "BUTTON_URL_INVALID",
          "description": "Button URL invalid"
        },
        {
          "code": 400,
          "type": "GIF_CONTENT_TYPE_INVALID",
          "description": "GIF content-type invalid"
        },
        {
          "code": 400,
          "type": "MESSAGE_EMPTY",
          "description": "The provided message is empty"
        },
        {
          "code": 400,
          "type": "MESSAGE_TOO_LONG",
          "description": "The provided message is too long"
        },
        {
          "code": 400,
          "type": "PHOTO_CONTENT_TYPE_INVALID",
          "description": "Photo mime-type invalid"
        },
        {
          "code": 400,
          "type": "PHOTO_CONTENT_URL_EMPTY",
          "description": "Photo URL invalid"
        },
        {
          "code": 400,
          "type": "PHOTO_INVALID",
          "description": "Photo invalid"
        },
        {
          "code": 400,
          "type": "PHOTO_THUMB_URL_EMPTY",
          "description": "Photo thumbnail URL is empty"
        },
        {
          "code": 400,
          "type": "QUERY_ID_INVALID",
          "description": "The query ID is invalid"
        },
        {
          "code": 400,
          "type": "REPLY_MARKUP_INVALID",
          "description": "The provided reply markup is invalid"
        },
        {
          "code": 400,
          "type": "RESULTS_TOO_MUCH",
          "description": "Too many results were provided"
        },
        {
          "code": 400,
          "type": "RESULT_ID_DUPLICATE",
          "description": "You provided a duplicate result ID"
        },
        {
          "code": 400,
          "type": "RESULT_TYPE_INVALID",
          "description": "Result type invalid"
        },
        {
          "code": 400,
          "type": "SEND_MESSAGE_MEDIA_INVALID",
          "description": "Invalid media provided"
        },
        {
          "code": 400,
          "type": "SEND_MESSAGE_TYPE_INVALID",
          "description": "The message type is invalid"
        },
        {
          "code": 400,
          "type": "START_PARAM_INVALID",
          "description": "Start parameter invalid"
        },
        {
          "code": 403,
          "type": "USER_BOT_INVALID",
          "description": "This method can only be called by a bot"
        },
        {
          "code": 400,
          "type": "WEBDOCUMENT_INVALID",
          "description": "Invalid webdocument URL provided"
        },
        {
          "code": 400,
          "type": "WEBDOCUMENT_MIME_INVALID",
          "description": "Invalid webdocument mime type provided"
        },
        {
          "code": 400,
          "type": "WEBDOCUMENT_SIZE_TOO_BIG",
          "description": "Webdocument is too big!"
        }
      ]
    },
    "messages.setInlineGameScore": {
      "name": "messages.setInlineGameScore",
      "description": [
        "Use this method to set the score of the specified user in a game sent as an inline message (bots only)."
      ],
      "parameters": {
        "edit_message": "Set this flag if the game message should be automatically edited to include the current scoreboard",
        "flags": "Flags, see TL conditional fields",
        "force": "Set this flag if the high score is allowed to decrease. This can be useful when fixing mistakes or banning cheaters",
        "id": "ID of the inline message",
        "score": "New score",
        "user_id": "User identifier"
      },
      "errors": [
        {
          "code": 400,
          "type": "MESSAGE_ID_INVALID",
          "description": "The provided message id is invalid"
        },
        {
          "code": 400,
          "type": "USER_BOT_REQUIRED",
          "description": "This method can only be called by a bot"
        }
      ]
    },
    "messages.setTyping": {
      "name": "messages.setTyping",
      "description": [
        "Sends a current user typing event (see SendMessageAction for all event types) to a conversation partner or group."
      ],
      "parameters": {
        "action": "Type of actionParameter added in Layer 17.",
        "flags": "Flags, see TL conditional fields",
        "peer": "Target user or group",
        "top_msg_id": "Thread ID"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHANNEL_INVALID",
          "description": "The provided channel is invalid"
        },
        {
          "code": 400,
          "type": "CHANNEL_PRIVATE",
          "description": "You haven't joined this channel/supergroup"
        },
        {
          "code": 400,
          "type": "CHAT_ADMIN_REQUIRED",
          "description": "You must be an admin in this chat to do this"
        },
        {
          "code": 400,
          "type": "CHAT_ID_INVALID",
          "description": "The provided chat id is invalid"
        },
        {
          "code": 403,
          "type": "CHAT_WRITE_FORBIDDEN",
          "description": "You can't write in this chat"
        },
        {
          "code": 400,
          "type": "INPUT_USER_DEACTIVATED",
          "description": "The specified user was deleted"
        },
        {
          "code": 400,
          "type": "MSG_ID_INVALID",
          "description": "Invalid message ID provided"
        },
        {
          "code": 400,
          "type": "PEER_ID_INVALID",
          "description": "The provided peer id is invalid"
        },
        {
          "code": 400,
          "type": "USER_BANNED_IN_CHANNEL",
          "description": "You're banned from sending messages in supergroups/channels"
        },
        {
          "code": 400,
          "type": "USER_IS_BLOCKED",
          "description": "You were blocked by this user"
        },
        {
          "code": 400,
          "type": "USER_IS_BOT",
          "description": "Bots can't send messages to other bots"
        }
      ]
    },
    "messages.startBot": {
      "name": "messages.startBot",
      "description": [
        "Start a conversation with a bot using a deep linking parameter"
      ],
      "parameters": {
        "bot": "The bot",
        "peer": "The chat where to start the bot, can be the bot's private chat or a group",
        "random_id": "Random ID to avoid resending the same message",
        "start_param": "Deep linking parameter"
      },
      "errors": [
        {
          "code": 400,
          "type": "BOT_INVALID",
          "description": "This is not a valid bot"
        },
        {
          "code": 400,
          "type": "INPUT_USER_DEACTIVATED",
          "description": "The specified user was deleted"
        },
        {
          "code": 400,
          "type": "MSG_ID_INVALID",
          "description": "Invalid message ID provided"
        },
        {
          "code": 400,
          "type": "PEER_ID_INVALID",
          "description": "The provided peer id is invalid"
        },
        {
          "code": 400,
          "type": "START_PARAM_EMPTY",
          "description": "The start parameter is empty"
        },
        {
          "code": 400,
          "type": "START_PARAM_INVALID",
          "description": "Start parameter invalid"
        },
        {
          "code": 400,
          "type": "START_PARAM_TOO_LONG",
          "description": "Start parameter is too long"
        }
      ]
    },
    "messages.toggleDialogPin": {
      "name": "messages.toggleDialogPin",
      "description": [
        "Pin/unpin a dialog"
      ],
      "parameters": {
        "flags": "Flags, see TL conditional fields",
        "peer": "The dialog to pin",
        "pinned": "Whether to pin or unpin the dialog"
      },
      "errors": [
        {
          "code": 400,
          "type": "PEER_ID_INVALID",
          "description": "The provided peer id is invalid"
        }
      ]
    },
    "messages.toggleStickerSets": {
      "name": "messages.toggleStickerSets",
      "description": [
        "Apply changes to multiple stickersets"
      ],
      "parameters": {
        "archive": "Archive the specified stickersets",
        "flags": "Flags, see TL conditional fields",
        "stickersets": "Stickersets to act upon",
        "unarchive": "Unarchive the specified stickersets",
        "uninstall": "Uninstall the specified stickersets"
      }
    },
    "messages.uninstallStickerSet": {
      "name": "messages.uninstallStickerSet",
      "description": [
        "Uninstall a stickerset"
      ],
      "parameters": {
        "stickerset": "The stickerset to uninstall"
      },
      "errors": [
        {
          "code": 400,
          "type": "STICKERSET_INVALID",
          "description": "The provided sticker set is invalid"
        }
      ]
    },
    "messages.unpinAllMessages": {
      "name": "messages.unpinAllMessages",
      "description": [
        "Unpin all pinned messages"
      ],
      "parameters": {
        "peer": "Chat where to unpin"
      }
    },
    "messages.updateDialogFilter": {
      "name": "messages.updateDialogFilter",
      "description": [
        "Update folder"
      ],
      "parameters": {
        "filter": "Folder info",
        "flags": "Flags, see TL conditional fields",
        "id": "Folder ID"
      },
      "errors": [
        {
          "code": 400,
          "type": "FILTER_ID_INVALID",
          "description": "The specified filter ID is invalid"
        }
      ]
    },
    "messages.updateDialogFiltersOrder": {
      "name": "messages.updateDialogFiltersOrder",
      "description": [
        "Reorder folders"
      ],
      "parameters": {
        "order": "New folder order"
      }
    },
    "messages.updatePinnedMessage": {
      "name": "messages.updatePinnedMessage",
      "description": [
        "Pin a message"
      ],
      "parameters": {
        "flags": "Flags, see TL conditional fields",
        "id": "The message to pin or unpin",
        "peer": "The peer where to pin the message",
        "pm_oneside": "Whether the message should only be pinned on the local side of a one-to-one chat",
        "silent": "Pin the message silently, without triggering a notification",
        "unpin": "Whether the message should unpinned or pinned"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHANNEL_PRIVATE",
          "description": "You haven't joined this channel/supergroup"
        },
        {
          "code": 400,
          "type": "CHAT_ADMIN_REQUIRED",
          "description": "You must be an admin in this chat to do this"
        },
        {
          "code": 400,
          "type": "CHAT_NOT_MODIFIED",
          "description": "The pinned message wasn't modified"
        },
        {
          "code": 403,
          "type": "CHAT_WRITE_FORBIDDEN",
          "description": "You can't write in this chat"
        },
        {
          "code": 400,
          "type": "MESSAGE_ID_INVALID",
          "description": "The provided message id is invalid"
        },
        {
          "code": 400,
          "type": "PIN_RESTRICTED",
          "description": "You can't pin messages"
        }
      ]
    },
    "messages.uploadEncryptedFile": {
      "name": "messages.uploadEncryptedFile",
      "description": [
        "Upload encrypted file and associate it to a secret chat"
      ],
      "parameters": {
        "file": "The file",
        "peer": "The secret chat to associate the file to"
      }
    },
    "messages.uploadMedia": {
      "name": "messages.uploadMedia",
      "description": [
        "Upload a file and associate it to a chat (without actually sending it to the chat)"
      ],
      "parameters": {
        "media": "File uploaded in chunks as described in files ",
        "peer": "The chat, can be an inputPeerEmpty for bots"
      },
      "errors": [
        {
          "code": 400,
          "type": "BOT_MISSING",
          "description": "This method can only be run by a bot"
        },
        {
          "code": 400,
          "type": "CHANNEL_PRIVATE",
          "description": "You haven't joined this channel/supergroup"
        },
        {
          "code": 400,
          "type": "CHAT_ADMIN_REQUIRED",
          "description": "You must be an admin in this chat to do this"
        },
        {
          "code": 403,
          "type": "CHAT_WRITE_FORBIDDEN",
          "description": "You can't write in this chat"
        },
        {
          "code": 400,
          "type": "FILE_PARTS_INVALID",
          "description": "The number of file parts is invalid"
        },
        {
          "code": 400,
          "type": "IMAGE_PROCESS_FAILED",
          "description": "Failure while processing image"
        },
        {
          "code": 400,
          "type": "INPUT_USER_DEACTIVATED",
          "description": "The specified user was deleted"
        },
        {
          "code": 400,
          "type": "MEDIA_INVALID",
          "description": "Media invalid"
        },
        {
          "code": 400,
          "type": "MSG_ID_INVALID",
          "description": "Invalid message ID provided"
        },
        {
          "code": 400,
          "type": "PEER_ID_INVALID",
          "description": "The provided peer id is invalid"
        },
        {
          "code": 400,
          "type": "PHOTO_EXT_INVALID",
          "description": "The extension of the photo is invalid"
        },
        {
          "code": 400,
          "type": "PHOTO_SAVE_FILE_INVALID",
          "description": "Internal issues, try again later"
        },
        {
          "code": 400,
          "type": "USER_BANNED_IN_CHANNEL",
          "description": "You're banned from sending messages in supergroups/channels"
        },
        {
          "code": 400,
          "type": "WEBPAGE_CURL_FAILED",
          "description": "Failure while fetching the webpage with cURL"
        }
      ]
    },
    "payments.clearSavedInfo": {
      "name": "payments.clearSavedInfo",
      "description": [
        "Clear saved payment information"
      ],
      "parameters": {
        "credentials": "Remove saved payment credentials",
        "flags": "Flags, see TL conditional fields",
        "info": "Clear the last order settings saved by the user"
      }
    },
    "payments.getBankCardData": {
      "name": "payments.getBankCardData",
      "description": [
        "Get info about a credit card"
      ],
      "parameters": {
        "number": "Credit card number"
      }
    },
    "payments.getPaymentForm": {
      "name": "payments.getPaymentForm",
      "description": [
        "Get a payment form"
      ],
      "parameters": {
        "msg_id": "Message ID of payment form"
      },
      "errors": [
        {
          "code": 400,
          "type": "MESSAGE_ID_INVALID",
          "description": "The provided message id is invalid"
        }
      ]
    },
    "payments.getPaymentReceipt": {
      "name": "payments.getPaymentReceipt",
      "description": [
        "Get payment receipt"
      ],
      "parameters": {
        "msg_id": "Message ID of receipt"
      },
      "errors": [
        {
          "code": 400,
          "type": "MESSAGE_ID_INVALID",
          "description": "The provided message id is invalid"
        }
      ]
    },
    "payments.getSavedInfo": {
      "name": "payments.getSavedInfo",
      "description": [
        "Get saved payment information"
      ]
    },
    "payments.sendPaymentForm": {
      "name": "payments.sendPaymentForm",
      "description": [
        "Send compiled payment form"
      ],
      "parameters": {
        "credentials": "Payment credentials",
        "flags": "Flags, see TL conditional fields",
        "msg_id": "Message ID of form",
        "requested_info_id": "ID of saved and validated order info",
        "shipping_option_id": "Chosen shipping option ID"
      },
      "errors": [
        {
          "code": 400,
          "type": "MESSAGE_ID_INVALID",
          "description": "The provided message id is invalid"
        }
      ]
    },
    "payments.validateRequestedInfo": {
      "name": "payments.validateRequestedInfo",
      "description": [
        "Submit requested order information for validation"
      ],
      "parameters": {
        "flags": "Flags, see TL conditional fields",
        "info": "Requested order information",
        "msg_id": "Message ID of payment form",
        "save": "Save order information to re-use it for future orders"
      },
      "errors": [
        {
          "code": 400,
          "type": "MESSAGE_ID_INVALID",
          "description": "The provided message id is invalid"
        }
      ]
    },
    "phone.acceptCall": {
      "name": "phone.acceptCall",
      "description": [
        "Accept incoming call"
      ],
      "parameters": {
        "g_b": "Parameter for E2E encryption key exchange ",
        "peer": "The call to accept",
        "protocol": "Phone call settings"
      },
      "errors": [
        {
          "code": 400,
          "type": "CALL_ALREADY_ACCEPTED",
          "description": "The call was already accepted"
        },
        {
          "code": 400,
          "type": "CALL_ALREADY_DECLINED",
          "description": "The call was already declined"
        },
        {
          "code": 400,
          "type": "CALL_PEER_INVALID",
          "description": "The provided call peer object is invalid"
        },
        {
          "code": 400,
          "type": "CALL_PROTOCOL_FLAGS_INVALID",
          "description": "Call protocol flags invalid"
        }
      ]
    },
    "phone.confirmCall": {
      "name": "phone.confirmCall",
      "description": [
        "Complete phone call E2E encryption key exchange "
      ],
      "parameters": {
        "g_a": "Parameter for E2E encryption key exchange ",
        "key_fingerprint": "Key fingerprint",
        "peer": "The phone call",
        "protocol": "Phone call settings"
      },
      "errors": [
        {
          "code": 400,
          "type": "CALL_ALREADY_DECLINED",
          "description": "The call was already declined"
        },
        {
          "code": 400,
          "type": "CALL_PEER_INVALID",
          "description": "The provided call peer object is invalid"
        }
      ]
    },
    "phone.discardCall": {
      "name": "phone.discardCall",
      "description": [
        "Refuse or end running call"
      ],
      "parameters": {
        "connection_id": "Preferred libtgvoip relay ID",
        "duration": "Call duration",
        "flags": "Flags, see TL conditional fields",
        "peer": "The phone call",
        "reason": "Why was the call discarded",
        "video": "Whether this is a video call"
      },
      "errors": [
        {
          "code": 400,
          "type": "CALL_ALREADY_ACCEPTED",
          "description": "The call was already accepted"
        },
        {
          "code": 400,
          "type": "CALL_PEER_INVALID",
          "description": "The provided call peer object is invalid"
        }
      ]
    },
    "phone.getCallConfig": {
      "name": "phone.getCallConfig",
      "description": [
        "Get phone call configuration to be passed to libtgvoip's shared config"
      ]
    },
    "phone.receivedCall": {
      "name": "phone.receivedCall",
      "description": [
        "Optional: notify the server that the user is currently busy in a call: this will automatically refuse all incoming phone calls until the current phone call is ended."
      ],
      "parameters": {
        "peer": "The phone call we're currently in"
      },
      "errors": [
        {
          "code": 400,
          "type": "CALL_ALREADY_DECLINED",
          "description": "The call was already declined"
        },
        {
          "code": 400,
          "type": "CALL_PEER_INVALID",
          "description": "The provided call peer object is invalid"
        }
      ]
    },
    "phone.requestCall": {
      "name": "phone.requestCall",
      "description": [
        "Start a telegram phone call"
      ],
      "parameters": {
        "flags": "Flags, see TL conditional fields",
        "g_a_hash": "Parameter for E2E encryption key exchange ",
        "protocol": "Phone call settings",
        "random_id": "Random ID to avoid resending the same object",
        "user_id": "Destination of the phone call",
        "video": "Whether to start a video call"
      },
      "errors": [
        {
          "code": 400,
          "type": "CALL_PROTOCOL_FLAGS_INVALID",
          "description": "Call protocol flags invalid"
        },
        {
          "code": 400,
          "type": "PARTICIPANT_VERSION_OUTDATED",
          "description": "The other participant does not use an up to date telegram client with support for calls"
        },
        {
          "code": 400,
          "type": "USER_ID_INVALID",
          "description": "The provided user ID is invalid"
        },
        {
          "code": 403,
          "type": "USER_IS_BLOCKED",
          "description": "You were blocked by this user"
        },
        {
          "code": 403,
          "type": "USER_PRIVACY_RESTRICTED",
          "description": "The user's privacy settings do not allow you to do this"
        }
      ]
    },
    "phone.saveCallDebug": {
      "name": "phone.saveCallDebug",
      "description": [
        "Send phone call debug data to server"
      ],
      "parameters": {
        "debug": "Debug statistics obtained from libtgvoip",
        "peer": "Phone call"
      },
      "errors": [
        {
          "code": 400,
          "type": "CALL_PEER_INVALID",
          "description": "The provided call peer object is invalid"
        },
        {
          "code": 400,
          "type": "DATA_JSON_INVALID",
          "description": "The provided JSON data is invalid"
        }
      ]
    },
    "phone.sendSignalingData": {
      "name": "phone.sendSignalingData",
      "description": [
        "Send VoIP signaling data"
      ],
      "parameters": {
        "data": "Signaling payload",
        "peer": "Phone call"
      }
    },
    "phone.setCallRating": {
      "name": "phone.setCallRating",
      "description": [
        "Rate a call"
      ],
      "parameters": {
        "comment": "An additional comment",
        "flags": "Flags, see TL conditional fields",
        "peer": "The call to rate",
        "rating": "Rating in 1-5 stars",
        "user_initiative": "Whether the user decided on their own initiative to rate the call"
      },
      "errors": [
        {
          "code": 400,
          "type": "CALL_PEER_INVALID",
          "description": "The provided call peer object is invalid"
        }
      ]
    },
    "photos.deletePhotos": {
      "name": "photos.deletePhotos",
      "description": [
        "Deletes profile photos."
      ],
      "parameters": {
        "id": "Input photos to delete"
      }
    },
    "photos.getUserPhotos": {
      "name": "photos.getUserPhotos",
      "description": [
        "Returns the list of user photos."
      ],
      "parameters": {
        "limit": "Number of list elements to be returned",
        "max_id": "If a positive value was transferred, the method will return only photos with IDs less than the set one",
        "offset": "Number of list elements to be skipped",
        "user_id": "User ID"
      },
      "errors": [
        {
          "code": 400,
          "type": "MAX_ID_INVALID",
          "description": "The provided max ID is invalid"
        },
        {
          "code": 400,
          "type": "USER_ID_INVALID",
          "description": "The provided user ID is invalid"
        }
      ]
    },
    "photos.updateProfilePhoto": {
      "name": "photos.updateProfilePhoto",
      "description": [
        "Installs a previously uploaded photo as a profile photo."
      ],
      "parameters": {
        "id": "Input photo"
      },
      "errors": [
        {
          "code": 400,
          "type": "FILE_PARTS_INVALID",
          "description": "The number of file parts is invalid"
        },
        {
          "code": 400,
          "type": "IMAGE_PROCESS_FAILED",
          "description": "Failure while processing image"
        },
        {
          "code": 400,
          "type": "LOCATION_INVALID",
          "description": "The provided location is invalid"
        },
        {
          "code": 400,
          "type": "PHOTO_CROP_SIZE_SMALL",
          "description": "Photo is too small"
        },
        {
          "code": 400,
          "type": "PHOTO_EXT_INVALID",
          "description": "The extension of the photo is invalid"
        },
        {
          "code": 400,
          "type": "PHOTO_ID_INVALID",
          "description": "Photo ID invalid"
        }
      ]
    },
    "photos.uploadProfilePhoto": {
      "name": "photos.uploadProfilePhoto",
      "description": [
        "Updates current user profile photo."
      ],
      "parameters": {
        "file": "File saved in parts by means of upload.saveFilePart method",
        "flags": "Flags, see TL conditional fields",
        "video": "Animated profile picture video",
        "video_start_ts": "Floating point UNIX timestamp in seconds, indicating the frame of the video that should be used as static preview."
      },
      "errors": [
        {
          "code": 400,
          "type": "FILE_PARTS_INVALID",
          "description": "The number of file parts is invalid"
        },
        {
          "code": 400,
          "type": "IMAGE_PROCESS_FAILED",
          "description": "Failure while processing image"
        },
        {
          "code": 400,
          "type": "PHOTO_CROP_FILE_MISSING",
          "description": "Photo crop file missing"
        },
        {
          "code": 400,
          "type": "PHOTO_CROP_SIZE_SMALL",
          "description": "Photo is too small"
        },
        {
          "code": 400,
          "type": "PHOTO_EXT_INVALID",
          "description": "The extension of the photo is invalid"
        },
        {
          "code": 400,
          "type": "PHOTO_FILE_MISSING",
          "description": "Profile photo file missing"
        },
        {
          "code": 400,
          "type": "VIDEO_FILE_INVALID",
          "description": "The specified video file is invalid"
        }
      ]
    },
    "stats.getBroadcastStats": {
      "name": "stats.getBroadcastStats",
      "description": [
        "Get channel statistics"
      ],
      "parameters": {
        "channel": "The channel",
        "dark": "Whether to enable dark theme for graph colors",
        "flags": "Flags, see TL conditional fields"
      },
      "errors": [
        {
          "code": 400,
          "type": "BROADCAST_REQUIRED",
          "description": "This method can only be called on a channel, please use stats.getMegagroupStats for supergroups"
        },
        {
          "code": 400,
          "type": "CHANNEL_INVALID",
          "description": "The provided channel is invalid"
        },
        {
          "code": 400,
          "type": "CHANNEL_PRIVATE",
          "description": "You haven't joined this channel/supergroup"
        },
        {
          "code": 400,
          "type": "CHAT_ADMIN_REQUIRED",
          "description": "You must be an admin in this chat to do this"
        }
      ]
    },
    "stats.getMegagroupStats": {
      "name": "stats.getMegagroupStats",
      "description": [
        "Get supergroup statistics"
      ],
      "parameters": {
        "channel": "Supergroup ID",
        "dark": "Whether to enable dark theme for graph colors",
        "flags": "Flags, see TL conditional fields"
      }
    },
    "stats.getMessagePublicForwards": {
      "name": "stats.getMessagePublicForwards",
      "description": [
        "Obtains a list of messages, indicating to which other public channels was a channel message forwarded.\nWill return a list of messages with peer_id equal to the public channel to which this message was forwarded."
      ],
      "parameters": {
        "channel": "Source channel",
        "limit": "Maximum number of results to return, see pagination",
        "msg_id": "Source message ID",
        "offset_id": "Offsets for pagination, for more info click here",
        "offset_peer": "Offsets for pagination, for more info click here",
        "offset_rate": "Initially 0, then set to the next_rate parameter of messages.messagesSlice"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHANNEL_INVALID",
          "description": "The provided channel is invalid"
        },
        {
          "code": 400,
          "type": "MESSAGE_ID_INVALID",
          "description": "The provided message id is invalid"
        }
      ]
    },
    "stats.getMessageStats": {
      "name": "stats.getMessageStats",
      "description": [
        "Get message statistics"
      ],
      "parameters": {
        "channel": "Channel ID",
        "dark": "Whether to enable dark theme for graph colors",
        "flags": "Flags, see TL conditional fields",
        "msg_id": "Message ID"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHAT_ADMIN_REQUIRED",
          "description": "You must be an admin in this chat to do this"
        }
      ]
    },
    "stats.loadAsyncGraph": {
      "name": "stats.loadAsyncGraph",
      "description": [
        "Load channel statistics graph asynchronously"
      ],
      "parameters": {
        "flags": "Flags, see TL conditional fields",
        "token": "Graph token from statsGraphAsync constructor",
        "x": "Zoom value, if required"
      },
      "errors": [
        {
          "code": 400,
          "type": "GRAPH_INVALID_RELOAD",
          "description": "Invalid graph token provided, please reload the stats and provide the updated token"
        },
        {
          "code": 400,
          "type": "GRAPH_OUTDATED_RELOAD",
          "description": "The graph is outdated, please get a new async token using stats.getBroadcastStats"
        }
      ]
    },
    "stickers.addStickerToSet": {
      "name": "stickers.addStickerToSet",
      "description": [
        "Add a sticker to a stickerset, bots only. The sticker set must have been created by the bot."
      ],
      "parameters": {
        "sticker": "The sticker",
        "stickerset": "The stickerset"
      },
      "errors": [
        {
          "code": 400,
          "type": "BOT_MISSING",
          "description": "This method can only be run by a bot"
        },
        {
          "code": 400,
          "type": "STICKERSET_INVALID",
          "description": "The provided sticker set is invalid"
        }
      ]
    },
    "stickers.changeStickerPosition": {
      "name": "stickers.changeStickerPosition",
      "description": [
        "Changes the absolute position of a sticker in the set to which it belongs; for bots only. The sticker set must have been created by the bot"
      ],
      "parameters": {
        "position": "The new position of the sticker, zero-based",
        "sticker": "The sticker"
      },
      "errors": [
        {
          "code": 400,
          "type": "BOT_MISSING",
          "description": "This method can only be run by a bot"
        },
        {
          "code": 400,
          "type": "STICKER_INVALID",
          "description": "The provided sticker is invalid"
        }
      ]
    },
    "stickers.createStickerSet": {
      "name": "stickers.createStickerSet",
      "description": [
        "Create a stickerset, bots only."
      ],
      "parameters": {
        "animated": "Whether this is an animated stickerset",
        "flags": "Flags, see TL conditional fields",
        "masks": "Whether this is a mask stickerset",
        "short_name": "Sticker set name. Can contain only English letters, digits and underscores. Must end with \"by\" ( is case insensitive); 1-64 characters",
        "stickers": "Stickers",
        "thumb": "Thumbnail",
        "title": "Stickerset name, 1-64 chars",
        "user_id": "Stickerset owner"
      },
      "errors": [
        {
          "code": 400,
          "type": "BOT_MISSING",
          "description": "This method can only be run by a bot"
        },
        {
          "code": 400,
          "type": "PACK_SHORT_NAME_INVALID",
          "description": "Short pack name invalid"
        },
        {
          "code": 400,
          "type": "PACK_SHORT_NAME_OCCUPIED",
          "description": "A stickerpack with this name already exists"
        },
        {
          "code": 400,
          "type": "PACK_TITLE_INVALID",
          "description": "The stickerpack title is invalid"
        },
        {
          "code": 400,
          "type": "PEER_ID_INVALID",
          "description": "The provided peer id is invalid"
        },
        {
          "code": 400,
          "type": "SHORTNAME_OCCUPY_FAILED",
          "description": "An internal error occurred"
        },
        {
          "code": 400,
          "type": "STICKERS_EMPTY",
          "description": "No sticker provided"
        },
        {
          "code": 400,
          "type": "STICKER_EMOJI_INVALID",
          "description": "Sticker emoji invalid"
        },
        {
          "code": 400,
          "type": "STICKER_FILE_INVALID",
          "description": "Sticker file invalid"
        },
        {
          "code": 400,
          "type": "STICKER_PNG_DIMENSIONS",
          "description": "Sticker png dimensions invalid"
        },
        {
          "code": 400,
          "type": "STICKER_PNG_NOPNG",
          "description": "One of the specified stickers is not a valid PNG file"
        },
        {
          "code": 400,
          "type": "USER_ID_INVALID",
          "description": "The provided user ID is invalid"
        }
      ]
    },
    "stickers.removeStickerFromSet": {
      "name": "stickers.removeStickerFromSet",
      "description": [
        "Remove a sticker from the set where it belongs, bots only. The sticker set must have been created by the bot."
      ],
      "parameters": {
        "sticker": "The sticker to remove"
      },
      "errors": [
        {
          "code": 400,
          "type": "BOT_MISSING",
          "description": "This method can only be run by a bot"
        },
        {
          "code": 400,
          "type": "STICKER_INVALID",
          "description": "The provided sticker is invalid"
        }
      ]
    },
    "stickers.setStickerSetThumb": {
      "name": "stickers.setStickerSetThumb",
      "description": [
        "Set stickerset thumbnail"
      ],
      "parameters": {
        "stickerset": "Stickerset",
        "thumb": "Thumbnail"
      },
      "errors": [
        {
          "code": 400,
          "type": "STICKERSET_INVALID",
          "description": "The provided sticker set is invalid"
        }
      ]
    },
    "updates.getChannelDifference": {
      "name": "updates.getChannelDifference",
      "description": [
        "Returns the difference between the current state of updates of a certain channel and transmitted."
      ],
      "parameters": {
        "channel": "The channel",
        "filter": "Messsage filter",
        "flags": "Flags, see TL conditional fields",
        "force": "Set to true to skip some possibly unneeded updates and reduce server-side load",
        "limit": "How many updates to fetch, max 100000Ordinary (non-bot) users are supposed to pass 10-100",
        "pts": "Persistent timestamp (see updates)"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHANNEL_INVALID",
          "description": "The provided channel is invalid"
        },
        {
          "code": 400,
          "type": "CHANNEL_PRIVATE",
          "description": "You haven't joined this channel/supergroup"
        },
        {
          "code": 403,
          "type": "CHANNEL_PUBLIC_GROUP_NA",
          "description": "channel/supergroup not available"
        },
        {
          "code": 400,
          "type": "FROM_MESSAGE_BOT_DISABLED",
          "description": "Bots can't use fromMessage min constructors"
        },
        {
          "code": 400,
          "type": "MSG_ID_INVALID",
          "description": "Invalid message ID provided"
        },
        {
          "code": 400,
          "type": "PERSISTENT_TIMESTAMP_EMPTY",
          "description": "Persistent timestamp empty"
        },
        {
          "code": 400,
          "type": "PERSISTENT_TIMESTAMP_INVALID",
          "description": "Persistent timestamp invalid"
        },
        {
          "code": 400,
          "type": "PINNED_DIALOGS_TOO_MUCH",
          "description": "Too many pinned dialogs"
        },
        {
          "code": 400,
          "type": "RANGES_INVALID",
          "description": "Invalid range provided"
        }
      ]
    },
    "updates.getDifference": {
      "name": "updates.getDifference",
      "description": [
        "Get new updates."
      ],
      "parameters": {
        "date": "date, see updates.",
        "flags": "Flags, see TL conditional fields",
        "pts": "PTS, see updates.",
        "pts_total_limit": "For fast updating: if provided and pts + pts_total_limit \u003c remote pts, updates.differenceTooLong will be returned.Simply tells the server to not return the difference if it is bigger than pts_total_limitIf the remote pts is too big (\u003e ~4000000), this field will default to 1000000",
        "qts": "QTS, see updates."
      },
      "errors": [
        {
          "code": 401,
          "type": "AUTH_KEY_PERM_EMPTY",
          "description": "The temporary auth key must be binded to the permanent auth key to use these methods."
        },
        {
          "code": 400,
          "type": "CDN_METHOD_INVALID",
          "description": "You can't call this method in a CDN DC"
        },
        {
          "code": 400,
          "type": "DATE_EMPTY",
          "description": "Date empty"
        },
        {
          "code": 400,
          "type": "PERSISTENT_TIMESTAMP_EMPTY",
          "description": "Persistent timestamp empty"
        },
        {
          "code": 400,
          "type": "PERSISTENT_TIMESTAMP_INVALID",
          "description": "Persistent timestamp invalid"
        }
      ]
    },
    "updates.getState": {
      "name": "updates.getState",
      "description": [
        "Returns a current state of updates."
      ]
    },
    "upload.getCdnFile": {
      "name": "upload.getCdnFile",
      "description": [
        "Download a CDN file."
      ],
      "parameters": {
        "file_token": "File token",
        "limit": "Length of chunk to download",
        "offset": "Offset of chunk to download"
      }
    },
    "upload.getCdnFileHashes": {
      "name": "upload.getCdnFileHashes",
      "description": [
        "Get SHA256 hashes for verifying downloaded CDN files"
      ],
      "parameters": {
        "file_token": "File",
        "offset": "Offset from which to start getting hashes"
      },
      "errors": [
        {
          "code": 400,
          "type": "CDN_METHOD_INVALID",
          "description": "You can't call this method in a CDN DC"
        },
        {
          "code": 400,
          "type": "RSA_DECRYPT_FAILED",
          "description": "Internal RSA decryption failed"
        }
      ]
    },
    "upload.getFile": {
      "name": "upload.getFile",
      "description": [
        "Returns content of a whole file or its part."
      ],
      "parameters": {
        "cdn_supported": "Whether the current client supports CDN downloads",
        "flags": "Flags, see TL conditional fields",
        "limit": "Number of bytes to be returned",
        "location": "File location",
        "offset": "Number of bytes to be skipped",
        "precise": "Disable some checks on limit and offset values, useful for example to stream videos by keyframes"
      },
      "errors": [
        {
          "code": 401,
          "type": "AUTH_KEY_PERM_EMPTY",
          "description": "The temporary auth key must be binded to the permanent auth key to use these methods."
        },
        {
          "code": 400,
          "type": "CHANNEL_INVALID",
          "description": "The provided channel is invalid"
        },
        {
          "code": 400,
          "type": "CHANNEL_PRIVATE",
          "description": "You haven't joined this channel/supergroup"
        },
        {
          "code": 406,
          "type": "FILEREF_UPGRADE_NEEDED",
          "description": "The client has to be updated in order to support file references"
        },
        {
          "code": 400,
          "type": "FILE_ID_INVALID",
          "description": "The provided file id is invalid"
        },
        {
          "code": 400,
          "type": "FILE_REFERENCE_*",
          "description": "The file reference expired, it must be refreshed"
        },
        {
          "code": 400,
          "type": "FILE_REFERENCE_EXPIRED",
          "description": "File reference expired, it must be refetched as described in https://core.telegram.org/api/file_reference"
        },
        {
          "code": 400,
          "type": "LIMIT_INVALID",
          "description": "The provided limit is invalid"
        },
        {
          "code": 400,
          "type": "LOCATION_INVALID",
          "description": "The provided location is invalid"
        },
        {
          "code": 400,
          "type": "MSG_ID_INVALID",
          "description": "Invalid message ID provided"
        },
        {
          "code": 400,
          "type": "OFFSET_INVALID",
          "description": "The provided offset is invalid"
        },
        {
          "code": 400,
          "type": "PEER_ID_INVALID",
          "description": "The provided peer id is invalid"
        }
      ]
    },
    "upload.getFileHashes": {
      "name": "upload.getFileHashes",
      "description": [
        "Get SHA256 hashes for verifying downloaded files"
      ],
      "parameters": {
        "location": "File",
        "offset": "Offset from which to get file hashes"
      },
      "errors": [
        {
          "code": 400,
          "type": "LOCATION_INVALID",
          "description": "The provided location is invalid"
        }
      ]
    },
    "upload.getWebfile": {
      "name": "upload.getWebfile",
      "description": [
        "Returns content of an HTTP file or a part, by proxying the request through telegram."
      ],
      "parameters": {
        "limit": "Number of bytes to be returned",
        "location": "The file to download",
        "offset": "Number of bytes to be skipped"
      },
      "errors": [
        {
          "code": 400,
          "type": "LOCATION_INVALID",
          "description": "The provided location is invalid"
        }
      ]
    },
    "upload.reuploadCdnFile": {
      "name": "upload.reuploadCdnFile",
      "description": [
        "Request a reupload of a certain file to a CDN DC."
      ],
      "parameters": {
        "file_token": "File token",
        "request_token": "Request token"
      },
      "errors": [
        {
          "code": 400,
          "type": "RSA_DECRYPT_FAILED",
          "description": "Internal RSA decryption failed"
        }
      ]
    },
    "upload.saveBigFilePart": {
      "name": "upload.saveBigFilePart",
      "description": [
        "Saves a part of a large file (over 10Mb in size) to be later passed to one of the methods."
      ],
      "parameters": {
        "bytes": "Binary data, part contents",
        "file_id": "Random file id, created by the client",
        "file_part": "Part sequence number",
        "file_total_parts": "Total number of parts"
      },
      "errors": [
        {
          "code": 400,
          "type": "FILE_PARTS_INVALID",
          "description": "The number of file parts is invalid"
        },
        {
          "code": 400,
          "type": "FILE_PART_EMPTY",
          "description": "The provided file part is empty"
        },
        {
          "code": 400,
          "type": "FILE_PART_INVALID",
          "description": "The file part number is invalid"
        },
        {
          "code": 400,
          "type": "FILE_PART_SIZE_CHANGED",
          "description": "Provided file part size has changed"
        },
        {
          "code": 400,
          "type": "FILE_PART_SIZE_INVALID",
          "description": "The provided file part size is invalid"
        },
        {
          "code": 400,
          "type": "FILE_PART_TOO_BIG",
          "description": "The uploaded file part is too big"
        }
      ]
    },
    "upload.saveFilePart": {
      "name": "upload.saveFilePart",
      "description": [
        "Saves a part of file for futher sending to one of the methods."
      ],
      "parameters": {
        "bytes": "Binary data, contend of a part",
        "file_id": "Random file identifier created by the client",
        "file_part": "Numerical order of a part"
      },
      "errors": [
        {
          "code": 400,
          "type": "FILE_PART_EMPTY",
          "description": "The provided file part is empty"
        },
        {
          "code": 400,
          "type": "FILE_PART_INVALID",
          "description": "The file part number is invalid"
        }
      ]
    },
    "users.getFullUser": {
      "name": "users.getFullUser",
      "description": [
        "Returns extended user info by ID."
      ],
      "parameters": {
        "id": "User ID"
      },
      "errors": [
        {
          "code": 400,
          "type": "CHANNEL_PRIVATE",
          "description": "You haven't joined this channel/supergroup"
        },
        {
          "code": 400,
          "type": "MSG_ID_INVALID",
          "description": "Invalid message ID provided"
        },
        {
          "code": 400,
          "type": "USER_ID_INVALID",
          "description": "The provided user ID is invalid"
        }
      ]
    },
    "users.getUsers": {
      "name": "users.getUsers",
      "description": [
        "Returns basic user info according to their identifiers."
      ],
      "parameters": {
        "id": "List of user identifiers"
      },
      "errors": [
        {
          "code": 401,
          "type": "AUTH_KEY_PERM_EMPTY",
          "description": "The temporary auth key must be binded to the permanent auth key to use these methods."
        },
        {
          "code": 400,
          "type": "CHANNEL_PRIVATE",
          "description": "You haven't joined this channel/supergroup"
        },
        {
          "code": 400,
          "type": "CONNECTION_NOT_INITED",
          "description": "Connection not initialized"
        },
        {
          "code": 400,
          "type": "INPUT_LAYER_INVALID",
          "description": "The provided layer is invalid"
        },
        {
          "code": 400,
          "type": "MSG_ID_INVALID",
          "description": "Invalid message ID provided"
        }
      ]
    },
    "users.setSecureValueErrors": {
      "name": "users.setSecureValueErrors",
      "description": [
        "Notify the user that the sent passport data contains some errors The user will not be able to re-submit their Passport data to you until the errors are fixed (the contents of the field for which you returned the error must change).",
        "Use this if the data submitted by the user doesn't satisfy the standards your service requires for any reason. For example, if a birthday date seems invalid, a submitted document is blurry, a scan shows evidence of tampering, etc. Supply some details in the error message to make sure the user knows how to correct the issues."
      ],
      "parameters": {
        "errors": "Errors",
        "id": "The user"
      },
      "errors": [
        {
          "code": 400,
          "type": "USER_ID_INVALID",
          "description": "The provided user ID is invalid"
        }
      ]
    }
  }
}
